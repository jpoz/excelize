// Copyright 2016 - 2025 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.24.0 or later.

package excelize

import (
	"container/list"
	"errors"
	"fmt"
	"math"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	"sync"

	"github.com/xuri/efp"
)

const (
	// Excel formula errors
	formulaErrorDIV         = "#DIV/0!"
	formulaErrorNAME        = "#NAME?"
	formulaErrorNA          = "#N/A"
	formulaErrorNUM         = "#NUM!"
	formulaErrorVALUE       = "#VALUE!"
	formulaErrorREF         = "#REF!"
	formulaErrorNULL        = "#NULL!"
	formulaErrorSPILL       = "#SPILL!"
	formulaErrorCALC        = "#CALC!"
	formulaErrorGETTINGDATA = "#GETTING_DATA"
	// Formula criteria condition enumeration
	_ byte = iota
	criteriaEq
	criteriaLe
	criteriaGe
	criteriaNe
	criteriaL
	criteriaG
	criteriaErr
	criteriaRegexp

	categoryWeightAndMass
	categoryDistance
	categoryTime
	categoryPressure
	categoryForce
	categoryEnergy
	categoryPower
	categoryMagnetism
	categoryTemperature
	categoryVolumeAndLiquidMeasure
	categoryArea
	categoryInformation
	categorySpeed

	matchModeExact      = 0
	matchModeMinGreater = 1
	matchModeMaxLess    = -1
	matchModeWildcard   = 2

	searchModeLinear        = 1
	searchModeReverseLinear = -1
	searchModeAscBinary     = 2
	searchModeDescBinary    = -2

	maxFinancialIterations = 128
	financialPrecision     = 1.0e-08
	// Date and time format regular expressions
	monthRe    = `((jan|january)|(feb|february)|(mar|march)|(apr|april)|(may)|(jun|june)|(jul|july)|(aug|august)|(sep|september)|(oct|october)|(nov|november)|(dec|december))`
	df1        = `(([0-9])+)/(([0-9])+)/(([0-9])+)`
	df2        = monthRe + ` (([0-9])+), (([0-9])+)`
	df3        = `(([0-9])+)-(([0-9])+)-(([0-9])+)`
	df4        = `(([0-9])+)-` + monthRe + `-(([0-9])+)`
	datePrefix = `^((` + df1 + `|` + df2 + `|` + df3 + `|` + df4 + `) )?`
	tfhh       = `(([0-9])+) (am|pm)`
	tfhhmm     = `(([0-9])+):(([0-9])+)( (am|pm))?`
	tfmmss     = `(([0-9])+):(([0-9])+\.([0-9])+)( (am|pm))?`
	tfhhmmss   = `(([0-9])+):(([0-9])+):(([0-9])+(\.([0-9])+)?)( (am|pm))?`
	timeSuffix = `( (` + tfhh + `|` + tfhhmm + `|` + tfmmss + `|` + tfhhmmss + `))?$`
)

var (
	// tokenPriority defined basic arithmetic operator priority
	tokenPriority = map[string]int{
		"^":  5,
		"*":  4,
		"/":  4,
		"+":  3,
		"-":  3,
		"&":  2,
		"=":  1,
		"<>": 1,
		"<":  1,
		"<=": 1,
		">":  1,
		">=": 1,
	}
	month2num = map[string]int{
		"january":   1,
		"february":  2,
		"march":     3,
		"april":     4,
		"may":       5,
		"june":      6,
		"july":      7,
		"august":    8,
		"september": 9,
		"october":   10,
		"november":  11,
		"december":  12,
		"jan":       1,
		"feb":       2,
		"mar":       3,
		"apr":       4,
		"jun":       6,
		"jul":       7,
		"aug":       8,
		"sep":       9,
		"oct":       10,
		"nov":       11,
		"dec":       12,
	}
	dateFormats = map[string]*regexp.Regexp{
		"mm/dd/yy":    regexp.MustCompile(`^` + df1 + timeSuffix),
		"mm dd, yy":   regexp.MustCompile(`^` + df2 + timeSuffix),
		"yy-mm-dd":    regexp.MustCompile(`^` + df3 + timeSuffix),
		"yy-mmStr-dd": regexp.MustCompile(`^` + df4 + timeSuffix),
	}
	timeFormats = map[string]*regexp.Regexp{
		"hh":       regexp.MustCompile(datePrefix + tfhh + `$`),
		"hh:mm":    regexp.MustCompile(datePrefix + tfhhmm + `$`),
		"mm:ss":    regexp.MustCompile(datePrefix + tfmmss + `$`),
		"hh:mm:ss": regexp.MustCompile(datePrefix + tfhhmmss + `$`),
	}
	dateOnlyFormats = []*regexp.Regexp{
		regexp.MustCompile(`^` + df1 + `$`),
		regexp.MustCompile(`^` + df2 + `$`),
		regexp.MustCompile(`^` + df3 + `$`),
		regexp.MustCompile(`^` + df4 + `$`),
	}
	addressFmtMaps = map[string]func(col, row int) (string, error){
		"1_TRUE": func(col, row int) (string, error) {
			return CoordinatesToCellName(col, row, true)
		},
		"1_FALSE": func(col, row int) (string, error) {
			return fmt.Sprintf("R%dC%d", row, col), nil
		},
		"2_TRUE": func(col, row int) (string, error) {
			column, err := ColumnNumberToName(col)
			if err != nil {
				return "", err
			}
			return fmt.Sprintf("%s$%d", column, row), nil
		},
		"2_FALSE": func(col, row int) (string, error) {
			return fmt.Sprintf("R%dC[%d]", row, col), nil
		},
		"3_TRUE": func(col, row int) (string, error) {
			column, err := ColumnNumberToName(col)
			if err != nil {
				return "", err
			}
			return fmt.Sprintf("$%s%d", column, row), nil
		},
		"3_FALSE": func(col, row int) (string, error) {
			return fmt.Sprintf("R[%d]C%d", row, col), nil
		},
		"4_TRUE": func(col, row int) (string, error) {
			return CoordinatesToCellName(col, row, false)
		},
		"4_FALSE": func(col, row int) (string, error) {
			return fmt.Sprintf("R[%d]C[%d]", row, col), nil
		},
	}
	formulaFnNameReplacer = strings.NewReplacer("_xlfn.", "", ".", "dot")
	formulaFormats        = []*regexp.Regexp{
		regexp.MustCompile(`^(\d+)$`),
		regexp.MustCompile(`^=(.*)$`),
		regexp.MustCompile(`^<>(.*)$`),
		regexp.MustCompile(`^<=(.*)$`),
		regexp.MustCompile(`^>=(.*)$`),
		regexp.MustCompile(`^<(.*)$`),
		regexp.MustCompile(`^>(.*)$`),
	}
	formulaCriterias = []byte{
		criteriaEq,
		criteriaEq,
		criteriaNe,
		criteriaLe,
		criteriaGe,
		criteriaL,
		criteriaG,
	}
	// defines numbers text in the Thai used for the BAHTTEXT formula function.
	th0      = "\u0E28\u0E39\u0E19\u0E22\u0E4C"
	th1      = "\u0E2B\u0E19\u0E36\u0E48\u0E07"
	th2      = "\u0E2A\u0E2D\u0E07"
	th3      = "\u0E2A\u0E32\u0E21"
	th4      = "\u0E2A\u0E35\u0E48"
	th5      = "\u0E2B\u0E49\u0E32"
	th6      = "\u0E2B\u0E01"
	th7      = "\u0E40\u0E08\u0E47\u0E14"
	th8      = "\u0E41\u0E1B\u0E14"
	th9      = "\u0E40\u0E01\u0E49\u0E32"
	th10     = "\u0E2A\u0E34\u0E1A"
	th11     = "\u0E40\u0E2D\u0E47\u0E14"
	th20     = "\u0E22\u0E35\u0E48"
	th1e2    = "\u0E23\u0E49\u0E2D\u0E22"
	th1e3    = "\u0E1E\u0E31\u0E19"
	th1e4    = "\u0E2B\u0E21\u0E37\u0E48\u0E19"
	th1e5    = "\u0E41\u0E2A\u0E19"
	th1e6    = "\u0E25\u0E49\u0E32\u0E19"
	thDot0   = "\u0E16\u0E49\u0E27\u0E19"
	thBaht   = "\u0E1A\u0E32\u0E17"
	thSatang = "\u0E2A\u0E15\u0E32\u0E07\u0E04\u0E4C"
	thMinus  = "\u0E25\u0E1A"
)

// calcContext defines the formula execution context.
type calcContext struct {
	mu                sync.Mutex
	entry             string
	maxCalcIterations uint
	iterations        map[string]uint
	iterationsCache   map[string]formulaArg
}

// cellRef defines the structure of a cell reference.
type cellRef struct {
	Col   int
	Row   int
	Sheet string
}

// cellRef defines the structure of a cell range.
type cellRange struct {
	From cellRef
	To   cellRef
}

// formulaCriteria defined formula criteria parser result.
type formulaCriteria struct {
	Type      byte
	Condition formulaArg
}

// ArgType is the type of formula argument type.
type ArgType byte

// Formula argument types enumeration.
const (
	ArgUnknown ArgType = iota
	ArgNumber
	ArgString
	ArgList
	ArgMatrix
	ArgError
	ArgEmpty
)

// formulaArg is the argument of a formula or function.
type formulaArg struct {
	SheetName            string
	Number               float64
	String               string
	List                 []formulaArg
	Matrix               [][]formulaArg
	Boolean              bool
	Error                string
	Type                 ArgType
	cellRefs, cellRanges *list.List
}

// Value returns a string data type of the formula argument.
func (fa formulaArg) Value() (value string) {
	switch fa.Type {
	case ArgNumber:
		if fa.Boolean {
			if fa.Number == 0 {
				return "FALSE"
			}
			return "TRUE"
		}
		return fmt.Sprintf("%g", fa.Number)
	case ArgString:
		return fa.String
	case ArgMatrix:
		if args := fa.ToList(); len(args) > 0 {
			return args[0].Value()
		}
	case ArgError:
		return fa.Error
	}
	return
}

// ToNumber returns a formula argument with number data type.
func (fa formulaArg) ToNumber() formulaArg {
	var n float64
	var err error
	switch fa.Type {
	case ArgString:
		n, err = strconv.ParseFloat(fa.String, 64)
		if err != nil {
			return newErrorFormulaArg(formulaErrorVALUE, err.Error())
		}
	case ArgNumber:
		n = fa.Number
	case ArgMatrix:
		if args := fa.ToList(); len(args) > 0 {
			return args[0].ToNumber()
		}
	}
	return newNumberFormulaArg(n)
}

// ToBool returns a formula argument with boolean data type.
func (fa formulaArg) ToBool() formulaArg {
	var b bool
	var err error
	switch fa.Type {
	case ArgString:
		b, err = strconv.ParseBool(fa.String)
		if err != nil {
			return newErrorFormulaArg(formulaErrorVALUE, err.Error())
		}
	case ArgNumber:
		if fa.Number == 1 {
			b = true
		}
	}
	return newBoolFormulaArg(b)
}

// ToList returns a formula argument with array data type.
func (fa formulaArg) ToList() []formulaArg {
	switch fa.Type {
	case ArgMatrix:
		var args []formulaArg
		for _, row := range fa.Matrix {
			args = append(args, row...)
		}
		return args
	case ArgList:
		return fa.List
	case ArgNumber, ArgString, ArgError, ArgUnknown:
		return []formulaArg{fa}
	}
	return nil
}

// formulaFuncs is the type of the formula functions.
type formulaFuncs struct {
	f           *File
	ctx         *calcContext
	sheet, cell string
}

// CalcCellValue provides a function to get calculated cell value. This feature
// is currently in working processing. Iterative calculation, implicit
// intersection, explicit intersection, array formula, table formula and some
// other formulas are not supported currently.
//
// Supported formula functions:
//
//	ABS
//	ACCRINT
//	ACCRINTM
//	ACOS
//	ACOSH
//	ACOT
//	ACOTH
//	ADDRESS
//	AGGREGATE
//	AMORDEGRC
//	AMORLINC
//	AND
//	ARABIC
//	ARRAYTOTEXT
//	ASIN
//	ASINH
//	ATAN
//	ATAN2
//	ATANH
//	AVEDEV
//	AVERAGE
//	AVERAGEA
//	AVERAGEIF
//	AVERAGEIFS
//	BAHTTEXT
//	BASE
//	BESSELI
//	BESSELJ
//	BESSELK
//	BESSELY
//	BETA.DIST
//	BETA.INV
//	BETADIST
//	BETAINV
//	BIN2DEC
//	BIN2HEX
//	BIN2OCT
//	BINOM.DIST
//	BINOM.DIST.RANGE
//	BINOM.INV
//	BINOMDIST
//	BITAND
//	BITLSHIFT
//	BITOR
//	BITRSHIFT
//	BITXOR
//	CEILING
//	CEILING.MATH
//	CEILING.PRECISE
//	CHAR
//	CHIDIST
//	CHIINV
//	CHISQ.DIST
//	CHISQ.DIST.RT
//	CHISQ.INV
//	CHISQ.INV.RT
//	CHISQ.TEST
//	CHITEST
//	CHOOSE
//	CLEAN
//	CODE
//	COLUMN
//	COLUMNS
//	COMBIN
//	COMBINA
//	COMPLEX
//	CONCAT
//	CONCATENATE
//	CONFIDENCE
//	CONFIDENCE.NORM
//	CONFIDENCE.T
//	CONVERT
//	CORREL
//	COS
//	COSH
//	COT
//	COTH
//	COUNT
//	COUNTA
//	COUNTBLANK
//	COUNTIF
//	COUNTIFS
//	COUPDAYBS
//	COUPDAYS
//	COUPDAYSNC
//	COUPNCD
//	COUPNUM
//	COUPPCD
//	COVAR
//	COVARIANCE.P
//	COVARIANCE.S
//	CRITBINOM
//	CSC
//	CSCH
//	CUMIPMT
//	CUMPRINC
//	DATE
//	DATEDIF
//	DATEVALUE
//	DAVERAGE
//	DAY
//	DAYS
//	DAYS360
//	DB
//	DBCS
//	DCOUNT
//	DCOUNTA
//	DDB
//	DEC2BIN
//	DEC2HEX
//	DEC2OCT
//	DECIMAL
//	DEGREES
//	DELTA
//	DEVSQ
//	DGET
//	DISC
//	DMAX
//	DMIN
//	DOLLAR
//	DOLLARDE
//	DOLLARFR
//	DPRODUCT
//	DSTDEV
//	DSTDEVP
//	DSUM
//	DURATION
//	DVAR
//	DVARP
//	EDATE
//	EFFECT
//	ENCODEURL
//	EOMONTH
//	ERF
//	ERF.PRECISE
//	ERFC
//	ERFC.PRECISE
//	ERROR.TYPE
//	EUROCONVERT
//	EVEN
//	EXACT
//	EXP
//	EXPON.DIST
//	EXPONDIST
//	F.DIST
//	F.DIST.RT
//	F.INV
//	F.INV.RT
//	F.TEST
//	FACT
//	FACTDOUBLE
//	FALSE
//	FDIST
//	FIND
//	FINDB
//	FINV
//	FISHER
//	FISHERINV
//	FIXED
//	FLOOR
//	FLOOR.MATH
//	FLOOR.PRECISE
//	FORECAST
//	FORECAST.LINEAR
//	FORMULATEXT
//	FREQUENCY
//	FTEST
//	FV
//	FVSCHEDULE
//	GAMMA
//	GAMMA.DIST
//	GAMMA.INV
//	GAMMADIST
//	GAMMAINV
//	GAMMALN
//	GAMMALN.PRECISE
//	GAUSS
//	GCD
//	GEOMEAN
//	GESTEP
//	GROWTH
//	HARMEAN
//	HEX2BIN
//	HEX2DEC
//	HEX2OCT
//	HLOOKUP
//	HOUR
//	HYPERLINK
//	HYPGEOM.DIST
//	HYPGEOMDIST
//	IF
//	IFERROR
//	IFNA
//	IFS
//	IMABS
//	IMAGINARY
//	IMARGUMENT
//	IMCONJUGATE
//	IMCOS
//	IMCOSH
//	IMCOT
//	IMCSC
//	IMCSCH
//	IMDIV
//	IMEXP
//	IMLN
//	IMLOG10
//	IMLOG2
//	IMPOWER
//	IMPRODUCT
//	IMREAL
//	IMSEC
//	IMSECH
//	IMSIN
//	IMSINH
//	IMSQRT
//	IMSUB
//	IMSUM
//	IMTAN
//	INDEX
//	INDIRECT
//	INT
//	INTERCEPT
//	INTRATE
//	IPMT
//	IRR
//	ISBLANK
//	ISERR
//	ISERROR
//	ISEVEN
//	ISFORMULA
//	ISLOGICAL
//	ISNA
//	ISNONTEXT
//	ISNUMBER
//	ISO.CEILING
//	ISODD
//	ISOWEEKNUM
//	ISPMT
//	ISREF
//	ISTEXT
//	KURT
//	LARGE
//	LCM
//	LEFT
//	LEFTB
//	LEN
//	LENB
//	LN
//	LOG
//	LOG10
//	LOGINV
//	LOGNORM.DIST
//	LOGNORM.INV
//	LOGNORMDIST
//	LOOKUP
//	LOWER
//	MATCH
//	MAX
//	MAXA
//	MAXIFS
//	MDETERM
//	MDURATION
//	MEDIAN
//	MID
//	MIDB
//	MIN
//	MINA
//	MINIFS
//	MINUTE
//	MINVERSE
//	MIRR
//	MMULT
//	MOD
//	MODE
//	MODE.MULT
//	MODE.SNGL
//	MONTH
//	MROUND
//	MULTINOMIAL
//	MUNIT
//	N
//	NA
//	NEGBINOM.DIST
//	NEGBINOMDIST
//	NETWORKDAYS
//	NETWORKDAYS.INTL
//	NOMINAL
//	NORM.DIST
//	NORM.INV
//	NORM.S.DIST
//	NORM.S.INV
//	NORMDIST
//	NORMINV
//	NORMSDIST
//	NORMSINV
//	NOT
//	NOW
//	NPER
//	NPV
//	OCT2BIN
//	OCT2DEC
//	OCT2HEX
//	ODD
//	ODDFPRICE
//	ODDFYIELD
//	ODDLPRICE
//	ODDLYIELD
//	OR
//	PDURATION
//	PEARSON
//	PERCENTILE
//	PERCENTILE.EXC
//	PERCENTILE.INC
//	PERCENTRANK
//	PERCENTRANK.EXC
//	PERCENTRANK.INC
//	PERMUT
//	PERMUTATIONA
//	PHI
//	PI
//	PMT
//	POISSON
//	POISSON.DIST
//	POWER
//	PPMT
//	PRICE
//	PRICEDISC
//	PRICEMAT
//	PROB
//	PRODUCT
//	PROPER
//	PV
//	QUARTILE
//	QUARTILE.EXC
//	QUARTILE.INC
//	QUOTIENT
//	RADIANS
//	RAND
//	RANDBETWEEN
//	RANK
//	RANK.EQ
//	RATE
//	RECEIVED
//	REPLACE
//	REPLACEB
//	REPT
//	RIGHT
//	RIGHTB
//	ROMAN
//	ROUND
//	ROUNDDOWN
//	ROUNDUP
//	ROW
//	ROWS
//	RRI
//	RSQ
//	SEARCH
//	SEARCHB
//	SEC
//	SECH
//	SECOND
//	SERIESSUM
//	SHEET
//	SHEETS
//	SIGN
//	SIN
//	SINH
//	SKEW
//	SKEW.P
//	SLN
//	SLOPE
//	SMALL
//	SQRT
//	SQRTPI
//	STANDARDIZE
//	STDEV
//	STDEV.P
//	STDEV.S
//	STDEVA
//	STDEVP
//	STDEVPA
//	STEYX
//	SUBSTITUTE
//	SUBTOTAL
//	SUM
//	SUMIF
//	SUMIFS
//	SUMPRODUCT
//	SUMSQ
//	SUMX2MY2
//	SUMX2PY2
//	SUMXMY2
//	SWITCH
//	SYD
//	T
//	T.DIST
//	T.DIST.2T
//	T.DIST.RT
//	T.INV
//	T.INV.2T
//	T.TEST
//	TAN
//	TANH
//	TBILLEQ
//	TBILLPRICE
//	TBILLYIELD
//	TDIST
//	TEXT
//	TEXTAFTER
//	TEXTBEFORE
//	TEXTJOIN
//	TIME
//	TIMEVALUE
//	TINV
//	TODAY
//	TRANSPOSE
//	TREND
//	TRIM
//	TRIMMEAN
//	TRUE
//	TRUNC
//	TTEST
//	TYPE
//	UNICHAR
//	UNICODE
//	UNIQUE
//	UPPER
//	VALUE
//	VALUETOTEXT
//	VAR
//	VAR.P
//	VAR.S
//	VARA
//	VARP
//	VARPA
//	VDB
//	VLOOKUP
//	WEEKDAY
//	WEEKNUM
//	WEIBULL
//	WEIBULL.DIST
//	WORKDAY
//	WORKDAY.INTL
//	XIRR
//	XLOOKUP
//	XNPV
//	XOR
//	YEAR
//	YEARFRAC
//	YIELD
//	YIELDDISC
//	YIELDMAT
//	Z.TEST
//	ZTEST
func (f *File) CalcCellValue(sheet, cell string, opts ...Options) (result string, err error) {
	entry := sheet + "!" + cell
	if cachedResult, ok := f.calcCache.Load(entry); ok {
		return cachedResult.(string), nil
	}
	options := f.getOptions(opts...)
	var (
		rawCellValue = options.RawCellValue
		styleIdx     int
		token        formulaArg
	)
	if token, err = f.calcCellValue(&calcContext{
		entry:             entry,
		maxCalcIterations: options.MaxCalcIterations,
		iterations:        make(map[string]uint),
		iterationsCache:   make(map[string]formulaArg),
	}, sheet, cell); err != nil {
		result = token.String
		return
	}
	if !rawCellValue {
		styleIdx, _ = f.GetCellStyle(sheet, cell)
	}
	if token.Type == ArgNumber && !token.Boolean {
		_, precision, decimal := isNumeric(token.Value())
		if precision > 15 {
			result, err = f.formattedValue(&xlsxC{S: styleIdx, V: strings.ToUpper(strconv.FormatFloat(decimal, 'G', 15, 64))}, rawCellValue, CellTypeNumber)
			if err == nil {
				f.calcCache.Store(entry, result)
			}
			return
		}
		if !strings.HasPrefix(result, "0") {
			result, err = f.formattedValue(&xlsxC{S: styleIdx, V: strings.ToUpper(strconv.FormatFloat(decimal, 'f', -1, 64))}, rawCellValue, CellTypeNumber)
		}
		if err == nil {
			f.calcCache.Store(entry, result)
		}
		return
	}
	result, err = f.formattedValue(&xlsxC{S: styleIdx, V: token.Value()}, rawCellValue, CellTypeInlineString)
	if err == nil {
		f.calcCache.Store(entry, result)
	}
	return
}

// clearCalcCache clear all calculation related caches.
func (f *File) clearCalcCache() {
	f.calcCache.Clear()
	f.formulaArgCache.Clear()
}

// calcCellValue calculate cell value by given context, worksheet name and cell
// reference.
func (f *File) calcCellValue(ctx *calcContext, sheet, cell string) (result formulaArg, err error) {
	var formula string
	if formula, err = f.getCellFormula(sheet, cell, true); err != nil {
		return
	}
	ps := efp.ExcelParser()
	tokens := ps.Parse(formula)
	if tokens == nil {
		return f.cellResolver(ctx, sheet, cell)
	}
	result, err = f.evalInfixExp(ctx, sheet, cell, tokens)
	return
}

// getPriority calculate arithmetic operator priority.
func getPriority(token efp.Token) (pri int) {
	pri = tokenPriority[token.TValue]
	if token.TValue == "-" && token.TType == efp.TokenTypeOperatorPrefix {
		pri = 6
	}
	if isBeginParenthesesToken(token) { // (
		pri = 0
	}
	return
}

// newNumberFormulaArg constructs a number formula argument.
func newNumberFormulaArg(n float64) formulaArg {
	if math.IsNaN(n) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return formulaArg{Type: ArgNumber, Number: n}
}

// newStringFormulaArg constructs a string formula argument.
func newStringFormulaArg(s string) formulaArg {
	return formulaArg{Type: ArgString, String: s}
}

// newMatrixFormulaArg constructs a matrix formula argument.
func newMatrixFormulaArg(m [][]formulaArg) formulaArg {
	return formulaArg{Type: ArgMatrix, Matrix: m}
}

// newListFormulaArg create a list formula argument.
func newListFormulaArg(l []formulaArg) formulaArg {
	return formulaArg{Type: ArgList, List: l}
}

// newBoolFormulaArg constructs a boolean formula argument.
func newBoolFormulaArg(b bool) formulaArg {
	var n float64
	if b {
		n = 1
	}
	return formulaArg{Type: ArgNumber, Number: n, Boolean: true}
}

// newErrorFormulaArg create an error formula argument of a given type with a
// specified error message.
func newErrorFormulaArg(formulaError, msg string) formulaArg {
	return formulaArg{Type: ArgError, String: formulaError, Error: msg}
}

// newEmptyFormulaArg create an empty formula argument.
func newEmptyFormulaArg() formulaArg {
	return formulaArg{Type: ArgEmpty}
}

// evalInfixExp evaluate syntax analysis by given infix expression after
// lexical analysis. Evaluate an infix expression containing formulas by
// stacks:
//
//	opd  - Operand
//	opt  - Operator
//	opf  - Operation formula
//	opfd - Operand of the operation formula
//	opft - Operator of the operation formula
//	args - Arguments list of the operation formula
//
// TODO: handle subtypes: Nothing, Text, Logical, Error, Concatenation, Intersection, Union
func (f *File) evalInfixExp(ctx *calcContext, sheet, cell string, tokens []efp.Token) (formulaArg, error) {
	var (
		err                             error
		inArray, inArrayRow             bool
		formulaArray                    [][]formulaArg
		formulaArrayRow                 []formulaArg
		opdStack, optStack, opfStack    = NewStack(), NewStack(), NewStack()
		opfdStack, opftStack, argsStack = NewStack(), NewStack(), NewStack()
	)
	for i := 0; i < len(tokens); i++ {
		token := tokens[i]

		// out of function stack
		if opfStack.Len() == 0 {
			if err = f.parseToken(ctx, sheet, token, opdStack, optStack); err != nil {
				return newEmptyFormulaArg(), err
			}
		}

		// function start
		if isFunctionStartToken(token) {
			if token.TValue == "ARRAY" {
				inArray, formulaArray = true, [][]formulaArg{}
				continue
			}
			if token.TValue == "ARRAYROW" {
				inArrayRow, formulaArrayRow = true, []formulaArg{}
				continue
			}
			opfStack.Push(token)
			argsStack.Push(list.New().Init())
			opftStack.Push(token) // to know which operators belong to a function use the function as a separator
			continue
		}

		// in function stack, walk 2 token at once
		if opfStack.Len() > 0 {
			var nextToken efp.Token
			if i+1 < len(tokens) {
				nextToken = tokens[i+1]
			}

			// current token is args or range, skip next token, order required: parse reference first
			if token.TSubType == efp.TokenSubTypeRange {
				if opftStack.Peek().(efp.Token) != opfStack.Peek().(efp.Token) {
					refTo := f.getDefinedNameRefTo(token.TValue, sheet)
					if refTo != "" {
						token.TValue = refTo
					}
					// parse reference: must reference at here
					result, err := f.parseReference(ctx, sheet, token.TValue)
					if err != nil {
						return result, err
					}
					opfdStack.Push(result)
					continue
				}
				if nextToken.TType == efp.TokenTypeArgument || nextToken.TType == efp.TokenTypeFunction {
					// parse reference: reference or range at here
					refTo := f.getDefinedNameRefTo(token.TValue, sheet)
					if refTo != "" {
						token.TValue = refTo
					}
					result, err := f.parseReference(ctx, sheet, token.TValue)
					if err != nil {
						return result, err
					}
					// when current token is range, next token is argument and opfdStack not empty,
					// should push value to opfdStack and continue
					if nextToken.TType == efp.TokenTypeArgument && !opfdStack.Empty() {
						opfdStack.Push(result)
						continue
					}
					argsStack.Peek().(*list.List).PushBack(result)
					continue
				}
			}

			// check current token is opft
			if err = f.parseToken(ctx, sheet, token, opfdStack, opftStack); err != nil {
				return newEmptyFormulaArg(), err
			}

			// current token is arg
			if token.TType == efp.TokenTypeArgument {
				for opftStack.Peek().(efp.Token) != opfStack.Peek().(efp.Token) {
					// calculate trigger
					topOpt := opftStack.Peek().(efp.Token)
					if err := calculate(opfdStack, topOpt); err != nil {
						argsStack.Peek().(*list.List).PushFront(newErrorFormulaArg(formulaErrorVALUE, err.Error()))
					}
					opftStack.Pop()
				}
				if !opfdStack.Empty() {
					argsStack.Peek().(*list.List).PushBack(opfdStack.Pop().(formulaArg))
				}
				continue
			}

			if inArrayRow && isOperand(token) {
				formulaArrayRow = append(formulaArrayRow, opfdStack.Pop().(formulaArg))
				continue
			}
			if inArrayRow && isFunctionStopToken(token) {
				formulaArray = append(formulaArray, formulaArrayRow)
				inArrayRow = false
				continue
			}
			if inArray && isFunctionStopToken(token) {
				argsStack.Peek().(*list.List).PushBack(newMatrixFormulaArg(formulaArray))
				inArray = false
				continue
			}
			if errArg := f.evalInfixExpFunc(ctx, sheet, cell, token, nextToken, opfStack, opdStack, opftStack, opfdStack, argsStack); errArg.Type == ArgError {
				return errArg, errors.New(errArg.Error)
			}
		}
	}
	for optStack.Len() != 0 {
		topOpt := optStack.Peek().(efp.Token)
		if err = calculate(opdStack, topOpt); err != nil {
			return newEmptyFormulaArg(), err
		}
		optStack.Pop()
	}
	if opdStack.Len() == 0 {
		return newEmptyFormulaArg(), ErrInvalidFormula
	}
	return opdStack.Peek().(formulaArg), err
}

// evalInfixExpFunc evaluate formula function in the infix expression.
func (f *File) evalInfixExpFunc(ctx *calcContext, sheet, cell string, token, nextToken efp.Token, opfStack, opdStack, opftStack, opfdStack, argsStack *Stack) formulaArg {
	if !isFunctionStopToken(token) {
		return newEmptyFormulaArg()
	}
	prepareEvalInfixExp(opfStack, opftStack, opfdStack, argsStack)
	// call formula function to evaluate
	arg := callFuncByName(&formulaFuncs{f: f, sheet: sheet, cell: cell, ctx: ctx},
		formulaFnNameReplacer.Replace(opfStack.Peek().(efp.Token).TValue),
		[]reflect.Value{reflect.ValueOf(argsStack.Peek().(*list.List))})
	if arg.Type == ArgError && opfStack.Len() == 1 {
		return arg
	}
	argsStack.Pop()
	opftStack.Pop() // remove current function separator
	opfStack.Pop()
	if opfStack.Len() > 0 { // still in function stack
		if nextToken.TType == efp.TokenTypeOperatorInfix || opftStack.Len() > 1 {
			// mathematics calculate in formula function
			opfdStack.Push(arg)
			return newEmptyFormulaArg()
		}
		argsStack.Peek().(*list.List).PushBack(arg)
		return newEmptyFormulaArg()
	}
	if arg.Type == ArgMatrix && len(arg.Matrix) > 0 && len(arg.Matrix[0]) > 0 {
		opdStack.Push(arg.Matrix[0][0])
		return newEmptyFormulaArg()
	}
	opdStack.Push(arg)
	return newEmptyFormulaArg()
}

// prepareEvalInfixExp check the token and stack state for formula function
// evaluate.
func prepareEvalInfixExp(opfStack, opftStack, opfdStack, argsStack *Stack) {
	// current token is function stop
	for opftStack.Peek().(efp.Token) != opfStack.Peek().(efp.Token) {
		// calculate trigger
		topOpt := opftStack.Peek().(efp.Token)
		if err := calculate(opfdStack, topOpt); err != nil {
			argsStack.Peek().(*list.List).PushBack(newErrorFormulaArg(err.Error(), err.Error()))
			opftStack.Pop()
			continue
		}
		opftStack.Pop()
	}
	argument := true
	if opftStack.Len() > 2 && opfdStack.Len() == 1 {
		topOpt := opftStack.Pop()
		if opftStack.Peek().(efp.Token).TType == efp.TokenTypeOperatorInfix {
			argument = false
		}
		opftStack.Push(topOpt)
	}
	// push opfd to args
	if argument && opfdStack.Len() > 0 {
		argsStack.Peek().(*list.List).PushBack(opfdStack.Pop().(formulaArg))
	}
}

// calcPow evaluate exponentiation arithmetic operations.
func calcPow(rOpd, lOpd formulaArg, opdStack *Stack) error {
	lOpdVal := lOpd.ToNumber()
	if lOpdVal.Type != ArgNumber {
		return errors.New(lOpdVal.Value())
	}
	rOpdVal := rOpd.ToNumber()
	if rOpdVal.Type != ArgNumber {
		return errors.New(rOpdVal.Value())
	}
	opdStack.Push(newNumberFormulaArg(math.Pow(lOpdVal.Number, rOpdVal.Number)))
	return nil
}

// calcEq evaluate equal arithmetic operations.
func calcEq(rOpd, lOpd formulaArg, opdStack *Stack) error {
	opdStack.Push(newBoolFormulaArg(rOpd.Value() == lOpd.Value()))
	return nil
}

// calcNEq evaluate not equal arithmetic operations.
func calcNEq(rOpd, lOpd formulaArg, opdStack *Stack) error {
	opdStack.Push(newBoolFormulaArg(rOpd.Value() != lOpd.Value()))
	return nil
}

// calcL evaluate less than arithmetic operations.
func calcL(rOpd, lOpd formulaArg, opdStack *Stack) error {
	if rOpd.Type == ArgNumber && lOpd.Type == ArgNumber {
		opdStack.Push(newBoolFormulaArg(lOpd.Number < rOpd.Number))
	}
	if rOpd.Type == ArgString && lOpd.Type == ArgString {
		opdStack.Push(newBoolFormulaArg(strings.Compare(lOpd.Value(), rOpd.Value()) == -1))
	}
	if rOpd.Type == ArgNumber && lOpd.Type == ArgString {
		opdStack.Push(newBoolFormulaArg(false))
	}
	if rOpd.Type == ArgString && lOpd.Type == ArgNumber {
		opdStack.Push(newBoolFormulaArg(true))
	}
	return nil
}

// calcLe evaluate less than or equal arithmetic operations.
func calcLe(rOpd, lOpd formulaArg, opdStack *Stack) error {
	if rOpd.Type == ArgNumber && lOpd.Type == ArgNumber {
		opdStack.Push(newBoolFormulaArg(lOpd.Number <= rOpd.Number))
	}
	if rOpd.Type == ArgString && lOpd.Type == ArgString {
		opdStack.Push(newBoolFormulaArg(strings.Compare(lOpd.Value(), rOpd.Value()) != 1))
	}
	if rOpd.Type == ArgNumber && lOpd.Type == ArgString {
		opdStack.Push(newBoolFormulaArg(false))
	}
	if rOpd.Type == ArgString && lOpd.Type == ArgNumber {
		opdStack.Push(newBoolFormulaArg(true))
	}
	return nil
}

// calcG evaluate greater than arithmetic operations.
func calcG(rOpd, lOpd formulaArg, opdStack *Stack) error {
	if rOpd.Type == ArgNumber && lOpd.Type == ArgNumber {
		opdStack.Push(newBoolFormulaArg(lOpd.Number > rOpd.Number))
	}
	if rOpd.Type == ArgString && lOpd.Type == ArgString {
		opdStack.Push(newBoolFormulaArg(strings.Compare(lOpd.Value(), rOpd.Value()) == 1))
	}
	if rOpd.Type == ArgNumber && lOpd.Type == ArgString {
		opdStack.Push(newBoolFormulaArg(true))
	}
	if rOpd.Type == ArgString && lOpd.Type == ArgNumber {
		opdStack.Push(newBoolFormulaArg(false))
	}
	return nil
}

// calcGe evaluate greater than or equal arithmetic operations.
func calcGe(rOpd, lOpd formulaArg, opdStack *Stack) error {
	if rOpd.Type == ArgNumber && lOpd.Type == ArgNumber {
		opdStack.Push(newBoolFormulaArg(lOpd.Number >= rOpd.Number))
	}
	if rOpd.Type == ArgString && lOpd.Type == ArgString {
		opdStack.Push(newBoolFormulaArg(strings.Compare(lOpd.Value(), rOpd.Value()) != -1))
	}
	if rOpd.Type == ArgNumber && lOpd.Type == ArgString {
		opdStack.Push(newBoolFormulaArg(true))
	}
	if rOpd.Type == ArgString && lOpd.Type == ArgNumber {
		opdStack.Push(newBoolFormulaArg(false))
	}
	return nil
}

// calcSplice evaluate splice '&' operations.
func calcSplice(rOpd, lOpd formulaArg, opdStack *Stack) error {
	opdStack.Push(newStringFormulaArg(lOpd.Value() + rOpd.Value()))
	return nil
}

// calcAdd evaluate addition arithmetic operations.
func calcAdd(rOpd, lOpd formulaArg, opdStack *Stack) error {
	lOpdVal := lOpd.ToNumber()
	if lOpdVal.Type != ArgNumber {
		return errors.New(lOpdVal.Value())
	}
	rOpdVal := rOpd.ToNumber()
	if rOpdVal.Type != ArgNumber {
		return errors.New(rOpdVal.Value())
	}
	opdStack.Push(newNumberFormulaArg(lOpdVal.Number + rOpdVal.Number))
	return nil
}

// calcSubtract evaluate subtraction arithmetic operations.
func calcSubtract(rOpd, lOpd formulaArg, opdStack *Stack) error {
	if rOpd.Value() == "" {
		rOpd = newNumberFormulaArg(0)
	}
	if lOpd.Value() == "" {
		lOpd = newNumberFormulaArg(0)
	}
	lOpdVal := lOpd.ToNumber()
	if lOpdVal.Type != ArgNumber {
		return errors.New(lOpdVal.Value())
	}
	rOpdVal := rOpd.ToNumber()
	if rOpdVal.Type != ArgNumber {
		return errors.New(rOpdVal.Value())
	}
	opdStack.Push(newNumberFormulaArg(lOpdVal.Number - rOpdVal.Number))
	return nil
}

// calcMultiply evaluate multiplication arithmetic operations.
func calcMultiply(rOpd, lOpd formulaArg, opdStack *Stack) error {
	lOpdVal := lOpd.ToNumber()
	if lOpdVal.Type != ArgNumber {
		return errors.New(lOpdVal.Value())
	}
	rOpdVal := rOpd.ToNumber()
	if rOpdVal.Type != ArgNumber {
		return errors.New(rOpdVal.Value())
	}
	opdStack.Push(newNumberFormulaArg(lOpdVal.Number * rOpdVal.Number))
	return nil
}

// calcDiv evaluate division arithmetic operations.
func calcDiv(rOpd, lOpd formulaArg, opdStack *Stack) error {
	lOpdVal := lOpd.ToNumber()
	if lOpdVal.Type != ArgNumber {
		return errors.New(lOpdVal.Value())
	}
	rOpdVal := rOpd.ToNumber()
	if rOpdVal.Type != ArgNumber {
		return errors.New(rOpdVal.Value())
	}
	if rOpdVal.Number == 0 {
		return errors.New(formulaErrorDIV)
	}
	opdStack.Push(newNumberFormulaArg(lOpdVal.Number / rOpdVal.Number))
	return nil
}

// calculate evaluate basic arithmetic operations.
func calculate(opdStack *Stack, opt efp.Token) error {
	if opt.TValue == "-" && opt.TType == efp.TokenTypeOperatorPrefix {
		if opdStack.Len() < 1 {
			return ErrInvalidFormula
		}
		opd := opdStack.Pop().(formulaArg)
		opdStack.Push(newNumberFormulaArg(0 - opd.ToNumber().Number))
	}
	if opt.TValue == "-" && opt.TType == efp.TokenTypeOperatorInfix {
		if opdStack.Len() < 2 {
			return ErrInvalidFormula
		}
		rOpd := opdStack.Pop().(formulaArg)
		lOpd := opdStack.Pop().(formulaArg)
		if err := calcSubtract(rOpd, lOpd, opdStack); err != nil {
			return err
		}
	}
	tokenCalcFunc := map[string]func(rOpd, lOpd formulaArg, opdStack *Stack) error{
		"^":  calcPow,
		"*":  calcMultiply,
		"/":  calcDiv,
		"+":  calcAdd,
		"=":  calcEq,
		"<>": calcNEq,
		"<":  calcL,
		"<=": calcLe,
		">":  calcG,
		">=": calcGe,
		"&":  calcSplice,
	}
	if fn, ok := tokenCalcFunc[opt.TValue]; ok {
		if opdStack.Len() < 2 {
			return ErrInvalidFormula
		}
		rOpd := opdStack.Pop().(formulaArg)
		lOpd := opdStack.Pop().(formulaArg)
		if opt.TValue != "&" {
			if rOpd.Value() == "" {
				rOpd = newNumberFormulaArg(0)
			}
			if lOpd.Value() == "" {
				lOpd = newNumberFormulaArg(0)
			}
		}
		if rOpd.Type == ArgError {
			return errors.New(rOpd.Value())
		}
		if lOpd.Type == ArgError {
			return errors.New(lOpd.Value())
		}
		return fn(rOpd, lOpd, opdStack)
	}
	return nil
}

// parseOperatorPrefixToken parse operator prefix token.
func (f *File) parseOperatorPrefixToken(optStack, opdStack *Stack, token efp.Token) (err error) {
	if optStack.Len() == 0 {
		optStack.Push(token)
		return
	}
	tokenPriority := getPriority(token)
	topOpt := optStack.Peek().(efp.Token)
	topOptPriority := getPriority(topOpt)
	if topOpt.TValue == "-" && topOpt.TType == efp.TokenTypeOperatorPrefix && token.TValue == "-" && token.TType == efp.TokenTypeOperatorPrefix {
		optStack.Pop()
		return
	}
	if tokenPriority > topOptPriority {
		optStack.Push(token)
		return
	}
	for tokenPriority <= topOptPriority {
		optStack.Pop()
		if err = calculate(opdStack, topOpt); err != nil {
			return
		}
		if optStack.Len() > 0 {
			topOpt = optStack.Peek().(efp.Token)
			topOptPriority = getPriority(topOpt)
			continue
		}
		break
	}
	optStack.Push(token)
	return
}

// isFunctionStartToken determine if the token is function start.
func isFunctionStartToken(token efp.Token) bool {
	return token.TType == efp.TokenTypeFunction && token.TSubType == efp.TokenSubTypeStart
}

// isFunctionStopToken determine if the token is function stop.
func isFunctionStopToken(token efp.Token) bool {
	return token.TType == efp.TokenTypeFunction && token.TSubType == efp.TokenSubTypeStop
}

// isBeginParenthesesToken determine if the token is begin parentheses: (.
func isBeginParenthesesToken(token efp.Token) bool {
	return token.TType == efp.TokenTypeSubexpression && token.TSubType == efp.TokenSubTypeStart
}

// isEndParenthesesToken determine if the token is end parentheses: ).
func isEndParenthesesToken(token efp.Token) bool {
	return token.TType == efp.TokenTypeSubexpression && token.TSubType == efp.TokenSubTypeStop
}

// isOperatorPrefixToken determine if the token is parse operator prefix
// token.
func isOperatorPrefixToken(token efp.Token) bool {
	_, ok := tokenPriority[token.TValue]
	return (token.TValue == "-" && token.TType == efp.TokenTypeOperatorPrefix) || (ok && token.TType == efp.TokenTypeOperatorInfix)
}

// isOperand determine if the token is parse operand.
func isOperand(token efp.Token) bool {
	return token.TType == efp.TokenTypeOperand && (token.TSubType == efp.TokenSubTypeNumber || token.TSubType == efp.TokenSubTypeText || token.TSubType == efp.TokenSubTypeLogical)
}

// tokenToFormulaArg create a formula argument by given token.
func tokenToFormulaArg(token efp.Token) formulaArg {
	switch token.TSubType {
	case efp.TokenSubTypeLogical:
		return newBoolFormulaArg(strings.EqualFold(token.TValue, "TRUE"))
	case efp.TokenSubTypeNumber:
		num, _ := strconv.ParseFloat(token.TValue, 64)
		return newNumberFormulaArg(num)
	default:
		return newStringFormulaArg(token.TValue)
	}
}

// formulaArgToToken create a token by given formula argument.
func formulaArgToToken(arg formulaArg) efp.Token {
	switch arg.Type {
	case ArgNumber:
		if arg.Boolean {
			return efp.Token{TValue: arg.Value(), TType: efp.TokenTypeOperand, TSubType: efp.TokenSubTypeLogical}
		}
		return efp.Token{TValue: arg.Value(), TType: efp.TokenTypeOperand, TSubType: efp.TokenSubTypeNumber}
	default:
		return efp.Token{TValue: arg.Value(), TType: efp.TokenTypeOperand, TSubType: efp.TokenSubTypeText}
	}
}

// parseToken parse basic arithmetic operator priority and evaluate based on
// operators and operands.
func (f *File) parseToken(ctx *calcContext, sheet string, token efp.Token, opdStack, optStack *Stack) error {
	// parse reference: must reference at here
	if token.TSubType == efp.TokenSubTypeRange {
		refTo := f.getDefinedNameRefTo(token.TValue, sheet)
		if refTo != "" {
			token.TValue = refTo
		}
		result, err := f.parseReference(ctx, sheet, token.TValue)
		if err != nil {
			return errors.New(formulaErrorNAME)
		}
		token = formulaArgToToken(result)
	}
	if isOperatorPrefixToken(token) {
		if err := f.parseOperatorPrefixToken(optStack, opdStack, token); err != nil {
			return err
		}
	}
	if isBeginParenthesesToken(token) { // (
		optStack.Push(token)
	}
	if isEndParenthesesToken(token) { // )
		for !isBeginParenthesesToken(optStack.Peek().(efp.Token)) { // != (
			topOpt := optStack.Peek().(efp.Token)
			if err := calculate(opdStack, topOpt); err != nil {
				return err
			}
			optStack.Pop()
		}
		optStack.Pop()
	}
	if token.TType == efp.TokenTypeOperatorPostfix && !opdStack.Empty() {
		topOpd := opdStack.Pop().(formulaArg)
		opdStack.Push(newNumberFormulaArg(topOpd.Number / 100))
	}
	// opd
	if isOperand(token) {
		opdStack.Push(tokenToFormulaArg(token))
	}
	return nil
}

// parseRef parse reference for a cell, column name or row number.
func parseRef(ref string) (cellRef, bool, bool, error) {
	var (
		err, colErr, rowErr error
		cr                  cellRef
		cell                = ref
		tokens              = strings.Split(ref, "!")
	)
	if len(tokens) == 2 { // have a worksheet
		cr.Sheet, cell = tokens[0], tokens[1]
	}
	if cr.Col, cr.Row, err = CellNameToCoordinates(cell); err != nil {
		if cr.Col, colErr = ColumnNameToNumber(cell); colErr == nil { // cast to column
			return cr, true, false, nil
		}
		if cr.Row, rowErr = strconv.Atoi(cell); rowErr == nil { // cast to row
			return cr, false, true, nil
		}
		return cr, false, false, err
	}
	return cr, false, false, err
}

// prepareCellRange checking and convert cell reference to a cell range.
func (cr *cellRange) prepareCellRange(col, row bool, cellRef cellRef) error {
	if col {
		cellRef.Row = TotalRows
	}
	if row {
		cellRef.Col = MaxColumns
	}
	if cellRef.Sheet == "" {
		cellRef.Sheet = cr.From.Sheet
	}
	if cr.From.Sheet != cellRef.Sheet || cr.To.Sheet != cellRef.Sheet {
		return errors.New("invalid reference")
	}
	if cr.From.Col > cellRef.Col {
		cr.From.Col = cellRef.Col
	}
	if cr.From.Row > cellRef.Row {
		cr.From.Row = cellRef.Row
	}
	if cr.To.Col < cellRef.Col {
		cr.To.Col = cellRef.Col
	}
	if cr.To.Row < cellRef.Row {
		cr.To.Row = cellRef.Row
	}
	return nil
}

// parseReference parse reference and extract values by given reference
// characters and default sheet name.
func (f *File) parseReference(ctx *calcContext, sheet, reference string) (formulaArg, error) {
	reference = strings.ReplaceAll(reference, "$", "")
	ranges, cellRanges, cellRefs := strings.Split(reference, ":"), list.New(), list.New()
	if len(ranges) > 1 {
		var cr cellRange
		for i, ref := range ranges {
			cellRef, col, row, err := parseRef(ref)
			if err != nil {
				return newErrorFormulaArg(formulaErrorNAME, "invalid reference"), errors.New("invalid reference")
			}
			if i == 0 {
				if col {
					cellRef.Row = 1
				}
				if row {
					cellRef.Col = 1
				}
				if cellRef.Sheet == "" {
					cellRef.Sheet = sheet
				}
				cr.From, cr.To = cellRef, cellRef
				continue
			}
			if err := cr.prepareCellRange(col, row, cellRef); err != nil {
				return newErrorFormulaArg(formulaErrorNAME, err.Error()), err
			}
		}
		cellRanges.PushBack(cr)
		return f.rangeResolver(ctx, cellRefs, cellRanges)
	}
	cellRef, _, _, err := parseRef(reference)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNAME, "invalid reference"), errors.New("invalid reference")
	}
	if cellRef.Sheet == "" {
		cellRef.Sheet = sheet
	}
	cellRefs.PushBack(cellRef)
	return f.rangeResolver(ctx, cellRefs, cellRanges)
}

// prepareValueRange prepare value range.
func prepareValueRange(cr cellRange, valueRange []int) {
	if cr.From.Row < valueRange[0] || valueRange[0] == 0 {
		valueRange[0] = cr.From.Row
	}
	if cr.From.Col < valueRange[2] || valueRange[2] == 0 {
		valueRange[2] = cr.From.Col
	}
	if cr.To.Row > valueRange[1] || valueRange[1] == 0 {
		valueRange[1] = cr.To.Row
	}
	if cr.To.Col > valueRange[3] || valueRange[3] == 0 {
		valueRange[3] = cr.To.Col
	}
}

// prepareValueRef prepare value reference.
func prepareValueRef(cr cellRef, valueRange []int) {
	if cr.Row < valueRange[0] || valueRange[0] == 0 {
		valueRange[0] = cr.Row
	}
	if cr.Col < valueRange[2] || valueRange[2] == 0 {
		valueRange[2] = cr.Col
	}
	if cr.Row > valueRange[1] || valueRange[1] == 0 {
		valueRange[1] = cr.Row
	}
	if cr.Col > valueRange[3] || valueRange[3] == 0 {
		valueRange[3] = cr.Col
	}
}

// cellResolver calc cell value by given worksheet name, cell reference and context.
func (f *File) cellResolver(ctx *calcContext, sheet, cell string) (formulaArg, error) {
	var (
		arg   formulaArg
		value string
		err   error
	)
	ref := sheet + "!" + cell
	if cached, ok := f.formulaArgCache.Load(ref); ok {
		return cached.(formulaArg), err
	}

	if formula, _ := f.getCellFormula(sheet, cell, true); len(formula) != 0 {
		ctx.mu.Lock()
		if ctx.entry != ref {
			if ctx.iterations[ref] <= f.options.MaxCalcIterations {
				ctx.iterations[ref]++
				ctx.mu.Unlock()
				arg, _ = f.calcCellValue(ctx, sheet, cell)
				ctx.iterationsCache[ref] = arg
				f.formulaArgCache.Store(ref, arg)
				return arg, nil
			}
			ctx.mu.Unlock()
			return ctx.iterationsCache[ref], nil
		}
		ctx.mu.Unlock()
	}
	if value, err = f.GetCellValue(sheet, cell, Options{RawCellValue: true}); err != nil {
		return arg, err
	}
	arg = newStringFormulaArg(value)
	cellType, _ := f.GetCellType(sheet, cell)
	switch cellType {
	case CellTypeBool:
		arg = arg.ToBool()
	case CellTypeNumber, CellTypeUnset:
		if arg.Value() == "" {
			arg = newEmptyFormulaArg()
		} else {
			arg = arg.ToNumber()
		}
	case CellTypeInlineString, CellTypeSharedString:
	case CellTypeFormula:
		if value == "" {
			arg = newEmptyFormulaArg()
		}
	case CellTypeDate:
		if value, err = f.GetCellValue(sheet, cell); err == nil {
			if num := newStringFormulaArg(value).ToNumber(); num.Type == ArgNumber {
				arg = num
			}
		}
	default:
		arg = newErrorFormulaArg(value, value)
	}
	f.formulaArgCache.Store(ref, arg)
	return arg, err
}

// rangeResolver extract value as string from given reference and range list.
// This function will not ignore the empty cell. For example, A1:A2:A2:B3 will
// be reference A1:B3.
func (f *File) rangeResolver(ctx *calcContext, cellRefs, cellRanges *list.List) (arg formulaArg, err error) {
	arg.cellRefs, arg.cellRanges = cellRefs, cellRanges
	// value range order: from row, to row, from column, to column
	valueRange := []int{0, 0, 0, 0}
	var sheet string
	// prepare value range
	for temp := cellRanges.Front(); temp != nil; temp = temp.Next() {
		cr := temp.Value.(cellRange)
		rng := []int{cr.From.Col, cr.From.Row, cr.To.Col, cr.To.Row}
		_ = sortCoordinates(rng)
		cr.From.Col, cr.From.Row, cr.To.Col, cr.To.Row = rng[0], rng[1], rng[2], rng[3]
		prepareValueRange(cr, valueRange)
		if cr.From.Sheet != "" {
			sheet = cr.From.Sheet
		}
	}
	for temp := cellRefs.Front(); temp != nil; temp = temp.Next() {
		cr := temp.Value.(cellRef)
		if cr.Sheet != "" {
			sheet = cr.Sheet
		}
		prepareValueRef(cr, valueRange)
	}
	// extract value from ranges
	if cellRanges.Len() > 0 {
		arg.Type = ArgMatrix

		var ws *xlsxWorksheet
		ws, err = f.workSheetReader(sheet)
		if err != nil {
			return
		}

		// Detect whole column/row reference, limit to actual data range
		if valueRange[1] == TotalRows {
			actualMaxRow := 0
			for _, rowData := range ws.SheetData.Row {
				if rowData.R > actualMaxRow {
					actualMaxRow = rowData.R
				}
			}
			if actualMaxRow > 0 && actualMaxRow < TotalRows {
				valueRange[1] = actualMaxRow
			}
		}
		if valueRange[3] == MaxColumns {
			actualMaxCol := 0
			for _, rowData := range ws.SheetData.Row {
				for _, cell := range rowData.C {
					col, _, err := CellNameToCoordinates(cell.R)
					if err == nil && col > actualMaxCol {
						actualMaxCol = col
					}
				}
			}
			if actualMaxCol > 0 && actualMaxCol < MaxColumns {
				valueRange[3] = actualMaxCol
			}
		}

		for row := valueRange[0]; row <= valueRange[1]; row++ {
			colMax := 0
			if row <= len(ws.SheetData.Row) {
				rowData := &ws.SheetData.Row[row-1]
				colMax = min(valueRange[3], len(rowData.C))
			}
			var matrixRow []formulaArg
			for col := valueRange[2]; col <= valueRange[3]; col++ {
				value := newEmptyFormulaArg()
				if col <= colMax {
					var cell string
					if cell, err = CoordinatesToCellName(col, row); err != nil {
						return
					}
					if value, err = f.cellResolver(ctx, sheet, cell); err != nil {
						return
					}
				}
				matrixRow = append(matrixRow, value)
			}
			arg.Matrix = append(arg.Matrix, matrixRow)
		}
		return
	}
	// extract value from references
	for temp := cellRefs.Front(); temp != nil; temp = temp.Next() {
		cr := temp.Value.(cellRef)
		var cell string
		if cell, err = CoordinatesToCellName(cr.Col, cr.Row); err != nil {
			return
		}
		if arg, err = f.cellResolver(ctx, cr.Sheet, cell); err != nil {
			return
		}
		arg.cellRefs, arg.cellRanges = cellRefs, cellRanges
	}
	return
}

// callFuncByName calls the no error or only error return function with
// reflect by given receiver, name and parameters.
func callFuncByName(receiver interface{}, name string, params []reflect.Value) (arg formulaArg) {
	function := reflect.ValueOf(receiver).MethodByName(name)
	if function.IsValid() {
		rt := function.Call(params)
		if len(rt) == 0 {
			return
		}
		arg = rt[0].Interface().(formulaArg)
		return
	}
	return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("not support %s function", name))
}

// formulaCriteriaParser parse formula criteria.
func formulaCriteriaParser(exp formulaArg) *formulaCriteria {
	prepareValue := func(cond string) (expected float64, err error) {
		percentile := 1.0
		if strings.HasSuffix(cond, "%") {
			cond = strings.TrimSuffix(cond, "%")
			percentile /= 100
		}
		if expected, err = strconv.ParseFloat(cond, 64); err != nil {
			return
		}
		expected *= percentile
		return
	}
	fc, val := &formulaCriteria{}, exp.Value()
	if val == "" {
		return fc
	}
	for i, re := range formulaFormats {
		if match := re.FindStringSubmatch(val); len(match) > 1 {
			fc.Condition = newStringFormulaArg(match[1])
			if num, err := prepareValue(match[1]); err == nil {
				fc.Condition = newNumberFormulaArg(num)
			}
			fc.Type = formulaCriterias[i]
			return fc
		}
	}
	if strings.Contains(val, "?") {
		val = strings.ReplaceAll(val, "?", ".")
	}
	if strings.Contains(val, "*") {
		val = strings.ReplaceAll(val, "*", ".*")
	}
	fc.Type, fc.Condition = criteriaRegexp, newStringFormulaArg(val)
	if num := fc.Condition.ToNumber(); num.Type == ArgNumber {
		fc.Condition = num
	}
	return fc
}

// formulaCriteriaEval evaluate formula criteria expression.
func formulaCriteriaEval(val formulaArg, criteria *formulaCriteria) (result bool, err error) {
	s := NewStack()
	tokenCalcFunc := map[byte]func(rOpd, lOpd formulaArg, opdStack *Stack) error{
		criteriaEq: calcEq,
		criteriaNe: calcNEq,
		criteriaL:  calcL,
		criteriaLe: calcLe,
		criteriaG:  calcG,
		criteriaGe: calcGe,
	}
	switch criteria.Type {
	case criteriaEq, criteriaLe, criteriaGe, criteriaNe, criteriaL, criteriaG:
		if fn, ok := tokenCalcFunc[criteria.Type]; ok {
			if _ = fn(criteria.Condition, val, s); s.Len() > 0 {
				return s.Pop().(formulaArg).Number == 1, err
			}
		}
	case criteriaRegexp:
		return regexp.MatchString(criteria.Condition.Value(), val.Value())
	}
	return
}

// Engineering Functions

// BESSELI function the modified Bessel function, which is equivalent to the
// Bessel function evaluated for purely imaginary arguments. The syntax of
