// Copyright 2016 - 2025 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.24.0 or later.

package excelize

import (
	"container/list"
	"errors"
	"fmt"
	"math"
	"sort"
	"strconv"
)

func (fn *formulaFuncs) AVEDEV(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "AVEDEV requires at least 1 argument")
	}
	average := fn.AVERAGE(argsList)
	if average.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	result, count := 0.0, 0.0
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		num := arg.Value.(formulaArg).ToNumber()
		if num.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
		result += math.Abs(num.Number - average.Number)
		count++
	}
	return newNumberFormulaArg(result / count)
}

// AVERAGE function returns the arithmetic mean of a list of supplied numbers.
// The syntax of the function is:
//
//	AVERAGE(number1,[number2],...)
func (fn *formulaFuncs) AVERAGE(argsList *list.List) formulaArg {
	var args []formulaArg
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		args = append(args, arg.Value.(formulaArg))
	}
	count, sum := fn.countSum(false, args)
	if count == 0 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	return newNumberFormulaArg(sum / count)
}

// AVERAGEA function returns the arithmetic mean of a list of supplied numbers
// with text cell and zero values. The syntax of the function is:
//
//	AVERAGEA(number1,[number2],...)
func (fn *formulaFuncs) AVERAGEA(argsList *list.List) formulaArg {
	var args []formulaArg
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		args = append(args, arg.Value.(formulaArg))
	}
	count, sum := fn.countSum(true, args)
	if count == 0 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	return newNumberFormulaArg(sum / count)
}

// AVERAGEIF function finds the values in a supplied array that satisfy a
// specified criteria, and returns the average (i.e. the statistical mean) of
// the corresponding values in a second supplied array. The syntax of the
// function is:
//
//	AVERAGEIF(range,criteria,[average_range])
func (fn *formulaFuncs) AVERAGEIF(argsList *list.List) formulaArg {
	if argsList.Len() < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "AVERAGEIF requires at least 2 arguments")
	}
	var (
		criteria  = formulaCriteriaParser(argsList.Front().Next().Value.(formulaArg))
		rangeMtx  = argsList.Front().Value.(formulaArg).Matrix
		cellRange [][]formulaArg
		args      []formulaArg
		val       float64
		err       error
		ok        bool
	)
	if argsList.Len() == 3 {
		cellRange = argsList.Back().Value.(formulaArg).Matrix
	}
	for rowIdx, row := range rangeMtx {
		for colIdx, col := range row {
			fromVal := col.Value()
			if fromVal == "" {
				continue
			}
			if col.Type == ArgString && criteria.Condition.Type != ArgString {
				continue
			}
			ok, _ = formulaCriteriaEval(col, criteria)
			if ok {
				if argsList.Len() == 3 {
					if len(cellRange) > rowIdx && len(cellRange[rowIdx]) > colIdx {
						fromVal = cellRange[rowIdx][colIdx].Value()
					}
				}
				if val, err = strconv.ParseFloat(fromVal, 64); err != nil {
					continue
				}
				args = append(args, newNumberFormulaArg(val))
			}
		}
	}
	count, sum := fn.countSum(false, args)
	if count == 0 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	return newNumberFormulaArg(sum / count)
}

// AVERAGEIFS function finds entries in one or more arrays, that satisfy a set
// of supplied criteria, and returns the average (i.e. the statistical mean)
// of the corresponding values in a further supplied array. The syntax of the
// function is:
//
//	AVERAGEIFS(average_range,criteria_range1,criteria1,[criteria_range2,criteria2],...)
func (fn *formulaFuncs) AVERAGEIFS(argsList *list.List) formulaArg {
	if argsList.Len() < 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "AVERAGEIFS requires at least 3 arguments")
	}
	if argsList.Len()%2 != 1 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	var args []formulaArg
	sum, sumRange := 0.0, argsList.Front().Value.(formulaArg).Matrix
	for arg := argsList.Front().Next(); arg != nil; arg = arg.Next() {
		args = append(args, arg.Value.(formulaArg))
	}
	count := 0.0
	for _, ref := range formulaIfsMatch(args) {
		if num := sumRange[ref.Row][ref.Col].ToNumber(); num.Type == ArgNumber {
			sum += num.Number
			count++
		}
	}
	if count == 0 {
		return newErrorFormulaArg(formulaErrorDIV, "AVERAGEIF divide by zero")
	}
	return newNumberFormulaArg(sum / count)
}

// getBetaHelperContFrac continued fractions for the beta function.
func getBetaHelperContFrac(fX, fA, fB float64) float64 {
	var a1, b1, a2, b2, fnorm, cfnew, cf, rm float64
	a1, b1, b2 = 1, 1, 1-(fA+fB)/(fA+1)*fX
	if b2 == 0 {
		a2, fnorm, cf = 0, 1, 1
	} else {
		a2, fnorm = 1, 1/b2
		cf = a2 * fnorm
	}
	cfnew, rm = 1, 1
	fMaxIter, fMachEps := 50000.0, 2.22045e-016
	bfinished := false
	for rm < fMaxIter && !bfinished {
		apl2m := fA + 2*rm
		d2m := rm * (fB - rm) * fX / ((apl2m - 1) * apl2m)
		d2m1 := -(fA + rm) * (fA + fB + rm) * fX / (apl2m * (apl2m + 1))
		a1 = (a2 + d2m*a1) * fnorm
		b1 = (b2 + d2m*b1) * fnorm
		a2 = a1 + d2m1*a2*fnorm
		b2 = b1 + d2m1*b2*fnorm
		if b2 != 0 {
			fnorm = 1 / b2
			cfnew = a2 * fnorm
			bfinished = math.Abs(cf-cfnew) < math.Abs(cf)*fMachEps
		}
		cf = cfnew
		rm++
	}
	return cf
}

// getLanczosSum uses a variant of the Lanczos sum with a rational function.
func getLanczosSum(fZ float64) float64 {
	num := []float64{
		23531376880.41075968857200767445163675473,
		42919803642.64909876895789904700198885093,
		35711959237.35566804944018545154716670596,
		17921034426.03720969991975575445893111267,
		6039542586.35202800506429164430729792107,
		1439720407.311721673663223072794912393972,
		248874557.8620541565114603864132294232163,
		31426415.58540019438061423162831820536287,
		2876370.628935372441225409051620849613599,
		186056.2653952234950402949897160456992822,
		8071.672002365816210638002902272250613822,
		210.8242777515793458725097339207133627117,
		2.506628274631000270164908177133837338626,
	}
	denom := []float64{
		0,
		39916800,
		120543840,
		150917976,
		105258076,
		45995730,
		13339535,
		2637558,
		357423,
		32670,
		1925,
		66,
		1,
	}
	var sumNum, sumDenom, zInv float64
	if fZ <= 1 {
		sumNum = num[12]
		sumDenom = denom[12]
		for i := 11; i >= 0; i-- {
			sumNum *= fZ
			sumNum += num[i]
			sumDenom *= fZ
			sumDenom += denom[i]
		}
	} else {
		zInv = 1 / fZ
		sumNum = num[0]
		sumDenom = denom[0]
		for i := 1; i <= 12; i++ {
			sumNum *= zInv
			sumNum += num[i]
			sumDenom *= zInv
			sumDenom += denom[i]
		}
	}
	return sumNum / sumDenom
}

// getBeta return beta distribution.
func getBeta(fAlpha, fBeta float64) float64 {
	var fA, fB float64
	if fAlpha > fBeta {
		fA = fAlpha
		fB = fBeta
	} else {
		fA = fBeta
		fB = fAlpha
	}
	const maxGammaArgument = 171.624376956302
	if fA+fB < maxGammaArgument {
		return math.Gamma(fA) / math.Gamma(fA+fB) * math.Gamma(fB)
	}
	fg := 6.024680040776729583740234375
	fgm := fg - 0.5
	fLanczos := getLanczosSum(fA)
	fLanczos /= getLanczosSum(fA + fB)
	fLanczos *= getLanczosSum(fB)
	fABgm := fA + fB + fgm
	fLanczos *= math.Sqrt((fABgm / (fA + fgm)) / (fB + fgm))
	fTempA := fB / (fA + fgm)
	fTempB := fA / (fB + fgm)
	fResult := math.Exp(-fA*math.Log1p(fTempA) - fB*math.Log1p(fTempB) - fgm)
	fResult *= fLanczos
	return fResult
}

// getBetaDistPDF is an implementation for the Beta probability density
// function.
func getBetaDistPDF(fX, fA, fB float64) float64 {
	if fX <= 0 || fX >= 1 {
		return 0
	}
	fLogDblMax, fLogDblMin := math.Log(1.79769e+308), math.Log(2.22507e-308)
	fLogY := math.Log(0.5 - fX + 0.5)
	if fX < 0.1 {
		fLogY = math.Log1p(-fX)
	}
	fLogX := math.Log(fX)
	fAm1LogX := (fA - 1) * fLogX
	fBm1LogY := (fB - 1) * fLogY
	fLogBeta := getLogBeta(fA, fB)
	if fAm1LogX < fLogDblMax && fAm1LogX > fLogDblMin && fBm1LogY < fLogDblMax &&
		fBm1LogY > fLogDblMin && fLogBeta < fLogDblMax && fLogBeta > fLogDblMin &&
		fAm1LogX+fBm1LogY < fLogDblMax && fAm1LogX+fBm1LogY > fLogDblMin {
		return math.Pow(fX, fA-1) * math.Pow(0.5-fX+0.5, fB-1) / getBeta(fA, fB)
	}
	return math.Exp(fAm1LogX + fBm1LogY - fLogBeta)
}

// getLogBeta return beta with logarithm.
func getLogBeta(fAlpha, fBeta float64) float64 {
	var fA, fB float64
	if fAlpha > fBeta {
		fA, fB = fAlpha, fBeta
	} else {
		fA, fB = fBeta, fAlpha
	}
	fg := 6.024680040776729583740234375
	fgm := fg - 0.5
	fLanczos := getLanczosSum(fA)
	fLanczos /= getLanczosSum(fA + fB)
	fLanczos *= getLanczosSum(fB)
	fLogLanczos := math.Log(fLanczos)
	fABgm := fA + fB + fgm
	fLogLanczos += 0.5 * (math.Log(fABgm) - math.Log(fA+fgm) - math.Log(fB+fgm))
	fTempA := fB / (fA + fgm)
	fTempB := fA / (fB + fgm)
	fResult := -fA*math.Log1p(fTempA) - fB*math.Log1p(fTempB) - fgm
	fResult += fLogLanczos
	return fResult
}

// getBetaDist is an implementation for the beta distribution function.
func getBetaDist(fXin, fAlpha, fBeta float64) float64 {
	if fXin <= 0 {
		return 0
	}
	if fXin >= 1 {
		return 1
	}
	if fBeta == 1 {
		return math.Pow(fXin, fAlpha)
	}
	if fAlpha == 1 {
		return -math.Expm1(fBeta * math.Log1p(-fXin))
	}
	var fResult float64
	fY, flnY := (0.5-fXin)+0.5, math.Log1p(-fXin)
	fX, flnX := fXin, math.Log(fXin)
	fA, fB := fAlpha, fBeta
	bReflect := fXin > fAlpha/(fAlpha+fBeta)
	if bReflect {
		fA = fBeta
		fB = fAlpha
		fX = fY
		fY = fXin
		flnX = flnY
		flnY = math.Log(fXin)
	}
	fResult = getBetaHelperContFrac(fX, fA, fB) / fA
	fP, fQ := fA/(fA+fB), fB/(fA+fB)
	var fTemp float64
	if fA > 1 && fB > 1 && fP < 0.97 && fQ < 0.97 {
		fTemp = getBetaDistPDF(fX, fA, fB) * fX * fY
	} else {
		fTemp = math.Exp(fA*flnX + fB*flnY - getLogBeta(fA, fB))
	}
	fResult *= fTemp
	if bReflect {
		fResult = 0.5 - fResult + 0.5
	}
	return fResult
}

// prepareBETAdotDISTArgs checking and prepare arguments for the formula
// function BETA.DIST.
func (fn *formulaFuncs) prepareBETAdotDISTArgs(argsList *list.List) formulaArg {
	if argsList.Len() < 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "BETA.DIST requires at least 4 arguments")
	}
	if argsList.Len() > 6 {
		return newErrorFormulaArg(formulaErrorVALUE, "BETA.DIST requires at most 6 arguments")
	}
	x := argsList.Front().Value.(formulaArg).ToNumber()
	if x.Type != ArgNumber {
		return x
	}
	alpha := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if alpha.Type != ArgNumber {
		return alpha
	}
	beta := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if beta.Type != ArgNumber {
		return beta
	}
	if alpha.Number <= 0 || beta.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	cumulative := argsList.Front().Next().Next().Next().Value.(formulaArg).ToBool()
	if cumulative.Type != ArgNumber {
		return cumulative
	}
	a, b := newNumberFormulaArg(0), newNumberFormulaArg(1)
	if argsList.Len() > 4 {
		if a = argsList.Front().Next().Next().Next().Next().Value.(formulaArg).ToNumber(); a.Type != ArgNumber {
			return a
		}
	}
	if argsList.Len() == 6 {
		if b = argsList.Back().Value.(formulaArg).ToNumber(); b.Type != ArgNumber {
			return b
		}
	}
	return newListFormulaArg([]formulaArg{x, alpha, beta, cumulative, a, b})
}

// BETAdotDIST function calculates the cumulative beta distribution function
// or the probability density function of the Beta distribution, for a
// supplied set of parameters. The syntax of the function is:
//
//	BETA.DIST(x,alpha,beta,cumulative,[A],[B])
func (fn *formulaFuncs) BETAdotDIST(argsList *list.List) formulaArg {
	args := fn.prepareBETAdotDISTArgs(argsList)
	if args.Type != ArgList {
		return args
	}
	x, alpha, beta, cumulative, a, b := args.List[0], args.List[1], args.List[2], args.List[3], args.List[4], args.List[5]
	if x.Number < a.Number || x.Number > b.Number {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if a.Number == b.Number {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	scale := b.Number - a.Number
	x.Number = (x.Number - a.Number) / scale
	if cumulative.Number == 1 {
		return newNumberFormulaArg(getBetaDist(x.Number, alpha.Number, beta.Number))
	}
	return newNumberFormulaArg(getBetaDistPDF(x.Number, alpha.Number, beta.Number) / scale)
}

// BETADIST function calculates the cumulative beta probability density
// function for a supplied set of parameters. The syntax of the function is:
//
//	BETADIST(x,alpha,beta,[A],[B])
func (fn *formulaFuncs) BETADIST(argsList *list.List) formulaArg {
	if argsList.Len() < 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "BETADIST requires at least 3 arguments")
	}
	if argsList.Len() > 5 {
		return newErrorFormulaArg(formulaErrorVALUE, "BETADIST requires at most 5 arguments")
	}
	x := argsList.Front().Value.(formulaArg).ToNumber()
	if x.Type != ArgNumber {
		return x
	}
	alpha := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if alpha.Type != ArgNumber {
		return alpha
	}
	beta := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if beta.Type != ArgNumber {
		return beta
	}
	if alpha.Number <= 0 || beta.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	a, b := newNumberFormulaArg(0), newNumberFormulaArg(1)
	if argsList.Len() > 3 {
		if a = argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber(); a.Type != ArgNumber {
			return a
		}
	}
	if argsList.Len() == 5 {
		if b = argsList.Back().Value.(formulaArg).ToNumber(); b.Type != ArgNumber {
			return b
		}
	}
	if x.Number < a.Number || x.Number > b.Number {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if a.Number == b.Number {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(getBetaDist((x.Number-a.Number)/(b.Number-a.Number), alpha.Number, beta.Number))
}

// d1mach returns double precision real machine constants.
func d1mach(i int) float64 {
	arr := []float64{
		2.2250738585072014e-308,
		1.7976931348623158e+308,
		1.1102230246251565e-16,
		2.2204460492503131e-16,
		0.301029995663981195,
	}
	if i > len(arr) {
		return 0
	}
	return arr[i-1]
}

// chebyshevInit determines the number of terms for the double precision
// orthogonal series "dos" needed to insure the error is no larger
// than "eta". Ordinarily eta will be chosen to be one-tenth machine
// precision.
func chebyshevInit(nos int, eta float64, dos []float64) int {
	i, e := 0, 0.0
	if nos < 1 {
		return 0
	}
	for ii := 1; ii <= nos; ii++ {
		i = nos - ii
		e += math.Abs(dos[i])
		if e > eta {
			return i
		}
	}
	return i
}

// chebyshevEval evaluates the n-term Chebyshev series "a" at "x".
func chebyshevEval(n int, x float64, a []float64) float64 {
	if n < 1 || n > 1000 || x < -1.1 || x > 1.1 {
		return math.NaN()
	}
	twox, b0, b1, b2 := x*2, 0.0, 0.0, 0.0
	for i := 1; i <= n; i++ {
		b2 = b1
		b1 = b0
		b0 = twox*b1 - b2 + a[n-i]
	}
	return (b0 - b2) * 0.5
}

// lgammacor is an implementation for the log(gamma) correction.
func lgammacor(x float64) float64 {
	algmcs := []float64{
		0.1666389480451863247205729650822, -0.1384948176067563840732986059135e-4,
		0.9810825646924729426157171547487e-8, -0.1809129475572494194263306266719e-10,
		0.6221098041892605227126015543416e-13, -0.3399615005417721944303330599666e-15,
		0.2683181998482698748957538846666e-17, -0.2868042435334643284144622399999e-19,
		0.3962837061046434803679306666666e-21, -0.6831888753985766870111999999999e-23,
		0.1429227355942498147573333333333e-24, -0.3547598158101070547199999999999e-26,
		0.1025680058010470912000000000000e-27, -0.3401102254316748799999999999999e-29,
		0.1276642195630062933333333333333e-30,
	}
	nalgm := chebyshevInit(15, d1mach(3), algmcs)
	xbig := 1.0 / math.Sqrt(d1mach(3))
	xmax := math.Exp(math.Min(math.Log(d1mach(2)/12.0), -math.Log(12.0*d1mach(1))))
	if x < 10.0 {
		return math.NaN()
	} else if x >= xmax {
		return 4.930380657631324e-32
	} else if x < xbig {
		tmp := 10.0 / x
		return chebyshevEval(nalgm, tmp*tmp*2.0-1.0, algmcs) / x
	}
	return 1.0 / (x * 12.0)
}

// logrelerr compute the relative error logarithm.
func logrelerr(x float64) float64 {
	alnrcs := []float64{
		0.10378693562743769800686267719098e+1, -0.13364301504908918098766041553133,
		0.19408249135520563357926199374750e-1, -0.30107551127535777690376537776592e-2,
		0.48694614797154850090456366509137e-3, -0.81054881893175356066809943008622e-4,
		0.13778847799559524782938251496059e-4, -0.23802210894358970251369992914935e-5,
		0.41640416213865183476391859901989e-6, -0.73595828378075994984266837031998e-7,
		0.13117611876241674949152294345011e-7, -0.23546709317742425136696092330175e-8,
		0.42522773276034997775638052962567e-9, -0.77190894134840796826108107493300e-10,
		0.14075746481359069909215356472191e-10, -0.25769072058024680627537078627584e-11,
		0.47342406666294421849154395005938e-12, -0.87249012674742641745301263292675e-13,
		0.16124614902740551465739833119115e-13, -0.29875652015665773006710792416815e-14,
		0.55480701209082887983041321697279e-15, -0.10324619158271569595141333961932e-15,
		0.19250239203049851177878503244868e-16, -0.35955073465265150011189707844266e-17,
		0.67264542537876857892194574226773e-18, -0.12602624168735219252082425637546e-18,
		0.23644884408606210044916158955519e-19, -0.44419377050807936898878389179733e-20,
		0.83546594464034259016241293994666e-21, -0.15731559416479562574899253521066e-21,
		0.29653128740247422686154369706666e-22, -0.55949583481815947292156013226666e-23,
		0.10566354268835681048187284138666e-23, -0.19972483680670204548314999466666e-24,
		0.37782977818839361421049855999999e-25, -0.71531586889081740345038165333333e-26,
		0.13552488463674213646502024533333e-26, -0.25694673048487567430079829333333e-27,
		0.48747756066216949076459519999999e-28, -0.92542112530849715321132373333333e-29,
		0.17578597841760239233269760000000e-29, -0.33410026677731010351377066666666e-30,
		0.63533936180236187354180266666666e-31,
	}
	nlnrel := chebyshevInit(43, 0.1*d1mach(3), alnrcs)
	if x <= -1 {
		return math.NaN()
	}
	if math.Abs(x) <= 0.375 {
		return x * (1.0 - x*chebyshevEval(nlnrel, x/0.375, alnrcs))
	}
	return math.Log(x + 1.0)
}

// logBeta is an implementation for the log of the beta distribution
// function.
func logBeta(a, b float64) float64 {
	corr, p, q := 0.0, a, a
	if b < p {
		p = b
	}
	if b > q {
		q = b
	}
	if p < 0 {
		return math.NaN()
	}
	if p == 0 {
		return math.MaxFloat64
	}
	if p >= 10.0 {
		corr = lgammacor(p) + lgammacor(q) - lgammacor(p+q)
		f1 := q * logrelerr(-p/(p+q))
		return math.Log(q)*-0.5 + 0.918938533204672741780329736406 + corr + (p-0.5)*math.Log(p/(p+q)) + math.Nextafter(f1, f1)
	}
	if q >= 10 {
		corr = lgammacor(q) - lgammacor(p+q)
		val, _ := math.Lgamma(p)
		return val + corr + p - p*math.Log(p+q) + (q-0.5)*logrelerr(-p/(p+q))
	}
	return math.Log(math.Gamma(p) * (math.Gamma(q) / math.Gamma(p+q)))
}

// pbetaRaw is a part of pbeta for the beta distribution.
func pbetaRaw(alnsml, ans, eps, p, pin, q, sml, x, y float64) float64 {
	if q > 1.0 {
		xb := p*math.Log(y) + q*math.Log(1.0-y) - logBeta(p, q) - math.Log(q)
		ib := int(math.Max(xb/alnsml, 0.0))
		term := math.Exp(xb - float64(ib)*alnsml)
		c := 1.0 / (1.0 - y)
		p1 := q * c / (p + q - 1.0)
		finsum := 0.0
		n := int(q)
		if q == float64(n) {
			n = n - 1
		}
		for i := 1; i <= n; i++ {
			if p1 <= 1 && term/eps <= finsum {
				break
			}
			xi := float64(i)
			term = (q - xi + 1.0) * c * term / (p + q - xi)
			if term > 1.0 {
				ib = ib - 1
				term = term * sml
			}
			if ib == 0 {
				finsum = finsum + term
			}
		}
		ans = ans + finsum
	}
	if y != x || p != pin {
		ans = 1.0 - ans
	}
	ans = math.Max(math.Min(ans, 1.0), 0.0)
	return ans
}

// pbeta returns distribution function of the beta distribution.
func pbeta(x, pin, qin float64) (ans float64) {
	eps := d1mach(3)
	alneps := math.Log(eps)
	sml := d1mach(1)
	alnsml := math.Log(sml)
	y := x
	p := pin
	q := qin
	if p/(p+q) < x {
		y = 1.0 - y
		p = qin
		q = pin
	}
	if (p+q)*y/(p+1.0) < eps {
		xb := p*math.Log(math.Max(y, sml)) - math.Log(p) - logBeta(p, q)
		if xb > alnsml && y != 0.0 {
			ans = math.Exp(xb)
		}
		if y != x || p != pin {
			ans = 1.0 - ans
		}
	} else {
		ps := q - math.Floor(q)
		if ps == 0.0 {
			ps = 1.0
		}
		xb := p*math.Log(y) - logBeta(ps, p) - math.Log(p)
		if xb >= alnsml {
			ans = math.Exp(xb)
			term := ans * p
			if ps != 1.0 {
				n := int(math.Max(alneps/math.Log(y), 4.0))
				for i := 1; i <= n; i++ {
					xi := float64(i)
					term = term * (xi - ps) * y / xi
					ans = ans + term/(p+xi)
				}
			}
		}
		ans = pbetaRaw(alnsml, ans, eps, p, pin, q, sml, x, y)
	}
	return ans
}

// betainvProbIterator is a part of betainv for the inverse of the beta
// function.
func betainvProbIterator(alpha1, alpha3, beta1, beta2, beta3, logBeta, maxCumulative, prob1, prob2 float64) float64 {
	var i, j, prev, prop4 float64
	j = 1
	for prob := 0; prob < 1000; prob++ {
		prop3 := pbeta(beta3, alpha1, beta1)
		prop3 = (prop3 - prob1) * math.Exp(logBeta+prob2*math.Log(beta3)+beta2*math.Log(1.0-beta3))
		if prop3*prop4 <= 0 {
			prev = math.Max(math.Abs(j), maxCumulative)
		}
		h := 1.0
		for iteratorCount := 0; iteratorCount < 1000; iteratorCount++ {
			j = h * prop3
			if math.Abs(j) < prev {
				i = beta3 - j
				if i >= 0 && i <= 1.0 {
					if prev <= alpha3 {
						return beta3
					}
					if math.Abs(prop3) <= alpha3 {
						return beta3
					}
					if i != 0 && i != 1.0 {
						break
					}
				}
			}
			h /= 3.0
		}
		if i == beta3 {
			return beta3
		}
		beta3, prop4 = i, prop3
	}
	return beta3
}

// calcBetainv is an implementation for the quantile of the beta
// distribution.
func calcBetainv(probability, alpha, beta, lower, upper float64) float64 {
	minCumulative, maxCumulative := 1.0e-300, 3.0e-308
	lowerBound, upperBound := maxCumulative, 1.0-2.22e-16
	needSwap := false
	var alpha1, alpha2, beta1, beta2, beta3, prob1, x, y float64
	if probability <= 0.5 {
		prob1, alpha1, beta1 = probability, alpha, beta
	} else {
		prob1, alpha1, beta1, needSwap = 1.0-probability, beta, alpha, true
	}
	logBetaNum := logBeta(alpha, beta)
	prob2 := math.Sqrt(-math.Log(prob1 * prob1))
	prob3 := prob2 - (prob2*0.27061+2.3075)/(prob2*(prob2*0.04481+0.99229)+1)
	if alpha1 > 1 && beta1 > 1 {
		alpha2, beta2, prob2 = 1/(alpha1+alpha1-1), 1/(beta1+beta1-1), (prob3*prob3-3)/6
		x = 2 / (alpha2 + beta2)
		y = prob3*math.Sqrt(x+prob2)/x - (beta2-alpha2)*(prob2+5/6.0-2/(x*3))
		beta3 = alpha1 / (alpha1 + beta1*math.Exp(y+y))
	} else {
		beta2, prob2 = 1/(beta1*9), beta1+beta1
		beta2 = prob2 * math.Pow(1-beta2+prob3*math.Sqrt(beta2), 3)
		if beta2 <= 0 {
			beta3 = 1 - math.Exp((math.Log((1-prob1)*beta1)+logBetaNum)/beta1)
		} else {
			beta2 = (prob2 + alpha1*4 - 2) / beta2
			if beta2 <= 1 {
				beta3 = math.Exp((logBetaNum + math.Log(alpha1*prob1)) / alpha1)
			} else {
				beta3 = 1 - 2/(beta2+1)
			}
		}
	}
	beta2, prob2 = 1-beta1, 1-alpha1
	if beta3 < lowerBound {
		beta3 = lowerBound
	} else if beta3 > upperBound {
		beta3 = upperBound
	}
	alpha3 := math.Max(minCumulative, math.Pow(10.0, -13.0-2.5/(alpha1*alpha1)-0.5/(prob1*prob1)))
	beta3 = betainvProbIterator(alpha1, alpha3, beta1, beta2, beta3, logBetaNum, maxCumulative, prob1, prob2)
	if needSwap {
		beta3 = 1.0 - beta3
	}
	return (upper-lower)*beta3 + lower
}

// betainv is an implementation of the formula functions BETAINV and
// BETA.INV.
func (fn *formulaFuncs) betainv(name string, argsList *list.List) formulaArg {
	if argsList.Len() < 3 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires at least 3 arguments", name))
	}
	if argsList.Len() > 5 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires at most 5 arguments", name))
	}
	probability := argsList.Front().Value.(formulaArg).ToNumber()
	if probability.Type != ArgNumber {
		return probability
	}
	if probability.Number <= 0 || probability.Number >= 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	alpha := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if alpha.Type != ArgNumber {
		return alpha
	}
	beta := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if beta.Type != ArgNumber {
		return beta
	}
	if alpha.Number <= 0 || beta.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	a, b := newNumberFormulaArg(0), newNumberFormulaArg(1)
	if argsList.Len() > 3 {
		if a = argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber(); a.Type != ArgNumber {
			return a
		}
	}
	if argsList.Len() == 5 {
		if b = argsList.Back().Value.(formulaArg).ToNumber(); b.Type != ArgNumber {
			return b
		}
	}
	if a.Number == b.Number {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(calcBetainv(probability.Number, alpha.Number, beta.Number, a.Number, b.Number))
}

// BETAINV function uses an iterative procedure to calculate the inverse of
// the cumulative beta probability density function for a supplied
// probability. The syntax of the function is:
//
//	BETAINV(probability,alpha,beta,[A],[B])
func (fn *formulaFuncs) BETAINV(argsList *list.List) formulaArg {
	return fn.betainv("BETAINV", argsList)
}

// BETAdotINV function uses an iterative procedure to calculate the inverse of
// the cumulative beta probability density function for a supplied
// probability. The syntax of the function is:
//
//	BETA.INV(probability,alpha,beta,[A],[B])
func (fn *formulaFuncs) BETAdotINV(argsList *list.List) formulaArg {
	return fn.betainv("BETA.INV", argsList)
}

// incompleteGamma is an implementation of the incomplete gamma function.
func incompleteGamma(a, x float64) float64 {
	maxVal := 32
	summer := 0.0
	for n := 0; n <= maxVal; n++ {
		divisor := a
		for i := 1; i <= n; i++ {
			divisor *= a + float64(i)
		}
		summer += math.Pow(x, float64(n)) / divisor
	}
	return math.Pow(x, a) * math.Exp(0-x) * summer
}

// binomCoeff implement binomial coefficient calculation.
func binomCoeff(n, k float64) float64 {
	return fact(n) / (fact(k) * fact(n-k))
}

// binomdist implement binomial distribution calculation.
func binomdist(x, n, p float64) float64 {
	return binomCoeff(n, x) * math.Pow(p, x) * math.Pow(1-p, n-x)
}

// BINOMdotDIST function returns the Binomial Distribution probability for a
// given number of successes from a specified number of trials. The syntax of
// the function is:
//
//	BINOM.DIST(number_s,trials,probability_s,cumulative)
func (fn *formulaFuncs) BINOMdotDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "BINOM.DIST requires 4 arguments")
	}
	return fn.BINOMDIST(argsList)
}

// BINOMDIST function returns the Binomial Distribution probability of a
// specified number of successes out of a specified number of trials. The
// syntax of the function is:
//
//	BINOMDIST(number_s,trials,probability_s,cumulative)
func (fn *formulaFuncs) BINOMDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "BINOMDIST requires 4 arguments")
	}
	var s, trials, probability, cumulative formulaArg
	if s = argsList.Front().Value.(formulaArg).ToNumber(); s.Type != ArgNumber {
		return s
	}
	if trials = argsList.Front().Next().Value.(formulaArg).ToNumber(); trials.Type != ArgNumber {
		return trials
	}
	if s.Number < 0 || s.Number > trials.Number {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if probability = argsList.Back().Prev().Value.(formulaArg).ToNumber(); probability.Type != ArgNumber {
		return probability
	}

	if probability.Number < 0 || probability.Number > 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if cumulative = argsList.Back().Value.(formulaArg).ToBool(); cumulative.Type == ArgError {
		return cumulative
	}
	if cumulative.Number == 1 {
		bm := 0.0
		for i := 0; i <= int(s.Number); i++ {
			bm += binomdist(float64(i), trials.Number, probability.Number)
		}
		return newNumberFormulaArg(bm)
	}
	return newNumberFormulaArg(binomdist(s.Number, trials.Number, probability.Number))
}

// BINOMdotDISTdotRANGE function returns the Binomial Distribution probability
// for the number of successes from a specified number of trials falling into
// a specified range.
//
//	BINOM.DIST.RANGE(trials,probability_s,number_s,[number_s2])
func (fn *formulaFuncs) BINOMdotDISTdotRANGE(argsList *list.List) formulaArg {
	if argsList.Len() < 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "BINOM.DIST.RANGE requires at least 3 arguments")
	}
	if argsList.Len() > 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "BINOM.DIST.RANGE requires at most 4 arguments")
	}
	trials := argsList.Front().Value.(formulaArg).ToNumber()
	if trials.Type != ArgNumber {
		return trials
	}
	probability := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if probability.Type != ArgNumber {
		return probability
	}
	if probability.Number < 0 || probability.Number > 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	num1 := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if num1.Type != ArgNumber {
		return num1
	}
	if num1.Number < 0 || num1.Number > trials.Number {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	num2 := num1
	if argsList.Len() > 3 {
		if num2 = argsList.Back().Value.(formulaArg).ToNumber(); num2.Type != ArgNumber {
			return num2
		}
	}
	if num2.Number < 0 || num2.Number > trials.Number {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	sum := 0.0
	for i := num1.Number; i <= num2.Number; i++ {
		sum += binomdist(i, trials.Number, probability.Number)
	}
	return newNumberFormulaArg(sum)
}

// binominv implement inverse of the binomial distribution calculation.
func binominv(n, p, alpha float64) float64 {
	q, i, sum, maxVal := 1-p, 0.0, 0.0, 0.0
	n = math.Floor(n)
	if q > p {
		factor := math.Pow(q, n)
		sum = factor
		for i = 0; i < n && sum < alpha; i++ {
			factor *= (n - i) / (i + 1) * p / q
			sum += factor
		}
		return i
	}
	factor := math.Pow(p, n)
	sum, maxVal = 1-factor, n
	for i = 0; i < maxVal && sum >= alpha; i++ {
		factor *= (n - i) / (i + 1) * q / p
		sum -= factor
	}
	return n - i
}

// BINOMdotINV function returns the inverse of the Cumulative Binomial
// Distribution. The syntax of the function is:
//
//	BINOM.INV(trials,probability_s,alpha)
func (fn *formulaFuncs) BINOMdotINV(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "BINOM.INV requires 3 numeric arguments")
	}
	trials := argsList.Front().Value.(formulaArg).ToNumber()
	if trials.Type != ArgNumber {
		return trials
	}
	if trials.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	probability := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if probability.Type != ArgNumber {
		return probability
	}
	if probability.Number <= 0 || probability.Number >= 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	alpha := argsList.Back().Value.(formulaArg).ToNumber()
	if alpha.Type != ArgNumber {
		return alpha
	}
	if alpha.Number <= 0 || alpha.Number >= 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(binominv(trials.Number, probability.Number, alpha.Number))
}

// CHIDIST function calculates the right-tailed probability of the chi-square
// distribution. The syntax of the function is:
//
//	CHIDIST(x,degrees_freedom)
func (fn *formulaFuncs) CHIDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "CHIDIST requires 2 numeric arguments")
	}
	x := argsList.Front().Value.(formulaArg).ToNumber()
	if x.Type != ArgNumber {
		return x
	}
	degrees := argsList.Back().Value.(formulaArg).ToNumber()
	if degrees.Type != ArgNumber {
		return degrees
	}
	logSqrtPi, sqrtPi := math.Log(math.Sqrt(math.Pi)), 1/math.Sqrt(math.Pi)
	var e, s, z, c, y float64
	a, x1, even := x.Number/2, x.Number, int(degrees.Number)%2 == 0
	if degrees.Number > 1 {
		y = math.Exp(-a)
	}
	args := list.New()
	args.PushBack(newNumberFormulaArg(-math.Sqrt(x1)))
	o := fn.NORMSDIST(args)
	s = 2 * o.Number
	if even {
		s = y
	}
	if degrees.Number > 2 {
		x1 = (degrees.Number - 1) / 2
		z = 0.5
		if even {
			z = 1
		}
		if a > 20 {
			e = logSqrtPi
			if even {
				e = 0
			}
			c = math.Log(a)
			for z <= x1 {
				e = math.Log(z) + e
				s += math.Exp(c*z - a - e)
				z++
			}
			return newNumberFormulaArg(s)
		}
		e = sqrtPi / math.Sqrt(a)
		if even {
			e = 1
		}
		c = 0
		for z <= x1 {
			e = e * (a / z)
			c = c + e
			z++
		}
		return newNumberFormulaArg(c*y + s)
	}
	return newNumberFormulaArg(s)
}

// CHIINV function calculates the inverse of the right-tailed probability of
// the Chi-Square Distribution. The syntax of the function is:
//
//	CHIINV(probability,deg_freedom)
func (fn *formulaFuncs) CHIINV(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "CHIINV requires 2 numeric arguments")
	}
	probability := argsList.Front().Value.(formulaArg).ToNumber()
	if probability.Type != ArgNumber {
		return probability
	}
	if probability.Number <= 0 || probability.Number > 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	deg := argsList.Back().Value.(formulaArg).ToNumber()
	if deg.Type != ArgNumber {
		return deg
	}
	if deg.Number < 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(gammainv(1-probability.Number, 0.5*deg.Number, 2.0))
}

// CHITEST function uses the chi-square test to calculate the probability that
// the differences between two supplied data sets (of observed and expected
// frequencies), are likely to be simply due to sampling error, or if they are
// likely to be real. The syntax of the function is:
//
//	CHITEST(actual_range,expected_range)
func (fn *formulaFuncs) CHITEST(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "CHITEST requires 2 arguments")
	}
	actual, expected := argsList.Front().Value.(formulaArg), argsList.Back().Value.(formulaArg)
	actualList, expectedList := actual.ToList(), expected.ToList()
	rows := len(actual.Matrix)
	if rows == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	columns := len(actualList) / rows
	if len(actualList) != len(expectedList) || len(actualList) == 1 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	var result float64
	var degrees int
	for i := 0; i < len(actualList); i++ {
		a, e := actualList[i].ToNumber(), expectedList[i].ToNumber()
		if a.Type == ArgNumber && e.Type == ArgNumber {
			if e.Number == 0 {
				return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
			}
			if e.Number < 0 {
				return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
			}
			result += (a.Number - e.Number) * (a.Number - e.Number) / e.Number
		}
	}
	if rows == 1 {
		degrees = columns - 1
	} else if columns == 1 {
		degrees = rows - 1
	} else {
		degrees = (columns - 1) * (rows - 1)
	}
	args := list.New()
	args.PushBack(newNumberFormulaArg(result))
	args.PushBack(newNumberFormulaArg(float64(degrees)))
	return fn.CHIDIST(args)
}

// getGammaSeries calculates a power-series of the gamma function.
func getGammaSeries(fA, fX float64) float64 {
	var (
		fHalfMachEps = 2.22045e-016 / 2
		fDenomfactor = fA
		fSummand     = 1 / fA
		fSum         = fSummand
		nCount       = 1
	)
	for fSummand/fSum > fHalfMachEps && nCount <= 10000 {
		fDenomfactor = fDenomfactor + 1
		fSummand = fSummand * fX / fDenomfactor
		fSum = fSum + fSummand
		nCount = nCount + 1
	}
	return fSum
}

// getGammaContFraction returns continued fraction with odd items of the gamma
// function.
func getGammaContFraction(fA, fX float64) float64 {
	var (
		fBigInv      = 2.22045e-016
		fHalfMachEps = fBigInv / 2
		fBig         = 1 / fBigInv
		fCount       = 0.0
		fY           = 1 - fA
		fDenom       = fX + 2 - fA
		fPkm1        = fX + 1
		fPkm2        = 1.0
		fQkm1        = fDenom * fX
		fQkm2        = fX
		fApprox      = fPkm1 / fQkm1
		bFinished    = false
	)
	for !bFinished && fCount < 10000 {
		fCount = fCount + 1
		fY = fY + 1
		fDenom = fDenom + 2
		var (
			fNum = fY * fCount
			f1   = fPkm1 * fDenom
			f2   = fPkm2 * fNum
			fPk  = math.Nextafter(f1, f1) - math.Nextafter(f2, f2)
			f3   = fQkm1 * fDenom
			f4   = fQkm2 * fNum
			fQk  = math.Nextafter(f3, f3) - math.Nextafter(f4, f4)
		)
		if fQk != 0 {
			fR := fPk / fQk
			bFinished = math.Abs((fApprox-fR)/fR) <= fHalfMachEps
			fApprox = fR
		}
		fPkm2, fPkm1, fQkm2, fQkm1 = fPkm1, fPk, fQkm1, fQk
		if math.Abs(fPk) > fBig {
			// reduce a fraction does not change the value
			fPkm2 = fPkm2 * fBigInv
			fPkm1 = fPkm1 * fBigInv
			fQkm2 = fQkm2 * fBigInv
			fQkm1 = fQkm1 * fBigInv
		}
	}
	return fApprox
}

// getLogGammaHelper is a part of implementation of the function getLogGamma.
func getLogGammaHelper(fZ float64) float64 {
	_fg := 6.024680040776729583740234375
	zgHelp := fZ + _fg - 0.5
	return math.Log(getLanczosSum(fZ)) + (fZ-0.5)*math.Log(zgHelp) - zgHelp
}

// getGammaHelper is a part of implementation of the function getLogGamma.
func getGammaHelper(fZ float64) float64 {
	var (
		gamma  = getLanczosSum(fZ)
		fg     = 6.024680040776729583740234375
		zgHelp = fZ + fg - 0.5
		// avoid intermediate overflow
		halfpower = math.Pow(zgHelp, fZ/2-0.25)
	)
	gamma *= halfpower
	gamma /= math.Exp(zgHelp)
	gamma *= halfpower
	if fZ <= 20 && fZ == math.Floor(fZ) {
		gamma = math.Round(gamma)
	}
	return gamma
}

// getLogGamma calculates the natural logarithm of the gamma function.
func getLogGamma(fZ float64) float64 {
	fMaxGammaArgument := 171.624376956302
	if fZ >= fMaxGammaArgument {
		return getLogGammaHelper(fZ)
	}
	if fZ >= 1.0 {
		return math.Log(getGammaHelper(fZ))
	}
	if fZ >= 0.5 {
		return math.Log(getGammaHelper(fZ+1) / fZ)
	}
	return getLogGammaHelper(fZ+2) - math.Log(fZ+1) - math.Log(fZ)
}

// getLowRegIGamma returns lower regularized incomplete gamma function.
func getLowRegIGamma(fA, fX float64) float64 {
	lnFactor := fA*math.Log(fX) - fX - getLogGamma(fA)
	factor := math.Exp(lnFactor)
	if fX > fA+1 {
		return 1 - factor*getGammaContFraction(fA, fX)
	}
	return factor * getGammaSeries(fA, fX)
}

// getChiSqDistCDF returns left tail for the Chi-Square distribution.
func getChiSqDistCDF(fX, fDF float64) float64 {
	if fX <= 0 {
		return 0
	}
	return getLowRegIGamma(fDF/2, fX/2)
}

// getChiSqDistPDF calculates the probability density function for the
// Chi-Square distribution.
func getChiSqDistPDF(fX, fDF float64) float64 {
	if fDF*fX > 1391000 {
		return math.Exp((0.5*fDF-1)*math.Log(fX*0.5) - 0.5*fX - math.Log(2) - getLogGamma(0.5*fDF))
	}
	var fCount, fValue float64
	if math.Mod(fDF, 2) < 0.5 {
		fValue = 0.5
		fCount = 2
	} else {
		fValue = 1 / math.Sqrt(fX*2*math.Pi)
		fCount = 1
	}
	for fCount < fDF {
		fValue *= fX / fCount
		fCount += 2
	}
	if fX >= 1425 {
		fValue = math.Exp(math.Log(fValue) - fX/2)
	} else {
		fValue *= math.Exp(-fX / 2)
	}
	return fValue
}

// CHISQdotDIST function calculates the Probability Density Function or the
// Cumulative Distribution Function for the Chi-Square Distribution. The
// syntax of the function is:
//
//	CHISQ.DIST(x,degrees_freedom,cumulative)
func (fn *formulaFuncs) CHISQdotDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "CHISQ.DIST requires 3 arguments")
	}
	var x, degrees, cumulative formulaArg
	if x = argsList.Front().Value.(formulaArg).ToNumber(); x.Type != ArgNumber {
		return x
	}
	if degrees = argsList.Front().Next().Value.(formulaArg).ToNumber(); degrees.Type != ArgNumber {
		return degrees
	}
	if cumulative = argsList.Back().Value.(formulaArg).ToBool(); cumulative.Type == ArgError {
		return cumulative
	}
	if x.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	maxDeg := math.Pow10(10)
	if degrees.Number < 1 || degrees.Number >= maxDeg {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if cumulative.Number == 1 {
		return newNumberFormulaArg(getChiSqDistCDF(x.Number, degrees.Number))
	}
	return newNumberFormulaArg(getChiSqDistPDF(x.Number, degrees.Number))
}

// CHISQdotDISTdotRT function calculates the right-tailed probability of the
// Chi-Square Distribution. The syntax of the function is:
//
//	CHISQ.DIST.RT(x,degrees_freedom)
func (fn *formulaFuncs) CHISQdotDISTdotRT(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "CHISQ.DIST.RT requires 2 numeric arguments")
	}
	return fn.CHIDIST(argsList)
}

// CHISQdotTEST function performs the chi-square test on two supplied data sets
// (of observed and expected frequencies), and returns the probability that
// the differences between the sets are simply due to sampling error. The
// syntax of the function is:
//
//	CHISQ.TEST(actual_range,expected_range)
func (fn *formulaFuncs) CHISQdotTEST(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "CHISQ.TEST requires 2 arguments")
	}
	return fn.CHITEST(argsList)
}

// hasChangeOfSign check if the sign has been changed.
func hasChangeOfSign(u, w float64) bool {
	return (u < 0 && w > 0) || (u > 0 && w < 0)
}

// calcInverseIterator directly maps the required parameters for inverse
// distribution functions.
type calcInverseIterator struct {
	name        string
	fp, fDF, nT float64
}

// callBack implements the callback function for the inverse iterator.
func (iterator *calcInverseIterator) callBack(x float64) float64 {
	if iterator.name == "CHISQ.INV" {
		return iterator.fp - getChiSqDistCDF(x, iterator.fDF)
	}
	return iterator.fp - getTDist(x, iterator.fDF, iterator.nT)
}

// inverseQuadraticInterpolation inverse quadratic interpolation with
// additional brackets.
func inverseQuadraticInterpolation(iterator calcInverseIterator, fAx, fAy, fBx, fBy float64) float64 {
	fYEps := 1.0e-307
	fXEps := 2.22045e-016
	fPx, fPy, fQx, fQy, fRx, fRy := fAx, fAy, fBx, fBy, fAx, fAy
	fSx := 0.5 * (fAx + fBx)
	bHasToInterpolate := true
	nCount := 0
	for nCount < 500 && math.Abs(fRy) > fYEps && (fBx-fAx) > math.Max(math.Abs(fAx), math.Abs(fBx))*fXEps {
		if bHasToInterpolate {
			if fPy != fQy && fQy != fRy && fRy != fPy {
				fSx = fPx*fRy*fQy/(fRy-fPy)/(fQy-fPy) + fRx*fQy*fPy/(fQy-fRy)/(fPy-fRy) +
					fQx*fPy*fRy/(fPy-fQy)/(fRy-fQy)
				bHasToInterpolate = (fAx < fSx) && (fSx < fBx)
			} else {
				bHasToInterpolate = false
			}
		}
		if !bHasToInterpolate {
			fSx = 0.5 * (fAx + fBx)
			fQx, fQy = fBx, fBy
			bHasToInterpolate = true
		}
		fPx, fQx, fRx, fPy, fQy = fQx, fRx, fSx, fQy, fRy
		fRy = iterator.callBack(fSx)
		if hasChangeOfSign(fAy, fRy) {
			fBx, fBy = fRx, fRy
		} else {
			fAx, fAy = fRx, fRy
		}
		bHasToInterpolate = bHasToInterpolate && (math.Abs(fRy)*2 <= math.Abs(fQy))
		nCount++
	}
	return fRx
}

// calcIterateInverse function calculates the iteration for inverse
// distributions.
func calcIterateInverse(iterator calcInverseIterator, fAx, fBx float64) float64 {
	fAy, fBy := iterator.callBack(fAx), iterator.callBack(fBx)
	var fTemp float64
	var nCount int
	for nCount = 0; nCount < 1000 && !hasChangeOfSign(fAy, fBy); nCount++ {
		if math.Abs(fAy) <= math.Abs(fBy) {
			fTemp = fAx
			fAx += 2 * (fAx - fBx)
			if fAx < 0 {
				fAx = 0
			}
			fBx = fTemp
			fBy = fAy
			fAy = iterator.callBack(fAx)
		} else {
			fTemp = fBx
			fBx += 2 * (fBx - fAx)
			fAx = fTemp
			fAy = fBy
			fBy = iterator.callBack(fBx)
		}
	}
	if fAy == 0 || fBy == 0 {
		return 0
	}
	return inverseQuadraticInterpolation(iterator, fAx, fAy, fBx, fBy)
}

// CHISQdotINV function calculates the inverse of the left-tailed probability
// of the Chi-Square Distribution. The syntax of the function is:
//
//	CHISQ.INV(probability,degrees_freedom)
func (fn *formulaFuncs) CHISQdotINV(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "CHISQ.INV requires 2 numeric arguments")
	}
	var probability, degrees formulaArg
	if probability = argsList.Front().Value.(formulaArg).ToNumber(); probability.Type != ArgNumber {
		return probability
	}
	if degrees = argsList.Back().Value.(formulaArg).ToNumber(); degrees.Type != ArgNumber {
		return degrees
	}
	if probability.Number < 0 || probability.Number >= 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if degrees.Number < 1 || degrees.Number > math.Pow10(10) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(calcIterateInverse(calcInverseIterator{
		name: "CHISQ.INV",
		fp:   probability.Number,
		fDF:  degrees.Number,
	}, degrees.Number/2, degrees.Number))
}

// CHISQdotINVdotRT function calculates the inverse of the right-tailed
// probability of the Chi-Square Distribution. The syntax of the function is:
//
//	CHISQ.INV.RT(probability,degrees_freedom)
func (fn *formulaFuncs) CHISQdotINVdotRT(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "CHISQ.INV.RT requires 2 numeric arguments")
	}
	return fn.CHIINV(argsList)
}

// confidence is an implementation of the formula functions CONFIDENCE and
// CONFIDENCE.NORM.
func (fn *formulaFuncs) confidence(name string, argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires 3 numeric arguments", name))
	}
	alpha := argsList.Front().Value.(formulaArg).ToNumber()
	if alpha.Type != ArgNumber {
		return alpha
	}
	if alpha.Number <= 0 || alpha.Number >= 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	stdDev := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if stdDev.Type != ArgNumber {
		return stdDev
	}
	if stdDev.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	size := argsList.Back().Value.(formulaArg).ToNumber()
	if size.Type != ArgNumber {
		return size
	}
	if size.Number < 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	args := list.New()
	args.Init()
	args.PushBack(newNumberFormulaArg(alpha.Number / 2))
	args.PushBack(newNumberFormulaArg(0))
	args.PushBack(newNumberFormulaArg(1))
	return newNumberFormulaArg(-fn.NORMINV(args).Number * (stdDev.Number / math.Sqrt(size.Number)))
}

// CONFIDENCE function uses a Normal Distribution to calculate a confidence
// value that can be used to construct the Confidence Interval for a
// population mean, for a supplied probability and sample size. It is assumed
// that the standard deviation of the population is known. The syntax of the
// function is:
//
//	CONFIDENCE(alpha,standard_dev,size)
func (fn *formulaFuncs) CONFIDENCE(argsList *list.List) formulaArg {
	return fn.confidence("CONFIDENCE", argsList)
}

// CONFIDENCEdotNORM function uses a Normal Distribution to calculate a
// confidence value that can be used to construct the confidence interval for
// a population mean, for a supplied probability and sample size. It is
// assumed that the standard deviation of the population is known. The syntax
// of the function is:
//
//	CONFIDENCE.NORM(alpha,standard_dev,size)
func (fn *formulaFuncs) CONFIDENCEdotNORM(argsList *list.List) formulaArg {
	return fn.confidence("CONFIDENCE.NORM", argsList)
}

// CONFIDENCEdotT function uses a Student's T-Distribution to calculate a
// confidence value that can be used to construct the confidence interval for
// a population mean, for a supplied probablity and supplied sample size. It
// is assumed that the standard deviation of the population is known. The
// syntax of the function is:
//
//	CONFIDENCE.T(alpha,standard_dev,size)
func (fn *formulaFuncs) CONFIDENCEdotT(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "CONFIDENCE.T requires 3 arguments")
	}
	var alpha, standardDev, size formulaArg
	if alpha = argsList.Front().Value.(formulaArg).ToNumber(); alpha.Type != ArgNumber {
		return alpha
	}
	if standardDev = argsList.Front().Next().Value.(formulaArg).ToNumber(); standardDev.Type != ArgNumber {
		return standardDev
	}
	if size = argsList.Back().Value.(formulaArg).ToNumber(); size.Type != ArgNumber {
		return size
	}
	if alpha.Number <= 0 || alpha.Number >= 1 || standardDev.Number <= 0 || size.Number < 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if size.Number == 1 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	return newNumberFormulaArg(standardDev.Number * calcIterateInverse(calcInverseIterator{
		name: "CONFIDENCE.T",
		fp:   alpha.Number,
		fDF:  size.Number - 1,
		nT:   2,
	}, size.Number/2, size.Number) / math.Sqrt(size.Number))
}

// covar is an implementation of the formula functions COVAR, COVARIANCE.P and
// COVARIANCE.S.
func (fn *formulaFuncs) covar(name string, argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires 2 arguments", name))
	}
	array1 := argsList.Front().Value.(formulaArg)
	array2 := argsList.Back().Value.(formulaArg)
	left, right := array1.ToList(), array2.ToList()
	n := len(left)
	if n != len(right) {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	l1, l2 := list.New(), list.New()
	l1.PushBack(array1)
	l2.PushBack(array2)
	result, skip := 0.0, 0
	mean1, mean2 := fn.AVERAGE(l1), fn.AVERAGE(l2)
	for i := 0; i < n; i++ {
		arg1 := left[i].ToNumber()
		arg2 := right[i].ToNumber()
		if arg1.Type == ArgError || arg2.Type == ArgError {
			skip++
			continue
		}
		result += (arg1.Number - mean1.Number) * (arg2.Number - mean2.Number)
	}
	if name == "COVARIANCE.S" {
		return newNumberFormulaArg(result / float64(n-skip-1))
	}
	return newNumberFormulaArg(result / float64(n-skip))
}

// COVAR function calculates the covariance of two supplied sets of values. The
// syntax of the function is:
//
//	COVAR(array1,array2)
func (fn *formulaFuncs) COVAR(argsList *list.List) formulaArg {
	return fn.covar("COVAR", argsList)
}

// COVARIANCEdotP function calculates the population covariance of two supplied
// sets of values. The syntax of the function is:
//
//	COVARIANCE.P(array1,array2)
func (fn *formulaFuncs) COVARIANCEdotP(argsList *list.List) formulaArg {
	return fn.covar("COVARIANCE.P", argsList)
}

// COVARIANCEdotS function calculates the sample covariance of two supplied
// sets of values. The syntax of the function is:
//
//	COVARIANCE.S(array1,array2)
func (fn *formulaFuncs) COVARIANCEdotS(argsList *list.List) formulaArg {
	return fn.covar("COVARIANCE.S", argsList)
}

// calcStringCountSum is part of the implementation countSum.
func calcStringCountSum(countText bool, count, sum float64, num, arg formulaArg) (float64, float64) {
	if countText && num.Type == ArgError && arg.String != "" {
		count++
	}
	if num.Type == ArgNumber {
		sum += num.Number
		count++
	}
	return count, sum
}

// countSum get count and sum for a formula arguments array.
func (fn *formulaFuncs) countSum(countText bool, args []formulaArg) (count, sum float64) {
	for _, arg := range args {
		switch arg.Type {
		case ArgNumber:
			if countText || !arg.Boolean {
				sum += arg.Number
				count++
			}
		case ArgString:
			if !countText && (arg.Value() == "TRUE" || arg.Value() == "FALSE") {
				continue
			} else if countText && (arg.Value() == "TRUE" || arg.Value() == "FALSE") {
				num := arg.ToBool()
				if num.Type == ArgNumber {
					count++
					sum += num.Number
					continue
				}
			}
			num := arg.ToNumber()
			count, sum = calcStringCountSum(countText, count, sum, num, arg)
		case ArgList, ArgMatrix:
			cnt, summary := fn.countSum(countText, arg.ToList())
			sum += summary
			count += cnt
		}
	}
	return
}

// CORREL function calculates the Pearson Product-Moment Correlation
// Coefficient for two sets of values. The syntax of the function is:
//
//	CORREL(array1,array2)
func (fn *formulaFuncs) CORREL(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "CORREL requires 2 arguments")
	}
	array1 := argsList.Front().Value.(formulaArg)
	array2 := argsList.Back().Value.(formulaArg)
	left, right := array1.ToList(), array2.ToList()
	n := len(left)
	if n != len(right) {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	l1, l2, l3 := list.New(), list.New(), list.New()
	for i := 0; i < n; i++ {
		if lhs, rhs := left[i].ToNumber(), right[i].ToNumber(); lhs.Number != 0 && rhs.Number != 0 {
			l1.PushBack(lhs)
			l2.PushBack(rhs)
		}
	}
	stdev1, stdev2 := fn.STDEV(l1), fn.STDEV(l2)
	if stdev1.Number == 0 || stdev2.Number == 0 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	mean1, mean2, skip := fn.AVERAGE(l1), fn.AVERAGE(l2), 0
	for i := 0; i < n; i++ {
		lhs, rhs := left[i].ToNumber(), right[i].ToNumber()
		if lhs.Number == 0 || rhs.Number == 0 {
			skip++
			continue
		}
		l3.PushBack(newNumberFormulaArg((lhs.Number - mean1.Number) * (rhs.Number - mean2.Number)))
	}
	return newNumberFormulaArg(fn.SUM(l3).Number / float64(n-skip-1) / stdev1.Number / stdev2.Number)
}

// COUNT function returns the count of numeric values in a supplied set of
// cells or values. This count includes both numbers and dates. The syntax of
// the function is:
//
//	COUNT(value1,[value2],...)
func (fn *formulaFuncs) COUNT(argsList *list.List) formulaArg {
	var count int
	for token := argsList.Front(); token != nil; token = token.Next() {
		arg := token.Value.(formulaArg)
		switch arg.Type {
		case ArgString:
			if num := arg.ToNumber(); num.Type == ArgNumber {
				count++
			}
		case ArgNumber:
			count++
		case ArgMatrix:
			for _, row := range arg.Matrix {
				for _, cell := range row {
					if cell.Type == ArgNumber {
						count++
					}
				}
			}
		}
	}
	return newNumberFormulaArg(float64(count))
}

// COUNTA function returns the number of non-blanks within a supplied set of
// cells or values. The syntax of the function is:
//
//	COUNTA(value1,[value2],...)
func (fn *formulaFuncs) COUNTA(argsList *list.List) formulaArg {
	var count int
	for token := argsList.Front(); token != nil; token = token.Next() {
		arg := token.Value.(formulaArg)
		switch arg.Type {
		case ArgString:
			if arg.String != "" {
				count++
			}
		case ArgNumber:
			count++
		case ArgMatrix:
			for _, row := range arg.ToList() {
				switch row.Type {
				case ArgString:
					if row.String != "" {
						count++
					}
				case ArgNumber:
					count++
				}
			}
		}
	}
	return newNumberFormulaArg(float64(count))
}

// COUNTBLANK function returns the number of blank cells in a supplied range.
// The syntax of the function is:
//
//	COUNTBLANK(range)
func (fn *formulaFuncs) COUNTBLANK(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "COUNTBLANK requires 1 argument")
	}
	var count float64
	for _, cell := range argsList.Front().Value.(formulaArg).ToList() {
		if cell.Type == ArgEmpty {
			count++
		}
	}
	return newNumberFormulaArg(count)
}

// COUNTIF function returns the number of cells within a supplied range, that
// satisfy a given criteria. The syntax of the function is:
//
//	COUNTIF(range,criteria)
func (fn *formulaFuncs) COUNTIF(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "COUNTIF requires 2 arguments")
	}
	var (
		criteria = formulaCriteriaParser(argsList.Front().Next().Value.(formulaArg))
		count    float64
	)
	for _, cell := range argsList.Front().Value.(formulaArg).ToList() {
		if cell.Type == ArgString && criteria.Condition.Type != ArgString {
			continue
		}
		if ok, _ := formulaCriteriaEval(cell, criteria); ok {
			count++
		}
	}
	return newNumberFormulaArg(count)
}

// formulaIfsMatch function returns cells reference array which match criteria.
func formulaIfsMatch(args []formulaArg) (cellRefs []cellRef) {
	for i := 0; i < len(args)-1; i += 2 {
		var match []cellRef
		matrix, criteria := args[i].Matrix, formulaCriteriaParser(args[i+1])
		if i == 0 {
			for rowIdx, row := range matrix {
				for colIdx, col := range row {
					if ok, _ := formulaCriteriaEval(col, criteria); ok {
						match = append(match, cellRef{Col: colIdx, Row: rowIdx})
					}
				}
			}
		} else {
			match = []cellRef{}
			for _, ref := range cellRefs {
				value := matrix[ref.Row][ref.Col]
				if ok, _ := formulaCriteriaEval(value, criteria); ok {
					match = append(match, ref)
				}
			}
		}
		cellRefs = match[:]
	}
	return
}

// COUNTIFS function returns the number of rows within a table, that satisfy a
// set of given criteria. The syntax of the function is:
//
//	COUNTIFS(criteria_range1,criteria1,[criteria_range2,criteria2],...)
func (fn *formulaFuncs) COUNTIFS(argsList *list.List) formulaArg {
	if argsList.Len() < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "COUNTIFS requires at least 2 arguments")
	}
	if argsList.Len()%2 != 0 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	var args []formulaArg
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		args = append(args, arg.Value.(formulaArg))
	}
	return newNumberFormulaArg(float64(len(formulaIfsMatch(args))))
}

// CRITBINOM function returns the inverse of the Cumulative Binomial
// Distribution. I.e. for a specific number of independent trials, the
// function returns the smallest value (number of successes) for which the
// cumulative binomial distribution is greater than or equal to a specified
// value. The syntax of the function is:
//
//	CRITBINOM(trials,probability_s,alpha)
func (fn *formulaFuncs) CRITBINOM(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "CRITBINOM requires 3 numeric arguments")
	}
	return fn.BINOMdotINV(argsList)
}

// DEVSQ function calculates the sum of the squared deviations from the sample
// mean. The syntax of the function is:
//
//	DEVSQ(number1,[number2],...)
func (fn *formulaFuncs) DEVSQ(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "DEVSQ requires at least 1 numeric argument")
	}
	avg, count, result := fn.AVERAGE(argsList), -1, 0.0
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		for _, cell := range arg.Value.(formulaArg).ToList() {
			if cell.Type != ArgNumber {
				continue
			}
			count++
			if count == 0 {
				result = math.Pow(cell.Number-avg.Number, 2)
				continue
			}
			result += math.Pow(cell.Number-avg.Number, 2)
		}
	}
	if count == -1 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	return newNumberFormulaArg(result)
}

// FISHER function calculates the Fisher Transformation for a supplied value.
// The syntax of the function is:
//
//	FISHER(x)
func (fn *formulaFuncs) FISHER(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "FISHER requires 1 numeric argument")
	}
	token := argsList.Front().Value.(formulaArg)
	switch token.Type {
	case ArgString:
		arg := token.ToNumber()
		if arg.Type == ArgNumber {
			if arg.Number <= -1 || arg.Number >= 1 {
				return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
			}
			return newNumberFormulaArg(0.5 * math.Log((1+arg.Number)/(1-arg.Number)))
		}
	case ArgNumber:
		if token.Number <= -1 || token.Number >= 1 {
			return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
		}
		return newNumberFormulaArg(0.5 * math.Log((1+token.Number)/(1-token.Number)))
	}
	return newErrorFormulaArg(formulaErrorVALUE, "FISHER requires 1 numeric argument")
}

// FISHERINV function calculates the inverse of the Fisher Transformation and
// returns a value between -1 and +1. The syntax of the function is:
//
//	FISHERINV(y)
func (fn *formulaFuncs) FISHERINV(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "FISHERINV requires 1 numeric argument")
	}
	token := argsList.Front().Value.(formulaArg)
	switch token.Type {
	case ArgString:
		arg := token.ToNumber()
		if arg.Type == ArgNumber {
			return newNumberFormulaArg((math.Exp(2*arg.Number) - 1) / (math.Exp(2*arg.Number) + 1))
		}
	case ArgNumber:
		return newNumberFormulaArg((math.Exp(2*token.Number) - 1) / (math.Exp(2*token.Number) + 1))
	}
	return newErrorFormulaArg(formulaErrorVALUE, "FISHERINV requires 1 numeric argument")
}

// FORECAST function predicts a future point on a linear trend line fitted to a
// supplied set of x- and y- values. The syntax of the function is:
//
//	FORECAST(x,known_y's,known_x's)
func (fn *formulaFuncs) FORECAST(argsList *list.List) formulaArg {
	return fn.pearsonProduct("FORECAST", 3, argsList)
}

// FORECASTdotLINEAR function predicts a future point on a linear trend line
// fitted to a supplied set of x- and y- values. The syntax of the function is:
//
//	FORECAST.LINEAR(x,known_y's,known_x's)
func (fn *formulaFuncs) FORECASTdotLINEAR(argsList *list.List) formulaArg {
	return fn.pearsonProduct("FORECAST.LINEAR", 3, argsList)
}

// matrixToSortedColumnList convert matrix formula arguments to a ascending
// order list by column.
func matrixToSortedColumnList(arg formulaArg) formulaArg {
	var (
		mtx  []formulaArg
		cols = len(arg.Matrix[0])
	)
	for colIdx := 0; colIdx < cols; colIdx++ {
		for _, row := range arg.Matrix {
			cell := row[colIdx]
			if cell.Type == ArgError {
				return cell
			}
			if cell.Type == ArgNumber {
				mtx = append(mtx, cell)
			}
		}
	}
	argsList := newListFormulaArg(mtx)
	sort.Slice(argsList.List, func(i, j int) bool {
		return argsList.List[i].Number < argsList.List[j].Number
	})
	return argsList
}

// FREQUENCY function to count how many children fall into different age
// ranges. The syntax of the function is:
//
//	FREQUENCY(data_array,bins_array)
func (fn *formulaFuncs) FREQUENCY(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "FREQUENCY requires 2 arguments")
	}
	data, bins := argsList.Front().Value.(formulaArg), argsList.Back().Value.(formulaArg)
	if len(data.Matrix) == 0 {
		data.Matrix = [][]formulaArg{{data}}
	}
	if len(bins.Matrix) == 0 {
		bins.Matrix = [][]formulaArg{{bins}}
	}
	var (
		dataMtx, binsMtx formulaArg
		c                [][]formulaArg
		i, j             int
	)
	if dataMtx = matrixToSortedColumnList(data); dataMtx.Type != ArgList {
		return dataMtx
	}
	if binsMtx = matrixToSortedColumnList(bins); binsMtx.Type != ArgList {
		return binsMtx
	}
	for row := 0; row < len(binsMtx.List)+1; row++ {
		var rows []formulaArg
		for col := 0; col < 1; col++ {
			rows = append(rows, newNumberFormulaArg(0))
		}
		c = append(c, rows)
	}
	for j = 0; j < len(binsMtx.List); j++ {
		n := 0.0
		for i < len(dataMtx.List) && dataMtx.List[i].Number <= binsMtx.List[j].Number {
			n++
			i++
		}
		c[j] = []formulaArg{newNumberFormulaArg(n)}
	}
	c[j] = []formulaArg{newNumberFormulaArg(float64(len(dataMtx.List) - i))}
	if len(c) > 2 {
		c[1], c[2] = c[2], c[1]
	}
	return newMatrixFormulaArg(c)
}

// GAMMA function returns the value of the Gamma Function, Î“(n), for a
// specified number, n. The syntax of the function is:
//
//	GAMMA(number)
func (fn *formulaFuncs) GAMMA(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "GAMMA requires 1 numeric argument")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, "GAMMA requires 1 numeric argument")
	}
	if number.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	return newNumberFormulaArg(math.Gamma(number.Number))
}

// GAMMAdotDIST function returns the Gamma Distribution, which is frequently
// used to provide probabilities for values that may have a skewed
// distribution, such as queuing analysis.
//
//	GAMMA.DIST(x,alpha,beta,cumulative)
func (fn *formulaFuncs) GAMMAdotDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "GAMMA.DIST requires 4 arguments")
	}
	return fn.GAMMADIST(argsList)
}

// GAMMADIST function returns the Gamma Distribution, which is frequently used
// to provide probabilities for values that may have a skewed distribution,
// such as queuing analysis.
//
//	GAMMADIST(x,alpha,beta,cumulative)
func (fn *formulaFuncs) GAMMADIST(argsList *list.List) formulaArg {
	if argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "GAMMADIST requires 4 arguments")
	}
	var x, alpha, beta, cumulative formulaArg
	if x = argsList.Front().Value.(formulaArg).ToNumber(); x.Type != ArgNumber {
		return x
	}
	if x.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if alpha = argsList.Front().Next().Value.(formulaArg).ToNumber(); alpha.Type != ArgNumber {
		return alpha
	}
	if beta = argsList.Back().Prev().Value.(formulaArg).ToNumber(); beta.Type != ArgNumber {
		return beta
	}
	if alpha.Number <= 0 || beta.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if cumulative = argsList.Back().Value.(formulaArg).ToBool(); cumulative.Type == ArgError {
		return cumulative
	}
	if cumulative.Number == 1 {
		return newNumberFormulaArg(incompleteGamma(alpha.Number, x.Number/beta.Number) / math.Gamma(alpha.Number))
	}
	return newNumberFormulaArg((1 / (math.Pow(beta.Number, alpha.Number) * math.Gamma(alpha.Number))) * math.Pow(x.Number, alpha.Number-1) * math.Exp(0-(x.Number/beta.Number)))
}

// gammainv returns the inverse of the Gamma distribution for the specified
// value.
func gammainv(probability, alpha, beta float64) float64 {
	xLo, xHi := 0.0, alpha*beta*5
	dx, x, xNew, result := 1024.0, 1.0, 1.0, 0.0
	for i := 0; math.Abs(dx) > 8.88e-016 && i <= 256; i++ {
		result = incompleteGamma(alpha, x/beta) / math.Gamma(alpha)
		e := result - probability
		if e == 0 {
			dx = 0
		} else if e < 0 {
			xLo = x
		} else {
			xHi = x
		}
		pdf := (1 / (math.Pow(beta, alpha) * math.Gamma(alpha))) * math.Pow(x, alpha-1) * math.Exp(0-(x/beta))
		if pdf != 0 {
			dx = e / pdf
			xNew = x - dx
		}
		if xNew < xLo || xNew > xHi || pdf == 0 {
			xNew = (xLo + xHi) / 2
			dx = xNew - x
		}
		x = xNew
	}
	return x
}

// GAMMAdotINV function returns the inverse of the Gamma Cumulative
// Distribution. The syntax of the function is:
//
//	GAMMA.INV(probability,alpha,beta)
func (fn *formulaFuncs) GAMMAdotINV(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "GAMMA.INV requires 3 arguments")
	}
	return fn.GAMMAINV(argsList)
}

// GAMMAINV function returns the inverse of the Gamma Cumulative Distribution.
// The syntax of the function is:
//
//	GAMMAINV(probability,alpha,beta)
func (fn *formulaFuncs) GAMMAINV(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "GAMMAINV requires 3 arguments")
	}
	var probability, alpha, beta formulaArg
	if probability = argsList.Front().Value.(formulaArg).ToNumber(); probability.Type != ArgNumber {
		return probability
	}
	if probability.Number < 0 || probability.Number >= 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if alpha = argsList.Front().Next().Value.(formulaArg).ToNumber(); alpha.Type != ArgNumber {
		return alpha
	}
	if beta = argsList.Back().Value.(formulaArg).ToNumber(); beta.Type != ArgNumber {
		return beta
	}
	if alpha.Number <= 0 || beta.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(gammainv(probability.Number, alpha.Number, beta.Number))
}

// GAMMALN function returns the natural logarithm of the Gamma Function, Î“
// (n). The syntax of the function is:
//
//	GAMMALN(x)
func (fn *formulaFuncs) GAMMALN(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "GAMMALN requires 1 numeric argument")
	}
	x := argsList.Front().Value.(formulaArg).ToNumber()
	if x.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, "GAMMALN requires 1 numeric argument")
	}
	if x.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	return newNumberFormulaArg(math.Log(math.Gamma(x.Number)))
}

// GAMMALNdotPRECISE function returns the natural logarithm of the Gamma
// Function, Î“(n). The syntax of the function is:
//
//	GAMMALN.PRECISE(x)
func (fn *formulaFuncs) GAMMALNdotPRECISE(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "GAMMALN.PRECISE requires 1 numeric argument")
	}
	x := argsList.Front().Value.(formulaArg).ToNumber()
	if x.Type != ArgNumber {
		return x
	}
	if x.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(getLogGamma(x.Number))
}

// GAUSS function returns the probability that a member of a standard normal
// population will fall between the mean and a specified number of standard
// deviations from the mean. The syntax of the function is:
//
//	GAUSS(z)
func (fn *formulaFuncs) GAUSS(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "GAUSS requires 1 numeric argument")
	}
	args := list.New().Init()
	args.PushBack(argsList.Front().Value.(formulaArg))
	args.PushBack(formulaArg{Type: ArgNumber, Number: 0})
	args.PushBack(formulaArg{Type: ArgNumber, Number: 1})
	args.PushBack(newBoolFormulaArg(true))
	normdist := fn.NORMDIST(args)
	if normdist.Type != ArgNumber {
		return normdist
	}
	return newNumberFormulaArg(normdist.Number - 0.5)
}

// GEOMEAN function calculates the geometric mean of a supplied set of values.
// The syntax of the function is:
//
//	GEOMEAN(number1,[number2],...)
func (fn *formulaFuncs) GEOMEAN(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "GEOMEAN requires at least 1 numeric argument")
	}
	product := fn.PRODUCT(argsList)
	if product.Type != ArgNumber {
		return product
	}
	count := fn.COUNT(argsList)
	minVal := fn.MIN(argsList)
	if product.Number > 0 && minVal.Number > 0 {
		return newNumberFormulaArg(math.Pow(product.Number, 1/count.Number))
	}
	return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
}

// getNewMatrix create matrix by given columns and rows.
func getNewMatrix(c, r int) (matrix [][]float64) {
	for i := 0; i < c; i++ {
		for j := 0; j < r; j++ {
			for x := len(matrix); x <= i; x++ {
				matrix = append(matrix, []float64{})
			}
			for y := len(matrix[i]); y <= j; y++ {
				matrix[i] = append(matrix[i], 0)
			}
			matrix[i][j] = 0
		}
	}
	return
}

// approxSub subtract two values, if signs are identical and the values are
// equal, will be returns 0 instead of calculating the subtraction.
func approxSub(a, b float64) float64 {
	if ((a < 0 && b < 0) || (a > 0 && b > 0)) && math.Abs(a-b) < 2.22045e-016 {
		return 0
	}
	return a - b
}

// matrixClone return a copy of all elements of the original matrix.
func matrixClone(matrix [][]float64) (cloneMatrix [][]float64) {
	for i := 0; i < len(matrix); i++ {
		for j := 0; j < len(matrix[i]); j++ {
			for x := len(cloneMatrix); x <= i; x++ {
				cloneMatrix = append(cloneMatrix, []float64{})
			}
			for k := len(cloneMatrix[i]); k <= j; k++ {
				cloneMatrix[i] = append(cloneMatrix[i], 0)
			}
			cloneMatrix[i][j] = matrix[i][j]
		}
	}
	return
}

// trendGrowthMatrixInfo defined matrix checking result.
type trendGrowthMatrixInfo struct {
	trendType, nCX, nCY, nRX, nRY, M, N int
	mtxX, mtxY                          [][]float64
}

// prepareTrendGrowthMtxX is a part of implementation of the trend growth prepare.
func prepareTrendGrowthMtxX(mtxX [][]float64) [][]float64 {
	var mtx [][]float64
	for i := 0; i < len(mtxX); i++ {
		for j := 0; j < len(mtxX[i]); j++ {
			if mtxX[i][j] == 0 {
				return nil
			}
			for x := len(mtx); x <= j; x++ {
				mtx = append(mtx, []float64{})
			}
			for y := len(mtx[j]); y <= i; y++ {
				mtx[j] = append(mtx[j], 0)
			}
			mtx[j][i] = mtxX[i][j]
		}
	}
	return mtx
}

// prepareTrendGrowthMtxY is a part of implementation of the trend growth prepare.
func prepareTrendGrowthMtxY(bLOG bool, mtxY [][]float64) [][]float64 {
	var mtx [][]float64
	for i := 0; i < len(mtxY); i++ {
		for j := 0; j < len(mtxY[i]); j++ {
			if mtxY[i][j] == 0 {
				return nil
			}
			for x := len(mtx); x <= j; x++ {
				mtx = append(mtx, []float64{})
			}
			for y := len(mtx[j]); y <= i; y++ {
				mtx[j] = append(mtx[j], 0)
			}
			mtx[j][i] = mtxY[i][j]
		}
	}
	if bLOG {
		var pNewY [][]float64
		for i := 0; i < len(mtxY); i++ {
			for j := 0; j < len(mtxY[i]); j++ {
				fVal := mtxY[i][j]
				if fVal <= 0 {
					return nil
				}
				for x := len(pNewY); x <= j; x++ {
					pNewY = append(pNewY, []float64{})
				}
				for y := len(pNewY[j]); y <= i; y++ {
					pNewY[j] = append(pNewY[j], 0)
				}
				pNewY[j][i] = math.Log(fVal)
			}
		}
		mtx = pNewY
	}
	return mtx
}

// prepareTrendGrowth check and return the result.
func prepareTrendGrowth(bLOG bool, mtxX, mtxY [][]float64) (*trendGrowthMatrixInfo, formulaArg) {
	var nCX, nRX, M, N, trendType int
	nRY, nCY := len(mtxY), len(mtxY[0])
	cntY := nCY * nRY
	newY := prepareTrendGrowthMtxY(bLOG, mtxY)
	if newY == nil {
		return nil, newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	var newX [][]float64
	if len(mtxX) != 0 {
		nRX, nCX = len(mtxX), len(mtxX[0])
		if newX = prepareTrendGrowthMtxX(mtxX); newX == nil {
			return nil, newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
		if nCX == nCY && nRX == nRY {
			trendType, M, N = 1, 1, cntY // simple regression
		} else if nCY != 1 && nRY != 1 {
			return nil, newErrorFormulaArg(formulaErrorREF, formulaErrorREF)
		} else if nCY == 1 {
			if nRX != nRY {
				return nil, newErrorFormulaArg(formulaErrorREF, formulaErrorREF)
			}
			trendType, M, N = 2, nCX, nRY
		} else if nCX != nCY {
			return nil, newErrorFormulaArg(formulaErrorREF, formulaErrorREF)
		} else {
			trendType, M, N = 3, nRX, nCY
		}
	} else {
		newX = getNewMatrix(nCY, nRY)
		nCX, nRX = nCY, nRY
		num := 1.0
		for i := 0; i < nRY; i++ {
			for j := 0; j < nCY; j++ {
				newX[j][i] = num
				num++
			}
		}
		trendType, M, N = 1, 1, cntY
	}
	return &trendGrowthMatrixInfo{
		trendType: trendType,
		nCX:       nCX,
		nCY:       nCY,
		nRX:       nRX,
		nRY:       nRY,
		M:         M,
		N:         N,
		mtxX:      newX,
		mtxY:      newY,
	}, newEmptyFormulaArg()
}

// calcPosition calculate position for matrix by given index.
func calcPosition(mtx [][]float64, idx int) (row, col int) {
	rowSize := len(mtx[0])
	col = idx
	if rowSize > 1 {
		col = idx / rowSize
	}
	row = idx - col*rowSize
	return
}

// getDouble returns float64 data type value in the matrix by given index.
func getDouble(mtx [][]float64, idx int) float64 {
	row, col := calcPosition(mtx, idx)
	return mtx[col][row]
}

// putDouble set a float64 data type value in the matrix by given index.
func putDouble(mtx [][]float64, idx int, val float64) {
	row, col := calcPosition(mtx, idx)
	mtx[col][row] = val
}

// calcMeanOverAll returns mean of the given matrix by over all element.
func calcMeanOverAll(mtx [][]float64, n int) float64 {
	var sum float64
	for i := 0; i < len(mtx); i++ {
		for j := 0; j < len(mtx[i]); j++ {
			sum += mtx[i][j]
		}
	}
	return sum / float64(n)
}

// calcSumProduct returns uses the matrices as vectors of length M over all
// element.
func calcSumProduct(mtxA, mtxB [][]float64, m int) float64 {
	sum := 0.0
	for i := 0; i < m; i++ {
		sum += getDouble(mtxA, i) * getDouble(mtxB, i)
	}
	return sum
}

// calcColumnMeans calculates means of the columns of matrix.
func calcColumnMeans(mtxX, mtxRes [][]float64, c, r int) {
	for i := 0; i < c; i++ {
		var sum float64
		for k := 0; k < r; k++ {
			sum += mtxX[i][k]
		}
		putDouble(mtxRes, i, sum/float64(r))
	}
}

// calcColumnsDelta calculates subtract of the columns of matrix.
func calcColumnsDelta(mtx, columnMeans [][]float64, c, r int) {
	for i := 0; i < c; i++ {
		for k := 0; k < r; k++ {
			mtx[i][k] = approxSub(mtx[i][k], getDouble(columnMeans, i))
		}
	}
}

// calcSign returns sign by given value, no mathematical signum, but used to
// switch between adding and subtracting.
func calcSign(val float64) float64 {
	if val > 0 {
		return 1
	}
	return -1
}

// calcColsMaximumNorm is a special version for use within QR
// decomposition. Maximum norm of column index c starting in row index r;
// matrix A has count n rows.
func calcColsMaximumNorm(mtxA [][]float64, c, r, n int) float64 {
	var norm float64
	for row := r; row < n; row++ {
		if norm < math.Abs(mtxA[c][row]) {
			norm = math.Abs(mtxA[c][row])
		}
	}
	return norm
}

// calcFastMult returns multiply n x m matrix A with m x l matrix B to n x l matrix R.
func calcFastMult(mtxA, mtxB, mtxR [][]float64, n, m, l int) {
	var sum float64
	for row := 0; row < n; row++ {
		for col := 0; col < l; col++ {
			sum = 0.0
			for k := 0; k < m; k++ {
				sum += mtxA[k][row] * mtxB[col][k]
			}
			mtxR[col][row] = sum
		}
	}
}

// calcRowsEuclideanNorm is a special version for use within QR
// decomposition. Euclidean norm of column index c starting in row index r;
// matrix a has count n rows.
func calcRowsEuclideanNorm(mtxA [][]float64, c, r, n int) float64 {
	var norm float64
	for row := r; row < n; row++ {
		norm += mtxA[c][row] * mtxA[c][row]
	}
	return math.Sqrt(norm)
}

// calcRowsSumProduct is a special version for use within QR decomposition.
// <A(a);B(b)> starting in row index r;
// a and b are indices of columns, matrices A and B have count n rows.
func calcRowsSumProduct(mtxA [][]float64, a int, mtxB [][]float64, b, r, n int) float64 {
	var result float64
	for row := r; row < n; row++ {
		result += mtxA[a][row] * mtxB[b][row]
	}
	return result
}

// calcSolveWithUpperRightTriangle solve for X in R*X=S using back substitution.
func calcSolveWithUpperRightTriangle(mtxA [][]float64, vecR []float64, mtxS [][]float64, k int, bIsTransposed bool) {
	var row int
	for rowp1 := k; rowp1 > 0; rowp1-- {
		row = rowp1 - 1
		sum := getDouble(mtxS, row)
		for col := rowp1; col < k; col++ {
			if bIsTransposed {
				sum -= mtxA[row][col] * getDouble(mtxS, col)
			} else {
				sum -= mtxA[col][row] * getDouble(mtxS, col)
			}
		}
		putDouble(mtxS, row, sum/vecR[row])
	}
}

// calcRowQRDecomposition calculates a QR decomposition with Householder
// reflection.
func calcRowQRDecomposition(mtxA [][]float64, vecR []float64, k, n int) bool {
	for col := 0; col < k; col++ {
		scale := calcColsMaximumNorm(mtxA, col, col, n)
		if scale == 0 {
			return false
		}
		for row := col; row < n; row++ {
			mtxA[col][row] = mtxA[col][row] / scale
		}
		euclid := calcRowsEuclideanNorm(mtxA, col, col, n)
		factor := 1.0 / euclid / (euclid + math.Abs(mtxA[col][col]))
		signum := calcSign(mtxA[col][col])
		mtxA[col][col] = mtxA[col][col] + signum*euclid
		vecR[col] = -signum * scale * euclid
		// apply Householder transformation to A
		for c := col + 1; c < k; c++ {
			sum := calcRowsSumProduct(mtxA, col, mtxA, c, col, n)
			for row := col; row < n; row++ {
				mtxA[c][row] = mtxA[c][row] - sum*factor*mtxA[col][row]
			}
		}
	}
	return true
}

// calcApplyColsHouseholderTransformation transposed matrices A and Y.
func calcApplyColsHouseholderTransformation(mtxA [][]float64, r int, mtxY [][]float64, n int) {
	denominator := calcColsSumProduct(mtxA, r, mtxA, r, r, n)
	numerator := calcColsSumProduct(mtxA, r, mtxY, 0, r, n)
	factor := 2 * (numerator / denominator)
	for col := r; col < n; col++ {
		putDouble(mtxY, col, getDouble(mtxY, col)-factor*mtxA[col][r])
	}
}

// calcRowMeans calculates means of the rows of matrix.
func calcRowMeans(mtxX, mtxRes [][]float64, c, r int) {
	for k := 0; k < r; k++ {
		var fSum float64
		for i := 0; i < c; i++ {
			fSum += mtxX[i][k]
		}
		mtxRes[k][0] = fSum / float64(c)
	}
}

// calcRowsDelta calculates subtract of the rows of matrix.
func calcRowsDelta(mtx, rowMeans [][]float64, c, r int) {
	for k := 0; k < r; k++ {
		for i := 0; i < c; i++ {
			mtx[i][k] = approxSub(mtx[i][k], rowMeans[k][0])
		}
	}
}

// calcColumnMaximumNorm returns maximum norm of row index R starting in col
// index C; matrix A has count N columns.
func calcColumnMaximumNorm(mtxA [][]float64, r, c, n int) float64 {
	var norm float64
	for col := c; col < n; col++ {
		if norm < math.Abs(mtxA[col][r]) {
			norm = math.Abs(mtxA[col][r])
		}
	}
	return norm
}

// calcColsEuclideanNorm returns euclidean norm of row index R starting in
// column index C; matrix A has count N columns.
func calcColsEuclideanNorm(mtxA [][]float64, r, c, n int) float64 {
	var norm float64
	for col := c; col < n; col++ {
		norm += (mtxA[col][r]) * (mtxA[col][r])
	}
	return math.Sqrt(norm)
}

// calcColsSumProduct returns sum product for given matrix.
func calcColsSumProduct(mtxA [][]float64, a int, mtxB [][]float64, b, c, n int) float64 {
	var result float64
	for col := c; col < n; col++ {
		result += mtxA[col][a] * mtxB[col][b]
	}
	return result
}

// calcColQRDecomposition same with transposed matrix A, N is count of
// columns, k count of rows.
func calcColQRDecomposition(mtxA [][]float64, vecR []float64, k, n int) bool {
	var sum float64
	for row := 0; row < k; row++ {
		// calculate vector u of the householder transformation
		scale := calcColumnMaximumNorm(mtxA, row, row, n)
		if scale == 0 {
			return false
		}
		for col := row; col < n; col++ {
			mtxA[col][row] = mtxA[col][row] / scale
		}
		euclid := calcColsEuclideanNorm(mtxA, row, row, n)
		factor := 1 / euclid / (euclid + math.Abs(mtxA[row][row]))
		signum := calcSign(mtxA[row][row])
		mtxA[row][row] = mtxA[row][row] + signum*euclid
		vecR[row] = -signum * scale * euclid
		// apply Householder transformation to A
		for r := row + 1; r < k; r++ {
			sum = calcColsSumProduct(mtxA, row, mtxA, r, row, n)
			for col := row; col < n; col++ {
				mtxA[col][r] = mtxA[col][r] - sum*factor*mtxA[col][row]
			}
		}
	}
	return true
}

// calcApplyRowsHouseholderTransformation applies a Householder transformation to a
// column vector Y with is given as Nx1 Matrix. The vector u, from which the
// Householder transformation is built, is the column part in matrix A, with
// column index c, starting with row index c. A is the result of the QR
// decomposition as obtained from calcRowQRDecomposition.
func calcApplyRowsHouseholderTransformation(mtxA [][]float64, c int, mtxY [][]float64, n int) {
	denominator := calcRowsSumProduct(mtxA, c, mtxA, c, c, n)
	numerator := calcRowsSumProduct(mtxA, c, mtxY, 0, c, n)
	factor := 2 * (numerator / denominator)
	for row := c; row < n; row++ {
		putDouble(mtxY, row, getDouble(mtxY, row)-factor*mtxA[c][row])
	}
}

// calcTrendGrowthSimpleRegression calculate simple regression for the calcTrendGrowth.
func calcTrendGrowthSimpleRegression(bConstant, bGrowth bool, mtxY, mtxX, newX, mtxRes [][]float64, meanY float64, N int) {
	var meanX float64
	if bConstant {
		meanX = calcMeanOverAll(mtxX, N)
		for i := 0; i < len(mtxX); i++ {
			for j := 0; j < len(mtxX[i]); j++ {
				mtxX[i][j] = approxSub(mtxX[i][j], meanX)
			}
		}
	}
	sumXY := calcSumProduct(mtxX, mtxY, N)
	sumX2 := calcSumProduct(mtxX, mtxX, N)
	slope := sumXY / sumX2
	var help float64
	var intercept float64
	if bConstant {
		intercept = meanY - slope*meanX
		for i := 0; i < len(mtxRes); i++ {
			for j := 0; j < len(mtxRes[i]); j++ {
				help = newX[i][j]*slope + intercept
				if bGrowth {
					mtxRes[i][j] = math.Exp(help)
				} else {
					mtxRes[i][j] = help
				}
			}
		}
	} else {
		for i := 0; i < len(mtxRes); i++ {
			for j := 0; j < len(mtxRes[i]); j++ {
				help = newX[i][j] * slope
				if bGrowth {
					mtxRes[i][j] = math.Exp(help)
				} else {
					mtxRes[i][j] = help
				}
			}
		}
	}
}

// calcTrendGrowthMultipleRegressionPart1 calculate multiple regression for the
// calcTrendGrowth.
func calcTrendGrowthMultipleRegressionPart1(bConstant, bGrowth bool, mtxY, mtxX, newX, mtxRes [][]float64, meanY float64, RXN, K, N int) {
	vecR := make([]float64, N)   // for QR decomposition
	means := getNewMatrix(K, 1)  // mean of each column
	slopes := getNewMatrix(1, K) // from b1 to bK
	if len(means) == 0 || len(slopes) == 0 {
		return
	}
	if bConstant {
		calcColumnMeans(mtxX, means, K, N)
		calcColumnsDelta(mtxX, means, K, N)
	}
	if !calcRowQRDecomposition(mtxX, vecR, K, N) {
		return
	}
	// Later on we will divide by elements of vecR, so make sure that they aren't zero.
	bIsSingular := false
	for row := 0; row < K && !bIsSingular; row++ {
		bIsSingular = bIsSingular || vecR[row] == 0
	}
	if bIsSingular {
		return
	}
	for col := 0; col < K; col++ {
		calcApplyRowsHouseholderTransformation(mtxX, col, mtxY, N)
	}
	for col := 0; col < K; col++ {
		putDouble(slopes, col, getDouble(mtxY, col))
	}
	calcSolveWithUpperRightTriangle(mtxX, vecR, slopes, K, false)
	// Fill result matrix
	calcFastMult(newX, slopes, mtxRes, RXN, K, 1)
	if bConstant {
		intercept := meanY - calcSumProduct(means, slopes, K)
		for row := 0; row < RXN; row++ {
			mtxRes[0][row] = mtxRes[0][row] + intercept
		}
	}
	if bGrowth {
		for i := 0; i < RXN; i++ {
			putDouble(mtxRes, i, math.Exp(getDouble(mtxRes, i)))
		}
	}
}

// calcTrendGrowthMultipleRegressionPart2 calculate multiple regression for the
// calcTrendGrowth.
func calcTrendGrowthMultipleRegressionPart2(bConstant, bGrowth bool, mtxY, mtxX, newX, mtxRes [][]float64, meanY float64, nCXN, K, N int) {
	vecR := make([]float64, N)   // for QR decomposition
	means := getNewMatrix(K, 1)  // mean of each row
	slopes := getNewMatrix(K, 1) // row from b1 to bK
	if len(means) == 0 || len(slopes) == 0 {
		return
	}
	if bConstant {
		calcRowMeans(mtxX, means, N, K)
		calcRowsDelta(mtxX, means, N, K)
	}
	if !calcColQRDecomposition(mtxX, vecR, K, N) {
		return
	}
	// later on we will divide by elements of vecR, so make sure that they aren't zero
	bIsSingular := false
	for row := 0; row < K && !bIsSingular; row++ {
		bIsSingular = bIsSingular || vecR[row] == 0
	}
	if bIsSingular {
		return
	}
	for row := 0; row < K; row++ {
		calcApplyColsHouseholderTransformation(mtxX, row, mtxY, N)
	}
	for col := 0; col < K; col++ {
		putDouble(slopes, col, getDouble(mtxY, col))
	}
	calcSolveWithUpperRightTriangle(mtxX, vecR, slopes, K, true)
	// fill result matrix
	calcFastMult(slopes, newX, mtxRes, 1, K, nCXN)
	if bConstant {
		fIntercept := meanY - calcSumProduct(means, slopes, K)
		for col := 0; col < nCXN; col++ {
			mtxRes[col][0] = mtxRes[col][0] + fIntercept
		}
	}
	if bGrowth {
		for i := 0; i < nCXN; i++ {
			putDouble(mtxRes, i, math.Exp(getDouble(mtxRes, i)))
		}
	}
}

// calcTrendGrowthRegression is a part of implementation of the calcTrendGrowth.
func calcTrendGrowthRegression(bConstant, bGrowth bool, trendType, nCXN, nRXN, K, N int, mtxY, mtxX, newX, mtxRes [][]float64) {
	if len(mtxRes) == 0 {
		return
	}
	var meanY float64
	if bConstant {
		copyX, copyY := matrixClone(mtxX), matrixClone(mtxY)
		mtxX, mtxY = copyX, copyY
		meanY = calcMeanOverAll(mtxY, N)
		for i := 0; i < len(mtxY); i++ {
			for j := 0; j < len(mtxY[i]); j++ {
				mtxY[i][j] = approxSub(mtxY[i][j], meanY)
			}
		}
	}
	switch trendType {
	case 1:
		calcTrendGrowthSimpleRegression(bConstant, bGrowth, mtxY, mtxX, newX, mtxRes, meanY, N)
	case 2:
		calcTrendGrowthMultipleRegressionPart1(bConstant, bGrowth, mtxY, mtxX, newX, mtxRes, meanY, nRXN, K, N)
	default:
		calcTrendGrowthMultipleRegressionPart2(bConstant, bGrowth, mtxY, mtxX, newX, mtxRes, meanY, nCXN, K, N)
	}
}

// calcTrendGrowth returns values along a predicted exponential trend.
func calcTrendGrowth(mtxY, mtxX, newX [][]float64, bConstant, bGrowth bool) ([][]float64, formulaArg) {
	getMatrixParams, errArg := prepareTrendGrowth(bGrowth, mtxX, mtxY)
	if errArg.Type != ArgEmpty {
		return nil, errArg
	}
	trendType := getMatrixParams.trendType
	nCX := getMatrixParams.nCX
	nRX := getMatrixParams.nRX
	K := getMatrixParams.M
	N := getMatrixParams.N
	mtxX = getMatrixParams.mtxX
	mtxY = getMatrixParams.mtxY
	// checking if data samples are enough
	if (bConstant && (N < K+1)) || (!bConstant && (N < K)) || (N < 1) || (K < 1) {
		return nil, errArg
	}
	// set the default newX if necessary
	nCXN, nRXN := nCX, nRX
	if len(newX) == 0 {
		newX = matrixClone(mtxX) // mtxX will be changed to X-meanX
	} else {
		nRXN, nCXN = len(newX[0]), len(newX)
		if (trendType == 2 && K != nCXN) || (trendType == 3 && K != nRXN) {
			return nil, errArg
		}
	}
	var mtxRes [][]float64
	switch trendType {
	case 1:
		mtxRes = getNewMatrix(nCXN, nRXN)
	case 2:
		mtxRes = getNewMatrix(1, nRXN)
	default:
		mtxRes = getNewMatrix(nCXN, 1)
	}
	calcTrendGrowthRegression(bConstant, bGrowth, trendType, nCXN, nRXN, K, N, mtxY, mtxX, newX, mtxRes)
	return mtxRes, errArg
}

// trendGrowth is an implementation of the formula functions GROWTH and TREND.
func (fn *formulaFuncs) trendGrowth(name string, argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires at least 1 argument", name))
	}
	if argsList.Len() > 4 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s allows at most 4 arguments", name))
	}
	var knowY, knowX, newX [][]float64
	var errArg formulaArg
	constArg := newBoolFormulaArg(true)
	knowY, errArg = newNumberMatrix(argsList.Front().Value.(formulaArg), false)
	if errArg.Type == ArgError {
		return errArg
	}
	if argsList.Len() > 1 {
		knowX, errArg = newNumberMatrix(argsList.Front().Next().Value.(formulaArg), false)
		if errArg.Type == ArgError {
			return errArg
		}
	}
	if argsList.Len() > 2 {
		newX, errArg = newNumberMatrix(argsList.Front().Next().Next().Value.(formulaArg), false)
		if errArg.Type == ArgError {
			return errArg
		}
	}
	if argsList.Len() > 3 {
		if constArg = argsList.Back().Value.(formulaArg).ToBool(); constArg.Type != ArgNumber {
			return constArg
		}
	}
	var mtxNewX [][]float64
	for i := 0; i < len(newX); i++ {
		for j := 0; j < len(newX[i]); j++ {
			for x := len(mtxNewX); x <= j; x++ {
				mtxNewX = append(mtxNewX, []float64{})
			}
			for k := len(mtxNewX[j]); k <= i; k++ {
				mtxNewX[j] = append(mtxNewX[j], 0)
			}
			mtxNewX[j][i] = newX[i][j]
		}
	}
	mtx, errArg := calcTrendGrowth(knowY, knowX, mtxNewX, constArg.Number == 1, name == "GROWTH")
	if errArg.Type != ArgEmpty {
		return errArg
	}
	return newMatrixFormulaArg(newFormulaArgMatrix(mtx))
}

// GROWTH function calculates the exponential growth curve through a given set
// of y-values and (optionally), one or more sets of x-values. The function
// then extends the curve to calculate additional y-values for a further
// supplied set of new x-values. The syntax of the function is:
//
//	GROWTH(known_y's,[known_x's],[new_x's],[const])
func (fn *formulaFuncs) GROWTH(argsList *list.List) formulaArg {
	return fn.trendGrowth("GROWTH", argsList)
}

// HARMEAN function calculates the harmonic mean of a supplied set of values.
// The syntax of the function is:
//
//	HARMEAN(number1,[number2],...)
func (fn *formulaFuncs) HARMEAN(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "HARMEAN requires at least 1 argument")
	}
	if minVal := fn.MIN(argsList); minVal.Number < 0 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	number, val, cnt := 0.0, 0.0, 0.0
	for token := argsList.Front(); token != nil; token = token.Next() {
		arg := token.Value.(formulaArg)
		switch arg.Type {
		case ArgString:
			num := arg.ToNumber()
			if num.Type != ArgNumber {
				continue
			}
			number = num.Number
		case ArgNumber:
			number = arg.Number
		}
		if number <= 0 {
			return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
		}
		val += 1 / number
		cnt++
	}
	return newNumberFormulaArg(1 / (val / cnt))
}

// checkHYPGEOMDISTArgs checking arguments for the formula function HYPGEOMDIST
// and HYPGEOM.DIST.
func checkHYPGEOMDISTArgs(sampleS, numberSample, populationS, numberPop formulaArg) bool {
	return sampleS.Number < 0 ||
		sampleS.Number > math.Min(numberSample.Number, populationS.Number) ||
		sampleS.Number < math.Max(0, numberSample.Number-numberPop.Number+populationS.Number) ||
		numberSample.Number <= 0 ||
		numberSample.Number > numberPop.Number ||
		populationS.Number <= 0 ||
		populationS.Number > numberPop.Number ||
		numberPop.Number <= 0
}

// prepareHYPGEOMDISTArgs prepare arguments for the formula function
// HYPGEOMDIST and HYPGEOM.DIST.
func (fn *formulaFuncs) prepareHYPGEOMDISTArgs(name string, argsList *list.List) formulaArg {
	if name == "HYPGEOMDIST" && argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "HYPGEOMDIST requires 4 numeric arguments")
	}
	if name == "HYPGEOM.DIST" && argsList.Len() != 5 {
		return newErrorFormulaArg(formulaErrorVALUE, "HYPGEOM.DIST requires 5 arguments")
	}
	var sampleS, numberSample, populationS, numberPop, cumulative formulaArg
	if sampleS = argsList.Front().Value.(formulaArg).ToNumber(); sampleS.Type != ArgNumber {
		return sampleS
	}
	if numberSample = argsList.Front().Next().Value.(formulaArg).ToNumber(); numberSample.Type != ArgNumber {
		return numberSample
	}
	if populationS = argsList.Front().Next().Next().Value.(formulaArg).ToNumber(); populationS.Type != ArgNumber {
		return populationS
	}
	if numberPop = argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber(); numberPop.Type != ArgNumber {
		return numberPop
	}
	if checkHYPGEOMDISTArgs(sampleS, numberSample, populationS, numberPop) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if name == "HYPGEOM.DIST" {
		if cumulative = argsList.Back().Value.(formulaArg).ToBool(); cumulative.Type != ArgNumber {
			return cumulative
		}
	}
	return newListFormulaArg([]formulaArg{sampleS, numberSample, populationS, numberPop, cumulative})
}

// HYPGEOMdotDIST function returns the value of the hypergeometric distribution
// for a specified number of successes from a population sample. The function
// can calculate the cumulative distribution or the probability density
// function. The syntax of the function is:
//
//	HYPGEOM.DIST(sample_s,number_sample,population_s,number_pop,cumulative)
func (fn *formulaFuncs) HYPGEOMdotDIST(argsList *list.List) formulaArg {
	args := fn.prepareHYPGEOMDISTArgs("HYPGEOM.DIST", argsList)
	if args.Type != ArgList {
		return args
	}
	sampleS, numberSample, populationS, numberPop, cumulative := args.List[0], args.List[1], args.List[2], args.List[3], args.List[4]
	if cumulative.Number == 1 {
		var res float64
		for i := 0; i <= int(sampleS.Number); i++ {
			res += binomCoeff(populationS.Number, float64(i)) *
				binomCoeff(numberPop.Number-populationS.Number, numberSample.Number-float64(i)) /
				binomCoeff(numberPop.Number, numberSample.Number)
		}
		return newNumberFormulaArg(res)
	}
	return newNumberFormulaArg(binomCoeff(populationS.Number, sampleS.Number) *
		binomCoeff(numberPop.Number-populationS.Number, numberSample.Number-sampleS.Number) /
		binomCoeff(numberPop.Number, numberSample.Number))
}

// HYPGEOMDIST function returns the value of the hypergeometric distribution
// for a given number of successes from a sample of a population. The syntax
// of the function is:
//
//	HYPGEOMDIST(sample_s,number_sample,population_s,number_pop)
func (fn *formulaFuncs) HYPGEOMDIST(argsList *list.List) formulaArg {
	args := fn.prepareHYPGEOMDISTArgs("HYPGEOMDIST", argsList)
	if args.Type != ArgList {
		return args
	}
	sampleS, numberSample, populationS, numberPop := args.List[0], args.List[1], args.List[2], args.List[3]
	return newNumberFormulaArg(binomCoeff(populationS.Number, sampleS.Number) *
		binomCoeff(numberPop.Number-populationS.Number, numberSample.Number-sampleS.Number) /
		binomCoeff(numberPop.Number, numberSample.Number))
}

// INTERCEPT function calculates the intercept (the value at the intersection
// of the y axis) of the linear regression line through a supplied set of x-
// and y- values. The syntax of the function is:
//
//	INTERCEPT(known_y's,known_x's)
func (fn *formulaFuncs) INTERCEPT(argsList *list.List) formulaArg {
	return fn.pearsonProduct("INTERCEPT", 2, argsList)
}

// KURT function calculates the kurtosis of a supplied set of values. The
// syntax of the function is:
//
//	KURT(number1,[number2],...)
func (fn *formulaFuncs) KURT(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "KURT requires at least 1 argument")
	}
	mean, stdev := fn.AVERAGE(argsList), fn.STDEV(argsList)
	if stdev.Number > 0 {
		count, summer := 0.0, 0.0
		for arg := argsList.Front(); arg != nil; arg = arg.Next() {
			token := arg.Value.(formulaArg)
			switch token.Type {
			case ArgString, ArgNumber:
				num := token.ToNumber()
				if num.Type == ArgError {
					continue
				}
				summer += math.Pow((num.Number-mean.Number)/stdev.Number, 4)
				count++
			case ArgList, ArgMatrix:
				for _, row := range token.ToList() {
					if row.Type == ArgNumber || row.Type == ArgString {
						num := row.ToNumber()
						if num.Type == ArgError {
							continue
						}
						summer += math.Pow((num.Number-mean.Number)/stdev.Number, 4)
						count++
					}
				}
			}
		}
		if count > 3 {
			return newNumberFormulaArg(summer*(count*(count+1)/((count-1)*(count-2)*(count-3))) - (3 * math.Pow(count-1, 2) / ((count - 2) * (count - 3))))
		}
	}
	return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
}

// EXPONdotDIST function returns the value of the exponential distribution for
// a give value of x. The user can specify whether the probability density
// function or the cumulative distribution function is used. The syntax of the
// Expondist function is:
//
//	EXPON.DIST(x,lambda,cumulative)
func (fn *formulaFuncs) EXPONdotDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "EXPON.DIST requires 3 arguments")
	}
	return fn.EXPONDIST(argsList)
}

// EXPONDIST function returns the value of the exponential distribution for a
// give value of x. The user can specify whether the probability density
// function or the cumulative distribution function is used. The syntax of the
// Expondist function is:
//
//	EXPONDIST(x,lambda,cumulative)
func (fn *formulaFuncs) EXPONDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "EXPONDIST requires 3 arguments")
	}
	var x, lambda, cumulative formulaArg
	if x = argsList.Front().Value.(formulaArg).ToNumber(); x.Type != ArgNumber {
		return x
	}
	if lambda = argsList.Front().Next().Value.(formulaArg).ToNumber(); lambda.Type != ArgNumber {
		return lambda
	}
	if cumulative = argsList.Back().Value.(formulaArg).ToBool(); cumulative.Type == ArgError {
		return cumulative
	}
	if x.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if lambda.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if cumulative.Number == 1 {
		return newNumberFormulaArg(1 - math.Exp(-lambda.Number*x.Number))
	}
	return newNumberFormulaArg(lambda.Number * math.Exp(-lambda.Number*x.Number))
}

// FdotDIST function calculates the Probability Density Function or the
// Cumulative Distribution Function for the F Distribution. This function is
// frequently used to measure the degree of diversity between two data
// sets. The syntax of the function is:
//
//	F.DIST(x,deg_freedom1,deg_freedom2,cumulative)
func (fn *formulaFuncs) FdotDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "F.DIST requires 4 arguments")
	}
	var x, deg1, deg2, cumulative formulaArg
	if x = argsList.Front().Value.(formulaArg).ToNumber(); x.Type != ArgNumber {
		return x
	}
	if deg1 = argsList.Front().Next().Value.(formulaArg).ToNumber(); deg1.Type != ArgNumber {
		return deg1
	}
	if deg2 = argsList.Front().Next().Next().Value.(formulaArg).ToNumber(); deg2.Type != ArgNumber {
		return deg2
	}
	if cumulative = argsList.Back().Value.(formulaArg).ToBool(); cumulative.Type == ArgError {
		return cumulative
	}
	if x.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	maxDeg := math.Pow10(10)
	if deg1.Number < 1 || deg1.Number >= maxDeg {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if deg2.Number < 1 || deg2.Number >= maxDeg {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if cumulative.Number == 1 {
		return newNumberFormulaArg(1 - getBetaDist(deg2.Number/(deg2.Number+deg1.Number*x.Number), deg2.Number/2, deg1.Number/2))
	}
	return newNumberFormulaArg(math.Gamma((deg2.Number+deg1.Number)/2) / (math.Gamma(deg1.Number/2) * math.Gamma(deg2.Number/2)) * math.Pow(deg1.Number/deg2.Number, deg1.Number/2) * (math.Pow(x.Number, (deg1.Number-2)/2) / math.Pow(1+(deg1.Number/deg2.Number)*x.Number, (deg1.Number+deg2.Number)/2)))
}

// FDIST function calculates the (right-tailed) F Probability Distribution,
// which measures the degree of diversity between two data sets. The syntax
// of the function is:
//
//	FDIST(x,deg_freedom1,deg_freedom2)
func (fn *formulaFuncs) FDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "FDIST requires 3 arguments")
	}
	var x, deg1, deg2 formulaArg
	if x = argsList.Front().Value.(formulaArg).ToNumber(); x.Type != ArgNumber {
		return x
	}
	if deg1 = argsList.Front().Next().Value.(formulaArg).ToNumber(); deg1.Type != ArgNumber {
		return deg1
	}
	if deg2 = argsList.Back().Value.(formulaArg).ToNumber(); deg2.Type != ArgNumber {
		return deg2
	}
	if x.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	maxDeg := math.Pow10(10)
	if deg1.Number < 1 || deg1.Number >= maxDeg {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if deg2.Number < 1 || deg2.Number >= maxDeg {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	args := list.New()
	args.PushBack(newNumberFormulaArg(deg1.Number * x.Number / (deg1.Number*x.Number + deg2.Number)))
	args.PushBack(newNumberFormulaArg(0.5 * deg1.Number))
	args.PushBack(newNumberFormulaArg(0.5 * deg2.Number))
	args.PushBack(newNumberFormulaArg(0))
	args.PushBack(newNumberFormulaArg(1))
	return newNumberFormulaArg(1 - fn.BETADIST(args).Number)
}

// FdotDISTdotRT function calculates the (right-tailed) F Probability
// Distribution, which measures the degree of diversity between two data sets.
// The syntax of the function is:
//
//	F.DIST.RT(x,deg_freedom1,deg_freedom2)
func (fn *formulaFuncs) FdotDISTdotRT(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "F.DIST.RT requires 3 arguments")
	}
	return fn.FDIST(argsList)
}

// prepareFinvArgs checking and prepare arguments for the formula functions
// F.INV, F.INV.RT and FINV.
func (fn *formulaFuncs) prepareFinvArgs(name string, argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires 3 arguments", name))
	}
	var probability, d1, d2 formulaArg
	if probability = argsList.Front().Value.(formulaArg).ToNumber(); probability.Type != ArgNumber {
		return probability
	}
	if d1 = argsList.Front().Next().Value.(formulaArg).ToNumber(); d1.Type != ArgNumber {
		return d1
	}
	if d2 = argsList.Back().Value.(formulaArg).ToNumber(); d2.Type != ArgNumber {
		return d2
	}
	if probability.Number <= 0 || probability.Number > 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if d1.Number < 1 || d1.Number >= math.Pow10(10) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if d2.Number < 1 || d2.Number >= math.Pow10(10) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newListFormulaArg([]formulaArg{probability, d1, d2})
}

// FdotINV function calculates the inverse of the Cumulative F Distribution
// for a supplied probability. The syntax of the F.Inv function is:
//
//	F.INV(probability,deg_freedom1,deg_freedom2)
func (fn *formulaFuncs) FdotINV(argsList *list.List) formulaArg {
	args := fn.prepareFinvArgs("F.INV", argsList)
	if args.Type != ArgList {
		return args
	}
	probability, d1, d2 := args.List[0], args.List[1], args.List[2]
	return newNumberFormulaArg((1/calcBetainv(1-probability.Number, d2.Number/2, d1.Number/2, 0, 1) - 1) * (d2.Number / d1.Number))
}

// FdotINVdotRT function calculates the inverse of the (right-tailed) F
// Probability Distribution for a supplied probability. The syntax of the
// function is:
//
//	F.INV.RT(probability,deg_freedom1,deg_freedom2)
func (fn *formulaFuncs) FdotINVdotRT(argsList *list.List) formulaArg {
	args := fn.prepareFinvArgs("F.INV.RT", argsList)
	if args.Type != ArgList {
		return args
	}
	probability, d1, d2 := args.List[0], args.List[1], args.List[2]
	return newNumberFormulaArg((1/calcBetainv(1-(1-probability.Number), d2.Number/2, d1.Number/2, 0, 1) - 1) * (d2.Number / d1.Number))
}

// FINV function calculates the inverse of the (right-tailed) F Probability
// Distribution for a supplied probability. The syntax of the function is:
//
//	FINV(probability,deg_freedom1,deg_freedom2)
func (fn *formulaFuncs) FINV(argsList *list.List) formulaArg {
	args := fn.prepareFinvArgs("FINV", argsList)
	if args.Type != ArgList {
		return args
	}
	probability, d1, d2 := args.List[0], args.List[1], args.List[2]
	return newNumberFormulaArg((1/calcBetainv(1-(1-probability.Number), d2.Number/2, d1.Number/2, 0, 1) - 1) * (d2.Number / d1.Number))
}

// FdotTEST function returns the F-Test for two supplied arrays. I.e. the
// function returns the two-tailed probability that the variances in the two
// supplied arrays are not significantly different. The syntax of the Ftest
// function is:
//
//	F.TEST(array1,array2)
func (fn *formulaFuncs) FdotTEST(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "F.TEST requires 2 arguments")
	}
	array1 := argsList.Front().Value.(formulaArg)
	array2 := argsList.Back().Value.(formulaArg)
	left, right := array1.ToList(), array2.ToList()
	collectMatrix := func(args []formulaArg) (n, accu float64) {
		var p, sum float64
		for _, arg := range args {
			if num := arg.ToNumber(); num.Type == ArgNumber {
				x := num.Number - p
				y := x / (n + 1)
				p += y
				accu += n * x * y
				n++
				sum += num.Number
			}
		}
		return
	}
	nums, accu := collectMatrix(left)
	f3 := nums - 1
	if nums == 1 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	f1 := accu / (nums - 1)
	if f1 == 0 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	nums, accu = collectMatrix(right)
	f4 := nums - 1
	if nums == 1 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	f2 := accu / (nums - 1)
	if f2 == 0 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	args := list.New()
	args.PushBack(newNumberFormulaArg(f1 / f2))
	args.PushBack(newNumberFormulaArg(f3))
	args.PushBack(newNumberFormulaArg(f4))
	probability := (1 - fn.FDIST(args).Number) * 2
	if probability > 1 {
		probability = 2 - probability
	}
	return newNumberFormulaArg(probability)
}

// FTEST function returns the F-Test for two supplied arrays. I.e. the function
// returns the two-tailed probability that the variances in the two supplied
// arrays are not significantly different. The syntax of the Ftest function
// is:
//
//	FTEST(array1,array2)
func (fn *formulaFuncs) FTEST(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "FTEST requires 2 arguments")
	}
	return fn.FdotTEST(argsList)
}

// LOGINV function calculates the inverse of the Cumulative Log-Normal
// Distribution Function of x, for a supplied probability. The syntax of the
// function is:
//
//	LOGINV(probability,mean,standard_dev)
func (fn *formulaFuncs) LOGINV(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "LOGINV requires 3 arguments")
	}
	var probability, mean, stdDev formulaArg
	if probability = argsList.Front().Value.(formulaArg).ToNumber(); probability.Type != ArgNumber {
		return probability
	}
	if mean = argsList.Front().Next().Value.(formulaArg).ToNumber(); mean.Type != ArgNumber {
		return mean
	}
	if stdDev = argsList.Back().Value.(formulaArg).ToNumber(); stdDev.Type != ArgNumber {
		return stdDev
	}
	if probability.Number <= 0 || probability.Number >= 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if stdDev.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	args := list.New()
	args.PushBack(probability)
	args.PushBack(newNumberFormulaArg(0))
	args.PushBack(newNumberFormulaArg(1))
	norminv := fn.NORMINV(args)
	return newNumberFormulaArg(math.Exp(mean.Number + stdDev.Number*norminv.Number))
}

// LOGNORMdotINV function calculates the inverse of the Cumulative Log-Normal
// Distribution Function of x, for a supplied probability. The syntax of the
// function is:
//
//	LOGNORM.INV(probability,mean,standard_dev)
func (fn *formulaFuncs) LOGNORMdotINV(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "LOGNORM.INV requires 3 arguments")
	}
	return fn.LOGINV(argsList)
}

// LOGNORMdotDIST function calculates the Log-Normal Probability Density
// Function or the Cumulative Log-Normal Distribution Function for a supplied
// value of x. The syntax of the function is:
//
//	LOGNORM.DIST(x,mean,standard_dev,cumulative)
func (fn *formulaFuncs) LOGNORMdotDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "LOGNORM.DIST requires 4 arguments")
	}
	var x, mean, stdDev, cumulative formulaArg
	if x = argsList.Front().Value.(formulaArg).ToNumber(); x.Type != ArgNumber {
		return x
	}
	if mean = argsList.Front().Next().Value.(formulaArg).ToNumber(); mean.Type != ArgNumber {
		return mean
	}
	if stdDev = argsList.Back().Prev().Value.(formulaArg).ToNumber(); stdDev.Type != ArgNumber {
		return stdDev
	}
	if cumulative = argsList.Back().Value.(formulaArg).ToBool(); cumulative.Type == ArgError {
		return cumulative
	}
	if x.Number <= 0 || stdDev.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if cumulative.Number == 1 {
		args := list.New()
		args.PushBack(newNumberFormulaArg((math.Log(x.Number) - mean.Number) / stdDev.Number))
		args.PushBack(newNumberFormulaArg(0))
		args.PushBack(newNumberFormulaArg(1))
		args.PushBack(cumulative)
		return fn.NORMDIST(args)
	}
	return newNumberFormulaArg((1 / (math.Sqrt(2*math.Pi) * stdDev.Number * x.Number)) *
		math.Exp(0-(math.Pow(math.Log(x.Number)-mean.Number, 2)/(2*math.Pow(stdDev.Number, 2)))))
}

// LOGNORMDIST function calculates the Cumulative Log-Normal Distribution
// Function at a supplied value of x. The syntax of the function is:
//
//	LOGNORMDIST(x,mean,standard_dev)
func (fn *formulaFuncs) LOGNORMDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "LOGNORMDIST requires 3 arguments")
	}
	var x, mean, stdDev formulaArg
	if x = argsList.Front().Value.(formulaArg).ToNumber(); x.Type != ArgNumber {
		return x
	}
	if mean = argsList.Front().Next().Value.(formulaArg).ToNumber(); mean.Type != ArgNumber {
		return mean
	}
	if stdDev = argsList.Back().Value.(formulaArg).ToNumber(); stdDev.Type != ArgNumber {
		return stdDev
	}
	if x.Number <= 0 || stdDev.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	args := list.New()
	args.PushBack(newNumberFormulaArg((math.Log(x.Number) - mean.Number) / stdDev.Number))
	return fn.NORMSDIST(args)
}

// MODE function returns the statistical mode (the most frequently occurring
// value) of a list of supplied numbers. If there are 2 or more most
// frequently occurring values in the supplied data, the function returns the
// lowest of these values The syntax of the function is:
//
//	MODE(number1,[number2],...)
func (fn *formulaFuncs) MODE(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "MODE requires at least 1 argument")
	}
	var values []float64
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		cells := arg.Value.(formulaArg)
		if cells.Type != ArgMatrix && cells.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
		for _, cell := range cells.ToList() {
			if cell.Type == ArgNumber {
				values = append(values, cell.Number)
			}
		}
	}
	sort.Float64s(values)
	cnt := len(values)
	var count, modeCnt int
	var mode float64
	for i := 0; i < cnt; i++ {
		count = 0
		for j := 0; j < cnt; j++ {
			if j != i && values[j] == values[i] {
				count++
			}
		}
		if count > modeCnt {
			modeCnt = count
			mode = values[i]
		}
	}
	if modeCnt == 0 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	return newNumberFormulaArg(mode)
}

// MODEdotMULT function returns a vertical array of the statistical modes
// (the most frequently occurring values) within a list of supplied numbers.
// The syntax of the function is:
//
//	MODE.MULT(number1,[number2],...)
func (fn *formulaFuncs) MODEdotMULT(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "MODE.MULT requires at least 1 argument")
	}
	var values []float64
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		cells := arg.Value.(formulaArg)
		if cells.Type != ArgMatrix && cells.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
		for _, cell := range cells.ToList() {
			if cell.Type == ArgNumber {
				values = append(values, cell.Number)
			}
		}
	}
	sort.Float64s(values)
	cnt := len(values)
	var count, modeCnt int
	var mtx [][]formulaArg
	for i := 0; i < cnt; i++ {
		count = 0
		for j := i + 1; j < cnt; j++ {
			if values[i] == values[j] {
				count++
			}
		}
		if count > modeCnt {
			modeCnt = count
			mtx = [][]formulaArg{}
			mtx = append(mtx, []formulaArg{newNumberFormulaArg(values[i])})
		} else if count == modeCnt {
			mtx = append(mtx, []formulaArg{newNumberFormulaArg(values[i])})
		}
	}
	if modeCnt == 0 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	return newMatrixFormulaArg(mtx)
}

// MODEdotSNGL function returns the statistical mode (the most frequently
// occurring value) within a list of supplied numbers. If there are 2 or more
// most frequently occurring values in the supplied data, the function returns
// the lowest of these values. The syntax of the function is:
//
//	MODE.SNGL(number1,[number2],...)
func (fn *formulaFuncs) MODEdotSNGL(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "MODE.SNGL requires at least 1 argument")
	}
	return fn.MODE(argsList)
}

// NEGBINOMdotDIST function calculates the probability mass function or the
// cumulative distribution function for the Negative Binomial Distribution.
// This gives the probability that there will be a given number of failures
// before a required number of successes is achieved. The syntax of the
// function is:
//
//	NEGBINOM.DIST(number_f,number_s,probability_s,cumulative)
func (fn *formulaFuncs) NEGBINOMdotDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "NEGBINOM.DIST requires 4 arguments")
	}
	var f, s, probability, cumulative formulaArg
	if f = argsList.Front().Value.(formulaArg).ToNumber(); f.Type != ArgNumber {
		return f
	}
	if s = argsList.Front().Next().Value.(formulaArg).ToNumber(); s.Type != ArgNumber {
		return s
	}
	if probability = argsList.Front().Next().Next().Value.(formulaArg).ToNumber(); probability.Type != ArgNumber {
		return probability
	}
	if cumulative = argsList.Back().Value.(formulaArg).ToBool(); cumulative.Type != ArgNumber {
		return cumulative
	}
	if f.Number < 0 || s.Number < 1 || probability.Number < 0 || probability.Number > 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if cumulative.Number == 1 {
		return newNumberFormulaArg(1 - getBetaDist(1-probability.Number, f.Number+1, s.Number))
	}
	return newNumberFormulaArg(binomCoeff(f.Number+s.Number-1, s.Number-1) * math.Pow(probability.Number, s.Number) * math.Pow(1-probability.Number, f.Number))
}

// NEGBINOMDIST function calculates the Negative Binomial Distribution for a
// given set of parameters. This gives the probability that there will be a
// specified number of failures before a required number of successes is
// achieved. The syntax of the function is:
//
//	NEGBINOMDIST(number_f,number_s,probability_s)
func (fn *formulaFuncs) NEGBINOMDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "NEGBINOMDIST requires 3 arguments")
	}
	var f, s, probability formulaArg
	if f = argsList.Front().Value.(formulaArg).ToNumber(); f.Type != ArgNumber {
		return f
	}
	if s = argsList.Front().Next().Value.(formulaArg).ToNumber(); s.Type != ArgNumber {
		return s
	}
	if probability = argsList.Back().Value.(formulaArg).ToNumber(); probability.Type != ArgNumber {
		return probability
	}
	if f.Number < 0 || s.Number < 1 || probability.Number < 0 || probability.Number > 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(binomCoeff(f.Number+s.Number-1, s.Number-1) * math.Pow(probability.Number, s.Number) * math.Pow(1-probability.Number, f.Number))
}

// NORMdotDIST function calculates the Normal Probability Density Function or
// the Cumulative Normal Distribution. Function for a supplied set of
// parameters. The syntax of the function is:
//
//	NORM.DIST(x,mean,standard_dev,cumulative)
func (fn *formulaFuncs) NORMdotDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "NORM.DIST requires 4 arguments")
	}
	return fn.NORMDIST(argsList)
}

// NORMDIST function calculates the Normal Probability Density Function or the
// Cumulative Normal Distribution. Function for a supplied set of parameters.
// The syntax of the function is:
//
//	NORMDIST(x,mean,standard_dev,cumulative)
func (fn *formulaFuncs) NORMDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "NORMDIST requires 4 arguments")
	}
	var x, mean, stdDev, cumulative formulaArg
	if x = argsList.Front().Value.(formulaArg).ToNumber(); x.Type != ArgNumber {
		return x
	}
	if mean = argsList.Front().Next().Value.(formulaArg).ToNumber(); mean.Type != ArgNumber {
		return mean
	}
	if stdDev = argsList.Back().Prev().Value.(formulaArg).ToNumber(); stdDev.Type != ArgNumber {
		return stdDev
	}
	if cumulative = argsList.Back().Value.(formulaArg).ToBool(); cumulative.Type == ArgError {
		return cumulative
	}
	if stdDev.Number < 0 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	if cumulative.Number == 1 {
		return newNumberFormulaArg(0.5 * (1 + math.Erf((x.Number-mean.Number)/(stdDev.Number*math.Sqrt(2)))))
	}
	return newNumberFormulaArg((1 / (math.Sqrt(2*math.Pi) * stdDev.Number)) * math.Exp(0-(math.Pow(x.Number-mean.Number, 2)/(2*(stdDev.Number*stdDev.Number)))))
}

// NORMdotINV function calculates the inverse of the Cumulative Normal
// Distribution Function for a supplied value of x, and a supplied
// distribution mean & standard deviation. The syntax of the function is:
//
//	NORM.INV(probability,mean,standard_dev)
func (fn *formulaFuncs) NORMdotINV(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "NORM.INV requires 3 arguments")
	}
	return fn.NORMINV(argsList)
}

// NORMINV function calculates the inverse of the Cumulative Normal
// Distribution Function for a supplied value of x, and a supplied
// distribution mean & standard deviation. The syntax of the function is:
//
//	NORMINV(probability,mean,standard_dev)
func (fn *formulaFuncs) NORMINV(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "NORMINV requires 3 arguments")
	}
	var prob, mean, stdDev formulaArg
	if prob = argsList.Front().Value.(formulaArg).ToNumber(); prob.Type != ArgNumber {
		return prob
	}
	if mean = argsList.Front().Next().Value.(formulaArg).ToNumber(); mean.Type != ArgNumber {
		return mean
	}
	if stdDev = argsList.Back().Value.(formulaArg).ToNumber(); stdDev.Type != ArgNumber {
		return stdDev
	}
	if prob.Number < 0 || prob.Number > 1 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	if stdDev.Number < 0 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	inv, err := norminv(prob.Number)
	if err != nil {
		return newErrorFormulaArg(err.Error(), err.Error())
	}
	return newNumberFormulaArg(inv*stdDev.Number + mean.Number)
}

// NORMdotSdotDIST function calculates the Standard Normal Cumulative
// Distribution Function for a supplied value. The syntax of the function
// is:
//
//	NORM.S.DIST(z)
func (fn *formulaFuncs) NORMdotSdotDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "NORM.S.DIST requires 2 numeric arguments")
	}
	args := list.New().Init()
	args.PushBack(argsList.Front().Value.(formulaArg))
	args.PushBack(formulaArg{Type: ArgNumber, Number: 0})
	args.PushBack(formulaArg{Type: ArgNumber, Number: 1})
	args.PushBack(argsList.Back().Value.(formulaArg))
	return fn.NORMDIST(args)
}

// NORMSDIST function calculates the Standard Normal Cumulative Distribution
// Function for a supplied value. The syntax of the function is:
//
//	NORMSDIST(z)
func (fn *formulaFuncs) NORMSDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "NORMSDIST requires 1 numeric argument")
	}
	args := list.New().Init()
	args.PushBack(argsList.Front().Value.(formulaArg))
	args.PushBack(formulaArg{Type: ArgNumber, Number: 0})
	args.PushBack(formulaArg{Type: ArgNumber, Number: 1})
	args.PushBack(formulaArg{Type: ArgNumber, Number: 1, Boolean: true})
	return fn.NORMDIST(args)
}

// NORMSINV function calculates the inverse of the Standard Normal Cumulative
// Distribution Function for a supplied probability value. The syntax of the
// function is:
//
//	NORMSINV(probability)
func (fn *formulaFuncs) NORMSINV(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "NORMSINV requires 1 numeric argument")
	}
	args := list.New().Init()
	args.PushBack(argsList.Front().Value.(formulaArg))
	args.PushBack(formulaArg{Type: ArgNumber, Number: 0})
	args.PushBack(formulaArg{Type: ArgNumber, Number: 1})
	return fn.NORMINV(args)
}

// NORMdotSdotINV function calculates the inverse of the Standard Normal
// Cumulative Distribution Function for a supplied probability value. The
// syntax of the function is:
//
//	NORM.S.INV(probability)
func (fn *formulaFuncs) NORMdotSdotINV(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "NORM.S.INV requires 1 numeric argument")
	}
	args := list.New().Init()
	args.PushBack(argsList.Front().Value.(formulaArg))
	args.PushBack(formulaArg{Type: ArgNumber, Number: 0})
	args.PushBack(formulaArg{Type: ArgNumber, Number: 1})
	return fn.NORMINV(args)
}

// norminv returns the inverse of the normal cumulative distribution for the
// specified value.
func norminv(p float64) (float64, error) {
	a := map[int]float64{
		1: -3.969683028665376e+01, 2: 2.209460984245205e+02, 3: -2.759285104469687e+02,
		4: 1.383577518672690e+02, 5: -3.066479806614716e+01, 6: 2.506628277459239e+00,
	}
	b := map[int]float64{
		1: -5.447609879822406e+01, 2: 1.615858368580409e+02, 3: -1.556989798598866e+02,
		4: 6.680131188771972e+01, 5: -1.328068155288572e+01,
	}
	c := map[int]float64{
		1: -7.784894002430293e-03, 2: -3.223964580411365e-01, 3: -2.400758277161838e+00,
		4: -2.549732539343734e+00, 5: 4.374664141464968e+00, 6: 2.938163982698783e+00,
	}
	d := map[int]float64{
		1: 7.784695709041462e-03, 2: 3.224671290700398e-01, 3: 2.445134137142996e+00,
		4: 3.754408661907416e+00,
	}
	pLow := 0.02425   // Use lower region approx. below this
	pHigh := 1 - pLow // Use upper region approx. above this
	if 0 < p && p < pLow {
		// Rational approximation for lower region.
		q := math.Sqrt(-2 * math.Log(p))
		return (((((c[1]*q+c[2])*q+c[3])*q+c[4])*q+c[5])*q + c[6]) /
			((((d[1]*q+d[2])*q+d[3])*q+d[4])*q + 1), nil
	} else if pLow <= p && p <= pHigh {
		// Rational approximation for central region.
		q := p - 0.5
		r := q * q
		f1 := ((((a[1]*r+a[2])*r+a[3])*r+a[4])*r + a[5]) * r
		f2 := (b[1]*r + b[2]) * r
		f3 := ((math.Nextafter(f2, f2)+b[3])*r + b[4]) * r
		f4 := (math.Nextafter(f3, f3) + b[5]) * r
		return (math.Nextafter(f1, f1) + a[6]) * q /
			(math.Nextafter(f4, f4) + 1), nil
	} else if pHigh < p && p < 1 {
		// Rational approximation for upper region.
		q := math.Sqrt(-2 * math.Log(1-p))
		return -(((((c[1]*q+c[2])*q+c[3])*q+c[4])*q+c[5])*q + c[6]) /
			((((d[1]*q+d[2])*q+d[3])*q+d[4])*q + 1), nil
	}
	return 0, errors.New(formulaErrorNUM)
}

// kth is an implementation of the formula functions LARGE and SMALL.
func (fn *formulaFuncs) kth(name string, argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires 2 arguments", name))
	}
	array := argsList.Front().Value.(formulaArg).ToList()
	argK := argsList.Back().Value.(formulaArg).ToNumber()
	if argK.Type != ArgNumber {
		return argK
	}
	k := int(argK.Number)
	if k < 1 {
		return newErrorFormulaArg(formulaErrorNUM, "k should be > 0")
	}
	var data []float64
	for _, arg := range array {
		if arg.Type == ArgNumber {
			data = append(data, arg.Number)
		}
	}
	if len(data) < k {
		return newErrorFormulaArg(formulaErrorNUM, "k should be <= length of array")
	}
	sort.Float64s(data)
	if name == "LARGE" {
		return newNumberFormulaArg(data[len(data)-k])
	}
	return newNumberFormulaArg(data[k-1])
}

// LARGE function returns the k'th largest value from an array of numeric
// values. The syntax of the function is:
//
//	LARGE(array,k)
func (fn *formulaFuncs) LARGE(argsList *list.List) formulaArg {
	return fn.kth("LARGE", argsList)
}

// MAX function returns the largest value from a supplied set of numeric
// values. The syntax of the function is:
//
//	MAX(number1,[number2],...)
func (fn *formulaFuncs) MAX(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "MAX requires at least 1 argument")
	}
	return fn.maxValue(false, argsList)
}

// MAXA function returns the largest value from a supplied set of numeric
// values, while counting text and the logical value FALSE as the value 0 and
// counting the logical value TRUE as the value 1. The syntax of the function
// is:
//
//	MAXA(number1,[number2],...)
func (fn *formulaFuncs) MAXA(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "MAXA requires at least 1 argument")
	}
	return fn.maxValue(true, argsList)
}

// MAXIFS function returns the maximum value from a subset of values that are
// specified according to one or more criteria. The syntax of the function
// is:
//
//	MAXIFS(max_range,criteria_range1,criteria1,[criteria_range2,criteria2],...)
func (fn *formulaFuncs) MAXIFS(argsList *list.List) formulaArg {
	if argsList.Len() < 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "MAXIFS requires at least 3 arguments")
	}
	if argsList.Len()%2 != 1 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	var args []formulaArg
	maxVal, maxRange := -math.MaxFloat64, argsList.Front().Value.(formulaArg).Matrix
	for arg := argsList.Front().Next(); arg != nil; arg = arg.Next() {
		args = append(args, arg.Value.(formulaArg))
	}
	for _, ref := range formulaIfsMatch(args) {
		if num := maxRange[ref.Row][ref.Col].ToNumber(); num.Type == ArgNumber && maxVal < num.Number {
			maxVal = num.Number
		}
	}
	if maxVal == -math.MaxFloat64 {
		maxVal = 0
	}
	return newNumberFormulaArg(maxVal)
}

// calcListMatrixMax is part of the implementation max.
func calcListMatrixMax(maxa bool, maxVal float64, arg formulaArg) float64 {
	for _, cell := range arg.ToList() {
		if cell.Type == ArgNumber && cell.Number > maxVal {
			if maxa && cell.Boolean || !cell.Boolean {
				maxVal = cell.Number
			}
		}
	}
	return maxVal
}

// maxValue is an implementation of the formula functions MAX and MAXA.
func (fn *formulaFuncs) maxValue(maxa bool, argsList *list.List) formulaArg {
	maxVal := -math.MaxFloat64
	for token := argsList.Front(); token != nil; token = token.Next() {
		arg := token.Value.(formulaArg)
		switch arg.Type {
		case ArgString:
			if !maxa && (arg.Value() == "TRUE" || arg.Value() == "FALSE") {
				continue
			} else {
				num := arg.ToBool()
				if num.Type == ArgNumber && num.Number > maxVal {
					maxVal = num.Number
					continue
				}
			}
			num := arg.ToNumber()
			if num.Type != ArgError && num.Number > maxVal {
				maxVal = num.Number
			}
		case ArgNumber:
			if arg.Number > maxVal {
				maxVal = arg.Number
			}
		case ArgList, ArgMatrix:
			maxVal = calcListMatrixMax(maxa, maxVal, arg)
		case ArgError:
			return arg
		}
	}
	if maxVal == -math.MaxFloat64 {
		maxVal = 0
	}
	return newNumberFormulaArg(maxVal)
}

// MEDIAN function returns the statistical median (the middle value) of a list
// of supplied numbers. The syntax of the function is:
//
//	MEDIAN(number1,[number2],...)
func (fn *formulaFuncs) MEDIAN(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "MEDIAN requires at least 1 argument")
	}
	var values []float64
	var median float64
	for token := argsList.Front(); token != nil; token = token.Next() {
		arg := token.Value.(formulaArg)
		switch arg.Type {
		case ArgString:
			value := arg.ToNumber()
			if value.Type != ArgNumber {
				return value
			}
			values = append(values, value.Number)
		case ArgNumber:
			values = append(values, arg.Number)
		case ArgMatrix:
			for _, row := range arg.Matrix {
				for _, cell := range row {
					if cell.Type == ArgNumber {
						values = append(values, cell.Number)
					}
				}
			}
		}
	}
	if len(values) == 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	sort.Float64s(values)
	if len(values)%2 == 0 {
		median = (values[len(values)/2-1] + values[len(values)/2]) / 2
	} else {
		median = values[len(values)/2]
	}
	return newNumberFormulaArg(median)
}

// MIN function returns the smallest value from a supplied set of numeric
// values. The syntax of the function is:
//
//	MIN(number1,[number2],...)
func (fn *formulaFuncs) MIN(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "MIN requires at least 1 argument")
	}
	return fn.minValue(false, argsList)
}

// MINA function returns the smallest value from a supplied set of numeric
// values, while counting text and the logical value FALSE as the value 0 and
// counting the logical value TRUE as the value 1. The syntax of the function
// is:
//
//	MINA(number1,[number2],...)
func (fn *formulaFuncs) MINA(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "MINA requires at least 1 argument")
	}
	return fn.minValue(true, argsList)
}

// MINIFS function returns the minimum value from a subset of values that are
// specified according to one or more criteria. The syntax of the function
// is:
//
//	MINIFS(min_range,criteria_range1,criteria1,[criteria_range2,criteria2],...)
func (fn *formulaFuncs) MINIFS(argsList *list.List) formulaArg {
	if argsList.Len() < 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "MINIFS requires at least 3 arguments")
	}
	if argsList.Len()%2 != 1 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	var args []formulaArg
	minVal, minRange := math.MaxFloat64, argsList.Front().Value.(formulaArg).Matrix
	for arg := argsList.Front().Next(); arg != nil; arg = arg.Next() {
		args = append(args, arg.Value.(formulaArg))
	}
	for _, ref := range formulaIfsMatch(args) {
		if num := minRange[ref.Row][ref.Col].ToNumber(); num.Type == ArgNumber && minVal > num.Number {
			minVal = num.Number
		}
	}
	if minVal == math.MaxFloat64 {
		minVal = 0
	}
	return newNumberFormulaArg(minVal)
}

// calcListMatrixMin is part of the implementation min.
func calcListMatrixMin(mina bool, minVal float64, arg formulaArg) float64 {
	for _, cell := range arg.ToList() {
		if cell.Type == ArgNumber && cell.Number < minVal {
			if mina && cell.Boolean || !cell.Boolean {
				minVal = cell.Number
			}
		}
	}
	return minVal
}

// minValue is an implementation of the formula functions MIN and MINA.
func (fn *formulaFuncs) minValue(mina bool, argsList *list.List) formulaArg {
	minVal := math.MaxFloat64
	for token := argsList.Front(); token != nil; token = token.Next() {
		arg := token.Value.(formulaArg)
		switch arg.Type {
		case ArgString:
			if !mina && (arg.Value() == "TRUE" || arg.Value() == "FALSE") {
				continue
			} else {
				num := arg.ToBool()
				if num.Type == ArgNumber && num.Number < minVal {
					minVal = num.Number
					continue
				}
			}
			num := arg.ToNumber()
			if num.Type != ArgError && num.Number < minVal {
				minVal = num.Number
			}
		case ArgNumber:
			if arg.Number < minVal {
				minVal = arg.Number
			}
		case ArgList, ArgMatrix:
			minVal = calcListMatrixMin(mina, minVal, arg)
		case ArgError:
			return arg
		}
	}
	if minVal == math.MaxFloat64 {
		minVal = 0
	}
	return newNumberFormulaArg(minVal)
}

// pearsonProduct is an implementation of the formula functions FORECAST,
// FORECAST.LINEAR, INTERCEPT, PEARSON, RSQ and SLOPE.
func (fn *formulaFuncs) pearsonProduct(name string, n int, argsList *list.List) formulaArg {
	if argsList.Len() != n {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires %d arguments", name, n))
	}
	var fx formulaArg
	array1 := argsList.Back().Value.(formulaArg).ToList()
	array2 := argsList.Front().Value.(formulaArg).ToList()
	if name == "PEARSON" || name == "RSQ" {
		array1, array2 = array2, array1
	}
	if n == 3 {
		if fx = argsList.Front().Value.(formulaArg).ToNumber(); fx.Type != ArgNumber {
			return fx
		}
		array2 = argsList.Front().Next().Value.(formulaArg).ToList()
	}
	if len(array1) != len(array2) {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	var sum, deltaX, deltaY, x, y, length float64
	for i := 0; i < len(array1); i++ {
		num1, num2 := array1[i], array2[i]
		if !(num1.Type == ArgNumber && num2.Type == ArgNumber) {
			continue
		}
		x += num1.Number
		y += num2.Number
		length++
	}
	x /= length
	y /= length
	for i := 0; i < len(array1); i++ {
		num1, num2 := array1[i], array2[i]
		if !(num1.Type == ArgNumber && num2.Type == ArgNumber) {
			continue
		}
		sum += (num1.Number - x) * (num2.Number - y)
		deltaX += (num1.Number - x) * (num1.Number - x)
		deltaY += (num2.Number - y) * (num2.Number - y)
	}
	if sum*deltaX*deltaY == 0 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	return newNumberFormulaArg(map[string]float64{
		"FORECAST":        y + sum/deltaX*(fx.Number-x),
		"FORECAST.LINEAR": y + sum/deltaX*(fx.Number-x),
		"INTERCEPT":       y - sum/deltaX*x,
		"PEARSON":         sum / math.Sqrt(deltaX*deltaY),
		"RSQ":             math.Pow(sum/math.Sqrt(deltaX*deltaY), 2),
		"SLOPE":           sum / deltaX,
	}[name])
}

// PEARSON function calculates the Pearson Product-Moment Correlation
// Coefficient for two sets of values. The syntax of the function is:
//
//	PEARSON(array1,array2)
func (fn *formulaFuncs) PEARSON(argsList *list.List) formulaArg {
	return fn.pearsonProduct("PEARSON", 2, argsList)
}

// PERCENTILEdotEXC function returns the k'th percentile (i.e. the value below
// which k% of the data values fall) for a supplied range of values and a
// supplied k (between 0 & 1 exclusive).The syntax of the function is:
//
//	PERCENTILE.EXC(array,k)
func (fn *formulaFuncs) PERCENTILEdotEXC(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "PERCENTILE.EXC requires 2 arguments")
	}
	array := argsList.Front().Value.(formulaArg).ToList()
	k := argsList.Back().Value.(formulaArg).ToNumber()
	if k.Type != ArgNumber {
		return k
	}
	if k.Number <= 0 || k.Number >= 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	var numbers []float64
	for _, arg := range array {
		if arg.Type == ArgError {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
		if arg.Type == ArgNumber {
			numbers = append(numbers, arg.Number)
		}
	}
	cnt := len(numbers)
	sort.Float64s(numbers)
	idx := k.Number * (float64(cnt) + 1)
	base := math.Floor(idx)
	next := base - 1
	proportion := math.Nextafter(idx, idx) - base
	return newNumberFormulaArg(numbers[int(next)] + ((numbers[int(base)] - numbers[int(next)]) * proportion))
}

// PERCENTILEdotINC function returns the k'th percentile (i.e. the value below
// which k% of the data values fall) for a supplied range of values and a
// supplied k. The syntax of the function is:
//
//	PERCENTILE.INC(array,k)
func (fn *formulaFuncs) PERCENTILEdotINC(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "PERCENTILE.INC requires 2 arguments")
	}
	return fn.PERCENTILE(argsList)
}

// PERCENTILE function returns the k'th percentile (i.e. the value below which
// k% of the data values fall) for a supplied range of values and a supplied
// k. The syntax of the function is:
//
//	PERCENTILE(array,k)
func (fn *formulaFuncs) PERCENTILE(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "PERCENTILE requires 2 arguments")
	}
	array := argsList.Front().Value.(formulaArg).ToList()
	k := argsList.Back().Value.(formulaArg).ToNumber()
	if k.Type != ArgNumber {
		return k
	}
	if k.Number < 0 || k.Number > 1 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	var numbers []float64
	for _, arg := range array {
		if arg.Type == ArgError {
			return arg
		}
		if arg.Type == ArgNumber {
			numbers = append(numbers, arg.Number)
		}
	}
	cnt := len(numbers)
	sort.Float64s(numbers)
	idx := k.Number * (float64(cnt) - 1)
	base := math.Floor(idx)
	if idx == base {
		return newNumberFormulaArg(numbers[int(idx)])
	}
	next := base + 1
	proportion := math.Nextafter(idx, idx) - base
	return newNumberFormulaArg(numbers[int(base)] + ((numbers[int(next)] - numbers[int(base)]) * proportion))
}

// percentrank is an implementation of the formula functions PERCENTRANK and
// PERCENTRANK.INC.
func (fn *formulaFuncs) percentrank(name string, argsList *list.List) formulaArg {
	if argsList.Len() != 2 && argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires 2 or 3 arguments", name))
	}
	array := argsList.Front().Value.(formulaArg).ToList()
	x := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if x.Type != ArgNumber {
		return x
	}
	var numbers []float64
	for _, arg := range array {
		if arg.Type == ArgError {
			return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
		}
		if arg.Type == ArgNumber {
			numbers = append(numbers, arg.Number)
		}
	}
	cnt := len(numbers)
	sort.Float64s(numbers)
	if x.Number < numbers[0] || x.Number > numbers[cnt-1] {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	pos, significance := float64(inFloat64Slice(numbers, x.Number)), newNumberFormulaArg(3)
	if argsList.Len() == 3 {
		if significance = argsList.Back().Value.(formulaArg).ToNumber(); significance.Type != ArgNumber {
			return significance
		}
		if significance.Number < 1 {
			return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s arguments significance should be > 1", name))
		}
	}
	if pos == -1 {
		pos = 0
		cmp := numbers[0]
		for cmp < x.Number {
			pos++
			cmp = numbers[int(pos)]
		}
		pos--
		pos += (x.Number - numbers[int(pos)]) / (cmp - numbers[int(pos)])
	}
	pow := math.Pow(10, significance.Number)
	digit := pow * pos / (float64(cnt) - 1)
	if name == "PERCENTRANK.EXC" {
		digit = pow * (pos + 1) / (float64(cnt) + 1)
	}
	return newNumberFormulaArg(math.Floor(digit) / pow)
}

// PERCENTRANKdotEXC function calculates the relative position, between 0 and
// 1 (exclusive), of a specified value within a supplied array. The syntax of
// the function is:
//
//	PERCENTRANK.EXC(array,x,[significance])
func (fn *formulaFuncs) PERCENTRANKdotEXC(argsList *list.List) formulaArg {
	return fn.percentrank("PERCENTRANK.EXC", argsList)
}

// PERCENTRANKdotINC function calculates the relative position, between 0 and
// 1 (inclusive), of a specified value within a supplied array.The syntax of
// the function is:
//
//	PERCENTRANK.INC(array,x,[significance])
func (fn *formulaFuncs) PERCENTRANKdotINC(argsList *list.List) formulaArg {
	return fn.percentrank("PERCENTRANK.INC", argsList)
}

// PERCENTRANK function calculates the relative position of a specified value,
// within a set of values, as a percentage. The syntax of the function is:
//
//	PERCENTRANK(array,x,[significance])
func (fn *formulaFuncs) PERCENTRANK(argsList *list.List) formulaArg {
	return fn.percentrank("PERCENTRANK", argsList)
}

// PERMUT function calculates the number of permutations of a specified number
// of objects from a set of objects. The syntax of the function is:
//
//	PERMUT(number,number_chosen)
func (fn *formulaFuncs) PERMUT(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "PERMUT requires 2 numeric arguments")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	chosen := argsList.Back().Value.(formulaArg).ToNumber()
	if number.Type != ArgNumber {
		return number
	}
	if chosen.Type != ArgNumber {
		return chosen
	}
	if number.Number < chosen.Number {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	return newNumberFormulaArg(math.Round(fact(number.Number) / fact(number.Number-chosen.Number)))
}

// PERMUTATIONA function calculates the number of permutations, with
// repetitions, of a specified number of objects from a set. The syntax of
// the function is:
//
//	PERMUTATIONA(number,number_chosen)
func (fn *formulaFuncs) PERMUTATIONA(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "PERMUTATIONA requires 2 numeric arguments")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	chosen := argsList.Back().Value.(formulaArg).ToNumber()
	if number.Type != ArgNumber {
		return number
	}
	if chosen.Type != ArgNumber {
		return chosen
	}
	num, numChosen := math.Floor(number.Number), math.Floor(chosen.Number)
	if num < 0 || numChosen < 0 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	return newNumberFormulaArg(math.Pow(num, numChosen))
}

// PHI function returns the value of the density function for a standard normal
// distribution for a supplied number. The syntax of the function is:
//
//	PHI(x)
func (fn *formulaFuncs) PHI(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "PHI requires 1 argument")
	}
	x := argsList.Front().Value.(formulaArg).ToNumber()
	if x.Type != ArgNumber {
		return x
	}
	return newNumberFormulaArg(0.39894228040143268 * math.Exp(-(x.Number*x.Number)/2))
}

// QUARTILE function returns a requested quartile of a supplied range of
// values. The syntax of the function is:
//
//	QUARTILE(array,quart)
func (fn *formulaFuncs) QUARTILE(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "QUARTILE requires 2 arguments")
	}
	quart := argsList.Back().Value.(formulaArg).ToNumber()
	if quart.Type != ArgNumber {
		return quart
	}
	if quart.Number < 0 || quart.Number > 4 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	args := list.New().Init()
	args.PushBack(argsList.Front().Value.(formulaArg))
	args.PushBack(newNumberFormulaArg(quart.Number / 4))
	return fn.PERCENTILE(args)
}

// QUARTILEdotEXC function returns a requested quartile of a supplied range of
// values, based on a percentile range of 0 to 1 exclusive. The syntax of the
// function is:
//
//	QUARTILE.EXC(array,quart)
func (fn *formulaFuncs) QUARTILEdotEXC(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "QUARTILE.EXC requires 2 arguments")
	}
	quart := argsList.Back().Value.(formulaArg).ToNumber()
	if quart.Type != ArgNumber {
		return quart
	}
	if quart.Number <= 0 || quart.Number >= 4 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	args := list.New().Init()
	args.PushBack(argsList.Front().Value.(formulaArg))
	args.PushBack(newNumberFormulaArg(quart.Number / 4))
	return fn.PERCENTILEdotEXC(args)
}

// QUARTILEdotINC function returns a requested quartile of a supplied range of
// values. The syntax of the function is:
//
//	QUARTILE.INC(array,quart)
func (fn *formulaFuncs) QUARTILEdotINC(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "QUARTILE.INC requires 2 arguments")
	}
	return fn.QUARTILE(argsList)
}

// rank is an implementation of the formula functions RANK and RANK.EQ.
func (fn *formulaFuncs) rank(name string, argsList *list.List) formulaArg {
	if argsList.Len() < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires at least 2 arguments", name))
	}
	if argsList.Len() > 3 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires at most 3 arguments", name))
	}
	num := argsList.Front().Value.(formulaArg).ToNumber()
	if num.Type != ArgNumber {
		return num
	}
	var arr []float64
	for _, arg := range argsList.Front().Next().Value.(formulaArg).ToList() {
		if arg.Type == ArgNumber {
			arr = append(arr, arg.Number)
		}
	}
	sort.Float64s(arr)
	order := newNumberFormulaArg(0)
	if argsList.Len() == 3 {
		if order = argsList.Back().Value.(formulaArg).ToNumber(); order.Type != ArgNumber {
			return order
		}
	}
	if order.Number == 0 {
		sort.Sort(sort.Reverse(sort.Float64Slice(arr)))
	}
	if idx := inFloat64Slice(arr, num.Number); idx != -1 {
		return newNumberFormulaArg(float64(idx + 1))
	}
	return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
}

// RANKdotEQ function returns the statistical rank of a given value, within a
// supplied array of values. If there are duplicate values in the list, these
// are given the same rank. The syntax of the function is:
//
//	RANK.EQ(number,ref,[order])
func (fn *formulaFuncs) RANKdotEQ(argsList *list.List) formulaArg {
	return fn.rank("RANK.EQ", argsList)
}

// RANK function returns the statistical rank of a given value, within a
// supplied array of values. If there are duplicate values in the list, these
// are given the same rank. The syntax of the function is:
//
//	RANK(number,ref,[order])
func (fn *formulaFuncs) RANK(argsList *list.List) formulaArg {
	return fn.rank("RANK", argsList)
}

// RSQ function calculates the square of the Pearson Product-Moment Correlation
// Coefficient for two supplied sets of values. The syntax of the function
// is:
//
//	RSQ(known_y's,known_x's)
func (fn *formulaFuncs) RSQ(argsList *list.List) formulaArg {
	return fn.pearsonProduct("RSQ", 2, argsList)
}

// skew is an implementation of the formula functions SKEW and SKEW.P.
func (fn *formulaFuncs) skew(name string, argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires at least 1 argument", name))
	}
	mean := fn.AVERAGE(argsList)
	var stdDev formulaArg
	var count, summer float64
	if name == "SKEW" {
		stdDev = fn.STDEV(argsList)
	} else {
		stdDev = fn.STDEVP(argsList)
	}
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		token := arg.Value.(formulaArg)
		switch token.Type {
		case ArgNumber, ArgString:
			num := token.ToNumber()
			if num.Type == ArgError {
				return num
			}
			summer += math.Pow((num.Number-mean.Number)/stdDev.Number, 3)
			count++
		case ArgList, ArgMatrix:
			for _, cell := range token.ToList() {
				if cell.Type != ArgNumber {
					continue
				}
				summer += math.Pow((cell.Number-mean.Number)/stdDev.Number, 3)
				count++
			}
		}
	}
	if count > 2 {
		if name == "SKEW" {
			return newNumberFormulaArg(summer * (count / ((count - 1) * (count - 2))))
		}
		return newNumberFormulaArg(summer / count)
	}
	return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
}

// SKEW function calculates the skewness of the distribution of a supplied set
// of values. The syntax of the function is:
//
//	SKEW(number1,[number2],...)
func (fn *formulaFuncs) SKEW(argsList *list.List) formulaArg {
	return fn.skew("SKEW", argsList)
}

// SKEWdotP function calculates the skewness of the distribution of a supplied
// set of values. The syntax of the function is:
//
//	SKEW.P(number1,[number2],...)
func (fn *formulaFuncs) SKEWdotP(argsList *list.List) formulaArg {
	return fn.skew("SKEW.P", argsList)
}

// SLOPE returns the slope of the linear regression line through data points in
// known_y's and known_x's. The slope is the vertical distance divided by the
// horizontal distance between any two points on the line, which is the rate
// of change along the regression line. The syntax of the function is:
//
//	SLOPE(known_y's,known_x's)
func (fn *formulaFuncs) SLOPE(argsList *list.List) formulaArg {
	return fn.pearsonProduct("SLOPE", 2, argsList)
}

// SMALL function returns the k'th smallest value from an array of numeric
// values. The syntax of the function is:
//
//	SMALL(array,k)
func (fn *formulaFuncs) SMALL(argsList *list.List) formulaArg {
	return fn.kth("SMALL", argsList)
}

// STANDARDIZE function returns a normalized value of a distribution that is
// characterized by a supplied mean and standard deviation. The syntax of the
// function is:
//
//	STANDARDIZE(x,mean,standard_dev)
func (fn *formulaFuncs) STANDARDIZE(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "STANDARDIZE requires 3 arguments")
	}
	x := argsList.Front().Value.(formulaArg).ToNumber()
	if x.Type != ArgNumber {
		return x
	}
	mean := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if mean.Type != ArgNumber {
		return mean
	}
	stdDev := argsList.Back().Value.(formulaArg).ToNumber()
	if stdDev.Type != ArgNumber {
		return stdDev
	}
	if stdDev.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	return newNumberFormulaArg((x.Number - mean.Number) / stdDev.Number)
}

// stdevp is an implementation of the formula functions STDEVP, STDEV.P and
// STDEVPA.
func (fn *formulaFuncs) stdevp(name string, argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires at least 1 argument", name))
	}
	fnName := "VARP"
	if name == "STDEVPA" {
		fnName = "VARPA"
	}
	varp := fn.vars(fnName, argsList)
	if varp.Type != ArgNumber {
		return varp
	}
	return newNumberFormulaArg(math.Sqrt(varp.Number))
}

// STDEVP function calculates the standard deviation of a supplied set of
// values. The syntax of the function is:
//
//	STDEVP(number1,[number2],...)
func (fn *formulaFuncs) STDEVP(argsList *list.List) formulaArg {
	return fn.stdevp("STDEVP", argsList)
}

// STDEVdotP function calculates the standard deviation of a supplied set of
// values.
//
//	STDEV.P( number1, [number2], ... )
func (fn *formulaFuncs) STDEVdotP(argsList *list.List) formulaArg {
	return fn.stdevp("STDEV.P", argsList)
}

// STDEVPA function calculates the standard deviation of a supplied set of
// values. The syntax of the function is:
//
//	STDEVPA(number1,[number2],...)
func (fn *formulaFuncs) STDEVPA(argsList *list.List) formulaArg {
	return fn.stdevp("STDEVPA", argsList)
}

// STEYX function calculates the standard error for the line of best fit,
// through a supplied set of x- and y- values. The syntax of the function is:
//
//	STEYX(known_y's,known_x's)
func (fn *formulaFuncs) STEYX(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "STEYX requires 2 arguments")
	}
	array1 := argsList.Back().Value.(formulaArg).ToList()
	array2 := argsList.Front().Value.(formulaArg).ToList()
	if len(array1) != len(array2) {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	var count, sumX, sumY, squareX, squareY, sigmaXY float64
	for i := 0; i < len(array1); i++ {
		num1, num2 := array1[i], array2[i]
		if !(num1.Type == ArgNumber && num2.Type == ArgNumber) {
			continue
		}
		sumX += num1.Number
		sumY += num2.Number
		squareX += num1.Number * num1.Number
		squareY += num2.Number * num2.Number
		sigmaXY += num1.Number * num2.Number
		count++
	}
	if count < 3 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	dx, dy := sumX/count, sumY/count
	sigma1 := squareY - 2*dy*sumY + count*dy*dy
	sigma2 := sigmaXY - dy*sumX - sumY*dx + count*dy*dx
	sigma3 := squareX - 2*dx*sumX + count*dx*dx
	return newNumberFormulaArg(math.Sqrt((sigma1 - (sigma2*sigma2)/sigma3) / (count - 2)))
}

// getTDist is an implementation for the beta distribution probability density
// function.
func getTDist(T, fDF, nType float64) float64 {
	var res float64
	switch nType {
	case 1:
		res = 0.5 * getBetaDist(fDF/(fDF+T*T), fDF/2, 0.5)
	case 2:
		res = getBetaDist(fDF/(fDF+T*T), fDF/2, 0.5)
	case 3:
		res = math.Pow(1+(T*T/fDF), -(fDF+1)/2) / (math.Sqrt(fDF) * getBeta(0.5, fDF/2.0))
	case 4:
		X := fDF / (T*T + fDF)
		R := 0.5 * getBetaDist(X, 0.5*fDF, 0.5)
		res = 1 - R
		if T < 0 {
			res = R
		}
	}
	return res
}

// TdotDIST function calculates the one-tailed Student's T Distribution, which
// is a continuous probability distribution that is frequently used for
// testing hypotheses on small sample data sets. The syntax of the function
// is:
//
//	T.DIST(x,degrees_freedom,cumulative)
func (fn *formulaFuncs) TdotDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "T.DIST requires 3 arguments")
	}
	var x, degrees, cumulative formulaArg
	if x = argsList.Front().Value.(formulaArg).ToNumber(); x.Type != ArgNumber {
		return x
	}
	if degrees = argsList.Front().Next().Value.(formulaArg).ToNumber(); degrees.Type != ArgNumber {
		return degrees
	}
	if cumulative = argsList.Back().Value.(formulaArg).ToBool(); cumulative.Type != ArgNumber {
		return cumulative
	}
	if cumulative.Number == 1 && degrees.Number < 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if cumulative.Number == 0 {
		if degrees.Number < 0 {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
		if degrees.Number == 0 {
			return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
		}
		return newNumberFormulaArg(getTDist(x.Number, degrees.Number, 3))
	}
	return newNumberFormulaArg(getTDist(x.Number, degrees.Number, 4))
}

// TdotDISTdot2T function calculates the two-tailed Student's T Distribution,
// which is a continuous probability distribution that is frequently used for
// testing hypotheses on small sample data sets. The syntax of the function
// is:
//
//	T.DIST.2T(x,degrees_freedom)
func (fn *formulaFuncs) TdotDISTdot2T(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "T.DIST.2T requires 2 arguments")
	}
	var x, degrees formulaArg
	if x = argsList.Front().Value.(formulaArg).ToNumber(); x.Type != ArgNumber {
		return x
	}
	if degrees = argsList.Back().Value.(formulaArg).ToNumber(); degrees.Type != ArgNumber {
		return degrees
	}
	if x.Number < 0 || degrees.Number < 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(getTDist(x.Number, degrees.Number, 2))
}

// TdotDISTdotRT function calculates the right-tailed Student's T Distribution,
// which is a continuous probability distribution that is frequently used for
// testing hypotheses on small sample data sets. The syntax of the function
// is:
//
//	T.DIST.RT(x,degrees_freedom)
func (fn *formulaFuncs) TdotDISTdotRT(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "T.DIST.RT requires 2 arguments")
	}
	var x, degrees formulaArg
	if x = argsList.Front().Value.(formulaArg).ToNumber(); x.Type != ArgNumber {
		return x
	}
	if degrees = argsList.Back().Value.(formulaArg).ToNumber(); degrees.Type != ArgNumber {
		return degrees
	}
	if degrees.Number < 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	v := getTDist(x.Number, degrees.Number, 1)
	if x.Number < 0 {
		v = 1 - v
	}
	return newNumberFormulaArg(v)
}

// TDIST function calculates the Student's T Distribution, which is a
// continuous probability distribution that is frequently used for testing
// hypotheses on small sample data sets. The syntax of the function is:
//
//	TDIST(x,degrees_freedom,tails)
func (fn *formulaFuncs) TDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "TDIST requires 3 arguments")
	}
	var x, degrees, tails formulaArg
	if x = argsList.Front().Value.(formulaArg).ToNumber(); x.Type != ArgNumber {
		return x
	}
	if degrees = argsList.Front().Next().Value.(formulaArg).ToNumber(); degrees.Type != ArgNumber {
		return degrees
	}
	if tails = argsList.Back().Value.(formulaArg).ToNumber(); tails.Type != ArgNumber {
		return tails
	}
	if x.Number < 0 || degrees.Number < 1 || (tails.Number != 1 && tails.Number != 2) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(getTDist(x.Number, degrees.Number, tails.Number))
}

// TdotINV function calculates the left-tailed inverse of the Student's T
// Distribution, which is a continuous probability distribution that is
// frequently used for testing hypotheses on small sample data sets. The
// syntax of the function is:
//
//	T.INV(probability,degrees_freedom)
func (fn *formulaFuncs) TdotINV(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "T.INV requires 2 arguments")
	}
	var probability, degrees formulaArg
	if probability = argsList.Front().Value.(formulaArg).ToNumber(); probability.Type != ArgNumber {
		return probability
	}
	if degrees = argsList.Back().Value.(formulaArg).ToNumber(); degrees.Type != ArgNumber {
		return degrees
	}
	if probability.Number <= 0 || probability.Number >= 1 || degrees.Number < 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if probability.Number < 0.5 {
		return newNumberFormulaArg(-calcIterateInverse(calcInverseIterator{
			name: "T.INV",
			fp:   1 - probability.Number,
			fDF:  degrees.Number,
			nT:   4,
		}, degrees.Number/2, degrees.Number))
	}
	return newNumberFormulaArg(calcIterateInverse(calcInverseIterator{
		name: "T.INV",
		fp:   probability.Number,
		fDF:  degrees.Number,
		nT:   4,
	}, degrees.Number/2, degrees.Number))
}

// TdotINVdot2T function calculates the inverse of the two-tailed Student's T
// Distribution, which is a continuous probability distribution that is
// frequently used for testing hypotheses on small sample data sets. The
// syntax of the function is:
//
//	T.INV.2T(probability,degrees_freedom)
func (fn *formulaFuncs) TdotINVdot2T(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "T.INV.2T requires 2 arguments")
	}
	var probability, degrees formulaArg
	if probability = argsList.Front().Value.(formulaArg).ToNumber(); probability.Type != ArgNumber {
		return probability
	}
	if degrees = argsList.Back().Value.(formulaArg).ToNumber(); degrees.Type != ArgNumber {
		return degrees
	}
	if probability.Number <= 0 || probability.Number > 1 || degrees.Number < 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(calcIterateInverse(calcInverseIterator{
		name: "T.INV.2T",
		fp:   probability.Number,
		fDF:  degrees.Number,
		nT:   2,
	}, degrees.Number/2, degrees.Number))
}

// TINV function calculates the inverse of the two-tailed Student's T
// Distribution, which is a continuous probability distribution that is
// frequently used for testing hypotheses on small sample data sets. The
// syntax of the function is:
//
//	TINV(probability,degrees_freedom)
func (fn *formulaFuncs) TINV(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "TINV requires 2 arguments")
	}
	return fn.TdotINVdot2T(argsList)
}

// TREND function calculates the linear trend line through a given set of
// y-values and (optionally), a given set of x-values. The function then
// extends the linear trendline to calculate additional y-values for a further
// supplied set of new x-values. The syntax of the function is:
//
//	TREND(known_y's,[known_x's],[new_x's],[const])
func (fn *formulaFuncs) TREND(argsList *list.List) formulaArg {
	return fn.trendGrowth("TREND", argsList)
}

// tTest calculates the probability associated with the Student's T Test.
func tTest(bTemplin bool, mtx1, mtx2 [][]formulaArg, c1, c2, r1, r2 int) (float64, float64, bool) {
	var cnt1, cnt2, sum1, sumSqr1, sum2, sumSqr2 float64
	var fVal formulaArg
	for i := 0; i < c1; i++ {
		for j := 0; j < r1; j++ {
			if fVal = mtx1[i][j]; fVal.Type == ArgNumber {
				sum1 += fVal.Number
				sumSqr1 += fVal.Number * fVal.Number
				cnt1++
			}
		}
	}
	for i := 0; i < c2; i++ {
		for j := 0; j < r2; j++ {
			if fVal = mtx2[i][j]; fVal.Type == ArgNumber {
				sum2 += fVal.Number
				sumSqr2 += fVal.Number * fVal.Number
				cnt2++
			}
		}
	}
	if cnt1 < 2.0 || cnt2 < 2.0 {
		return 0, 0, false
	}
	if bTemplin {
		fS1 := (sumSqr1 - sum1*sum1/cnt1) / (cnt1 - 1) / cnt1
		fS2 := (sumSqr2 - sum2*sum2/cnt2) / (cnt2 - 1) / cnt2
		if fS1+fS2 == 0 {
			return 0, 0, false
		}
		c := fS1 / (fS1 + fS2)
		return math.Abs(sum1/cnt1-sum2/cnt2) / math.Sqrt(fS1+fS2), 1 / (c*c/(cnt1-1) + (1-c)*(1-c)/(cnt2-1)), true
	}
	fS1 := (sumSqr1 - sum1*sum1/cnt1) / (cnt1 - 1)
	fS2 := (sumSqr2 - sum2*sum2/cnt2) / (cnt2 - 1)
	return math.Abs(sum1/cnt1-sum2/cnt2) / math.Sqrt((cnt1-1)*fS1+(cnt2-1)*fS2) * math.Sqrt(cnt1*cnt2*(cnt1+cnt2-2)/(cnt1+cnt2)), cnt1 + cnt2 - 2, true
}

// tTest is an implementation of the formula function TTEST.
func (fn *formulaFuncs) tTest(mtx1, mtx2 [][]formulaArg, fTails, fTyp float64) formulaArg {
	var fT, fF float64
	c1, c2, r1, r2, ok := len(mtx1), len(mtx2), len(mtx1[0]), len(mtx2[0]), true
	if fTyp == 1 {
		if c1 != c2 || r1 != r2 {
			return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
		}
		var cnt, sum1, sum2, sumSqrD float64
		var fVal1, fVal2 formulaArg
		for i := 0; i < c1; i++ {
			for j := 0; j < r1; j++ {
				fVal1, fVal2 = mtx1[i][j], mtx2[i][j]
				if fVal1.Type != ArgNumber || fVal2.Type != ArgNumber {
					continue
				}
				sum1 += fVal1.Number
				sum2 += fVal2.Number
				sumSqrD += (fVal1.Number - fVal2.Number) * (fVal1.Number - fVal2.Number)
				cnt++
			}
		}
		if cnt < 1 {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
		sumD := sum1 - sum2
		divider := cnt*sumSqrD - sumD*sumD
		if divider == 0 {
			return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
		}
		fT = math.Abs(sumD) * math.Sqrt((cnt-1)/divider)
		fF = cnt - 1
	} else if fTyp == 2 {
		fT, fF, ok = tTest(false, mtx1, mtx2, c1, c2, r1, r2)
	} else {
		fT, fF, ok = tTest(true, mtx1, mtx2, c1, c2, r1, r2)
	}
	if !ok {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(getTDist(fT, fF, fTails))
}

// TTEST function calculates the probability associated with the Student's T
// Test, which is commonly used for identifying whether two data sets are
// likely to have come from the same two underlying populations with the same
// mean. The syntax of the function is:
//
//	TTEST(array1,array2,tails,type)
func (fn *formulaFuncs) TTEST(argsList *list.List) formulaArg {
	if argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "TTEST requires 4 arguments")
	}
	var array1, array2, tails, typeArg formulaArg
	array1 = argsList.Front().Value.(formulaArg)
	array2 = argsList.Front().Next().Value.(formulaArg)
	if tails = argsList.Front().Next().Next().Value.(formulaArg); tails.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	if typeArg = argsList.Back().Value.(formulaArg); typeArg.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	if len(array1.Matrix) == 0 || len(array2.Matrix) == 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if tails.Number != 1 && tails.Number != 2 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if typeArg.Number != 1 && typeArg.Number != 2 && typeArg.Number != 3 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return fn.tTest(array1.Matrix, array2.Matrix, tails.Number, typeArg.Number)
}

// TdotTEST function calculates the probability associated with the Student's T
// Test, which is commonly used for identifying whether two data sets are
// likely to have come from the same two underlying populations with the same
// mean. The syntax of the function is:
//
//	T.TEST(array1,array2,tails,type)
func (fn *formulaFuncs) TdotTEST(argsList *list.List) formulaArg {
	if argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "T.TEST requires 4 arguments")
	}
	return fn.TTEST(argsList)
}

// TRIMMEAN function calculates the trimmed mean (or truncated mean) of a
// supplied set of values. The syntax of the function is:
//
//	TRIMMEAN(array,percent)
func (fn *formulaFuncs) TRIMMEAN(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "TRIMMEAN requires 2 arguments")
	}
	percent := argsList.Back().Value.(formulaArg).ToNumber()
	if percent.Type != ArgNumber {
		return percent
	}
	if percent.Number < 0 || percent.Number >= 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	var arr []float64
	arrArg := argsList.Front().Value.(formulaArg).ToList()
	for _, cell := range arrArg {
		if cell.Type != ArgNumber {
			continue
		}
		arr = append(arr, cell.Number)
	}
	discard := math.Floor(float64(len(arr)) * percent.Number / 2)
	sort.Float64s(arr)
	for i := 0; i < int(discard); i++ {
		if len(arr) > 0 {
			arr = arr[1:]
		}
		if len(arr) > 0 {
			arr = arr[:len(arr)-1]
		}
	}

	args := list.New().Init()
	for _, ele := range arr {
		args.PushBack(newNumberFormulaArg(ele))
	}
	return fn.AVERAGE(args)
}

// vars is an implementation of the formula functions VAR, VARA, VARP, VAR.P
// VAR.S and VARPA.
func (fn *formulaFuncs) vars(name string, argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires at least 1 argument", name))
	}
	summerA, summerB, count := 0.0, 0.0, 0.0
	minimum := 0.0
	if name == "VAR" || name == "VAR.S" || name == "VARA" {
		minimum = 1.0
	}
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		for _, token := range arg.Value.(formulaArg).ToList() {
			if token.Value() == "" {
				continue
			}
			num := token.ToNumber()
			if token.Value() != "TRUE" && num.Type == ArgNumber {
				summerA += num.Number * num.Number
				summerB += num.Number
				count++
				continue
			}
			num = token.ToBool()
			if num.Type == ArgNumber {
				summerA += num.Number * num.Number
				summerB += num.Number
				count++
				continue
			}
			if name == "VARA" || name == "VARPA" {
				count++
			}
		}
	}
	if count > minimum {
		summerA *= count
		summerB *= summerB
		return newNumberFormulaArg((summerA - summerB) / (count * (count - minimum)))
	}
	return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
}

// VAR function returns the sample variance of a supplied set of values. The
// syntax of the function is:
//
//	VAR(number1,[number2],...)
func (fn *formulaFuncs) VAR(argsList *list.List) formulaArg {
	return fn.vars("VAR", argsList)
}

// VARA function calculates the sample variance of a supplied set of values.
// The syntax of the function is:
//
//	VARA(number1,[number2],...)
func (fn *formulaFuncs) VARA(argsList *list.List) formulaArg {
	return fn.vars("VARA", argsList)
}

// VARP function returns the Variance of a given set of values. The syntax of
// the function is:
//
//	VARP(number1,[number2],...)
func (fn *formulaFuncs) VARP(argsList *list.List) formulaArg {
	return fn.vars("VARP", argsList)
}

// VARdotP function returns the Variance of a given set of values. The syntax
// of the function is:
//
//	VAR.P(number1,[number2],...)
func (fn *formulaFuncs) VARdotP(argsList *list.List) formulaArg {
	return fn.vars("VAR.P", argsList)
}

// VARdotS function calculates the sample variance of a supplied set of
// values. The syntax of the function is:
//
//	VAR.S(number1,[number2],...)
func (fn *formulaFuncs) VARdotS(argsList *list.List) formulaArg {
	return fn.vars("VAR.S", argsList)
}

// VARPA function returns the Variance of a given set of values. The syntax of
// the function is:
//
//	VARPA(number1,[number2],...)
func (fn *formulaFuncs) VARPA(argsList *list.List) formulaArg {
	return fn.vars("VARPA", argsList)
}

// WEIBULL function calculates the Weibull Probability Density Function or the
// Weibull Cumulative Distribution Function for a supplied set of parameters.
// The syntax of the function is:
//
//	WEIBULL(x,alpha,beta,cumulative)
func (fn *formulaFuncs) WEIBULL(argsList *list.List) formulaArg {
	if argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "WEIBULL requires 4 arguments")
	}
	x := argsList.Front().Value.(formulaArg).ToNumber()
	alpha := argsList.Front().Next().Value.(formulaArg).ToNumber()
	beta := argsList.Back().Prev().Value.(formulaArg).ToNumber()
	if alpha.Type == ArgNumber && beta.Type == ArgNumber && x.Type == ArgNumber {
		if alpha.Number < 0 || alpha.Number <= 0 || beta.Number <= 0 {
			return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
		}
		cumulative := argsList.Back().Value.(formulaArg).ToBool()
		if cumulative.Boolean && cumulative.Number == 1 {
			return newNumberFormulaArg(1 - math.Exp(0-math.Pow(x.Number/beta.Number, alpha.Number)))
		}
		return newNumberFormulaArg((alpha.Number / math.Pow(beta.Number, alpha.Number)) *
			math.Pow(x.Number, alpha.Number-1) * math.Exp(0-math.Pow(x.Number/beta.Number, alpha.Number)))
	}
	return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
}

// WEIBULLdotDIST function calculates the Weibull Probability Density Function
// or the Weibull Cumulative Distribution Function for a supplied set of
// parameters. The syntax of the function is:
//
//	WEIBULL.DIST(x,alpha,beta,cumulative)
func (fn *formulaFuncs) WEIBULLdotDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "WEIBULL.DIST requires 4 arguments")
	}
	return fn.WEIBULL(argsList)
}

// ZdotTEST function calculates the one-tailed probability value of the
// Z-Test. The syntax of the function is:
//
//	Z.TEST(array,x,[sigma])
func (fn *formulaFuncs) ZdotTEST(argsList *list.List) formulaArg {
	argsLen := argsList.Len()
	if argsLen < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "Z.TEST requires at least 2 arguments")
	}
	if argsLen > 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "Z.TEST accepts at most 3 arguments")
	}
	return fn.ZTEST(argsList)
}

// ZTEST function calculates the one-tailed probability value of the Z-Test.
// The syntax of the function is:
//
//	ZTEST(array,x,[sigma])
func (fn *formulaFuncs) ZTEST(argsList *list.List) formulaArg {
	argsLen := argsList.Len()
	if argsLen < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "ZTEST requires at least 2 arguments")
	}
	if argsLen > 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "ZTEST accepts at most 3 arguments")
	}
	arrArg, arrArgs := argsList.Front().Value.(formulaArg), list.New()
	arrArgs.PushBack(arrArg)
	arr := fn.AVERAGE(arrArgs)
	if arr.Type == ArgError {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	x := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if x.Type == ArgError {
		return x
	}
	sigma := argsList.Back().Value.(formulaArg).ToNumber()
	if sigma.Type == ArgError {
		return sigma
	}
	if argsLen != 3 {
		sigma = fn.STDEV(arrArgs).ToNumber()
	}
	normsdistArg := list.New()
	div := sigma.Number / math.Sqrt(float64(len(arrArg.ToList())))
	if div == 0 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	normsdistArg.PushBack(newNumberFormulaArg((arr.Number - x.Number) / div))
	return newNumberFormulaArg(1 - fn.NORMSDIST(normsdistArg).Number)
}

// Information Functions

// ERRORdotTYPE function receives an error value and returns an integer, that
// tells you the type of the supplied error. The syntax of the function is:
//
//	ERROR.TYPE(error_val)
