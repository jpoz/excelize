// Copyright 2016 - 2025 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excel™ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.24.0 or later.

package excelize

import (
	"container/list"
	"fmt"
	"math"
	"strconv"
	"strings"
	"time"
)

func validateFrequency(freq float64) bool {
	return freq == 1 || freq == 2 || freq == 4
}

// ACCRINT function returns the accrued interest in a security that pays
// periodic interest. The syntax of the function is:
//
//	ACCRINT(issue,first_interest,settlement,rate,par,frequency,[basis],[calc_method])
func (fn *formulaFuncs) ACCRINT(argsList *list.List) formulaArg {
	if argsList.Len() < 6 {
		return newErrorFormulaArg(formulaErrorVALUE, "ACCRINT requires at least 6 arguments")
	}
	if argsList.Len() > 8 {
		return newErrorFormulaArg(formulaErrorVALUE, "ACCRINT allows at most 8 arguments")
	}
	args := fn.prepareDataValueArgs(3, argsList)
	if args.Type != ArgList {
		return args
	}
	issue, settlement := args.List[0], args.List[2]
	rate := argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber()
	par := argsList.Front().Next().Next().Next().Next().Value.(formulaArg).ToNumber()
	frequency := argsList.Front().Next().Next().Next().Next().Next().Value.(formulaArg).ToNumber()
	if rate.Type != ArgNumber || par.Type != ArgNumber || frequency.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if !validateFrequency(frequency.Number) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	basis := newNumberFormulaArg(0)
	if argsList.Len() >= 7 {
		if basis = argsList.Front().Next().Next().Next().Next().Next().Next().Value.(formulaArg).ToNumber(); basis.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
	}
	if argsList.Len() == 8 {
		if cm := argsList.Back().Value.(formulaArg).ToBool(); cm.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
	}
	frac1 := yearFrac(issue.Number, settlement.Number, int(basis.Number))
	if frac1.Type != ArgNumber {
		return frac1
	}
	return newNumberFormulaArg(par.Number * rate.Number * frac1.Number)
}

// ACCRINTM function returns the accrued interest in a security that pays
// interest at maturity. The syntax of the function is:
//
//	ACCRINTM(issue,settlement,rate,[par],[basis])
func (fn *formulaFuncs) ACCRINTM(argsList *list.List) formulaArg {
	if argsList.Len() != 4 && argsList.Len() != 5 {
		return newErrorFormulaArg(formulaErrorVALUE, "ACCRINTM requires 4 or 5 arguments")
	}
	args := fn.prepareDataValueArgs(2, argsList)
	if args.Type != ArgList {
		return args
	}
	issue, settlement := args.List[0], args.List[1]
	if settlement.Number < issue.Number {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	rate := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	par := argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber()
	if rate.Type != ArgNumber || par.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if par.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	basis := newNumberFormulaArg(0)
	if argsList.Len() == 5 {
		if basis = argsList.Back().Value.(formulaArg).ToNumber(); basis.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
	}
	frac := yearFrac(issue.Number, settlement.Number, int(basis.Number))
	if frac.Type != ArgNumber {
		return frac
	}
	return newNumberFormulaArg(frac.Number * rate.Number * par.Number)
}

// prepareAmorArgs checking and prepare arguments for the formula functions
// AMORDEGRC and AMORLINC.
func (fn *formulaFuncs) prepareAmorArgs(name string, argsList *list.List) formulaArg {
	cost := argsList.Front().Value.(formulaArg).ToNumber()
	if cost.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires cost to be number argument", name))
	}
	if cost.Number < 0 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires cost >= 0", name))
	}
	args := list.New().Init()
	args.PushBack(argsList.Front().Next().Value.(formulaArg))
	datePurchased := fn.DATEVALUE(args)
	if datePurchased.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	args.Init()
	args.PushBack(argsList.Front().Next().Next().Value.(formulaArg))
	firstPeriod := fn.DATEVALUE(args)
	if firstPeriod.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	if firstPeriod.Number < datePurchased.Number {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	salvage := argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber()
	if salvage.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if salvage.Number < 0 || salvage.Number > cost.Number {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	period := argsList.Front().Next().Next().Next().Next().Value.(formulaArg).ToNumber()
	if period.Type != ArgNumber || period.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	rate := argsList.Front().Next().Next().Next().Next().Next().Value.(formulaArg).ToNumber()
	if rate.Type != ArgNumber || rate.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	basis := newNumberFormulaArg(0)
	if argsList.Len() == 7 {
		if basis = argsList.Back().Value.(formulaArg).ToNumber(); basis.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
	}
	return newListFormulaArg([]formulaArg{cost, datePurchased, firstPeriod, salvage, period, rate, basis})
}

// AMORDEGRC function is provided for users of the French accounting system.
// The function calculates the prorated linear depreciation of an asset for a
// specified accounting period. The syntax of the function is:
//
//	AMORDEGRC(cost,date_purchased,first_period,salvage,period,rate,[basis])
func (fn *formulaFuncs) AMORDEGRC(argsList *list.List) formulaArg {
	if argsList.Len() != 6 && argsList.Len() != 7 {
		return newErrorFormulaArg(formulaErrorVALUE, "AMORDEGRC requires 6 or 7 arguments")
	}
	args := fn.prepareAmorArgs("AMORDEGRC", argsList)
	if args.Type != ArgList {
		return args
	}
	cost, datePurchased, firstPeriod, salvage, period, rate, basis := args.List[0], args.List[1], args.List[2], args.List[3], args.List[4], args.List[5], args.List[6]
	if rate.Number >= 0.5 {
		return newErrorFormulaArg(formulaErrorNUM, "AMORDEGRC requires rate to be < 0.5")
	}
	assetsLife, amorCoeff := 1/rate.Number, 2.5
	if assetsLife < 3 {
		amorCoeff = 1
	} else if assetsLife < 5 {
		amorCoeff = 1.5
	} else if assetsLife <= 6 {
		amorCoeff = 2
	}
	rate.Number *= amorCoeff
	frac := yearFrac(datePurchased.Number, firstPeriod.Number, int(basis.Number))
	if frac.Type != ArgNumber {
		return frac
	}
	nRate := float64(int((frac.Number * cost.Number * rate.Number) + 0.5))
	cost.Number -= nRate
	rest := cost.Number - salvage.Number
	for n := 0; n < int(period.Number); n++ {
		nRate = float64(int((cost.Number * rate.Number) + 0.5))
		rest -= nRate
		if rest < 0 {
			switch int(period.Number) - n {
			case 0:
			case 1:
				return newNumberFormulaArg(float64(int((cost.Number * 0.5) + 0.5)))
			default:
				return newNumberFormulaArg(0)
			}
		}
		cost.Number -= nRate
	}
	return newNumberFormulaArg(nRate)
}

// AMORLINC function is provided for users of the French accounting system.
// The function calculates the prorated linear depreciation of an asset for a
// specified accounting period. The syntax of the function is:
//
//	AMORLINC(cost,date_purchased,first_period,salvage,period,rate,[basis])
func (fn *formulaFuncs) AMORLINC(argsList *list.List) formulaArg {
	if argsList.Len() != 6 && argsList.Len() != 7 {
		return newErrorFormulaArg(formulaErrorVALUE, "AMORLINC requires 6 or 7 arguments")
	}
	args := fn.prepareAmorArgs("AMORLINC", argsList)
	if args.Type != ArgList {
		return args
	}
	cost, datePurchased, firstPeriod, salvage, period, rate, basis := args.List[0], args.List[1], args.List[2], args.List[3], args.List[4], args.List[5], args.List[6]
	frac := yearFrac(datePurchased.Number, firstPeriod.Number, int(basis.Number))
	if frac.Type != ArgNumber {
		return frac
	}
	rate1 := frac.Number * cost.Number * rate.Number
	if period.Number == 0 {
		return newNumberFormulaArg(rate1)
	}
	rate2 := cost.Number * rate.Number
	delta := cost.Number - salvage.Number
	periods := int((delta - rate1) / rate2)
	if int(period.Number) <= periods {
		return newNumberFormulaArg(rate2)
	} else if int(period.Number)-1 == periods {
		return newNumberFormulaArg(delta - rate2*float64(periods) - math.Nextafter(rate1, rate1))
	}
	return newNumberFormulaArg(0)
}

// prepareCouponArgs checking and prepare arguments for the formula functions
// COUPDAYBS, COUPDAYS, COUPDAYSNC, COUPPCD, COUPNUM and COUPNCD.
func (fn *formulaFuncs) prepareCouponArgs(name string, argsList *list.List) formulaArg {
	if argsList.Len() != 3 && argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires 3 or 4 arguments", name))
	}
	args := fn.prepareDataValueArgs(2, argsList)
	if args.Type != ArgList {
		return args
	}
	settlement, maturity := args.List[0], args.List[1]
	if settlement.Number >= maturity.Number {
		return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s requires maturity > settlement", name))
	}
	frequency := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if frequency.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	if !validateFrequency(frequency.Number) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	basis := newNumberFormulaArg(0)
	if argsList.Len() == 4 {
		if basis = argsList.Back().Value.(formulaArg).ToNumber(); basis.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
	}
	return newListFormulaArg([]formulaArg{settlement, maturity, frequency, basis})
}

// is30BasisMethod determine if the financial day count basis rules is 30/360
// methods.
func is30BasisMethod(basis int) bool {
	return basis == 0 || basis == 4
}

// getDaysInMonthRange return the day by given year, month range and day count
// basis.
func getDaysInMonthRange(fromMonth, toMonth int) int {
	if fromMonth > toMonth {
		return 0
	}
	return (toMonth - fromMonth + 1) * 30
}

// getDayOnBasis returns the day by given date and day count basis.
func getDayOnBasis(y, m, d, basis int) int {
	if !is30BasisMethod(basis) {
		return d
	}
	day := d
	dim := getDaysInMonth(y, m)
	if day > 30 || d >= dim || day >= dim {
		day = 30
	}
	return day
}

// coupdays returns the number of days that base on date range and the day
// count basis to be used.
func coupdays(from, to time.Time, basis int) float64 {
	days := 0
	fromY, fromM, fromD := from.Date()
	toY, toM, toD := to.Date()
	fromDay, toDay := getDayOnBasis(fromY, int(fromM), fromD, basis), getDayOnBasis(toY, int(toM), toD, basis)
	if !is30BasisMethod(basis) {
		return (daysBetween(excelMinTime1900.Unix(), makeDate(toY, toM, toDay)) + 1) - (daysBetween(excelMinTime1900.Unix(), makeDate(fromY, fromM, fromDay)) + 1)
	}
	if basis == 0 {
		if (int(fromM) == 2 || fromDay < 30) && toD == 31 {
			toDay = 31
		}
	} else {
		if int(fromM) == 2 && fromDay == 30 {
			fromDay = getDaysInMonth(fromY, 2)
		}
		if int(toM) == 2 && toDay == 30 {
			toDay = getDaysInMonth(toY, 2)
		}
	}
	if fromY < toY || (fromY == toY && int(fromM) < int(toM)) {
		days = 30 - fromDay + 1
		fromD = 1
		fromDay = 1
		date := time.Date(fromY, fromM, fromD, 0, 0, 0, 0, time.UTC).AddDate(0, 1, 0)
		if date.Year() < toY {
			days += getDaysInMonthRange(int(date.Month()), 12)
			date = date.AddDate(0, 13-int(date.Month()), 0)
		}
		days += getDaysInMonthRange(int(date.Month()), int(toM)-1)
	}
	if days += toDay - fromDay; days > 0 {
		return float64(days)
	}
	return 0
}

// COUPDAYBS function calculates the number of days from the beginning of a
// coupon's period to the settlement date. The syntax of the function is:
//
//	COUPDAYBS(settlement,maturity,frequency,[basis])
func (fn *formulaFuncs) COUPDAYBS(argsList *list.List) formulaArg {
	args := fn.prepareCouponArgs("COUPDAYBS", argsList)
	if args.Type != ArgList {
		return args
	}
	settlement := timeFromExcelTime(args.List[0].Number, false)
	pcd := timeFromExcelTime(fn.COUPPCD(argsList).Number, false)
	return newNumberFormulaArg(coupdays(pcd, settlement, int(args.List[3].Number)))
}

// COUPDAYS function calculates the number of days in a coupon period that
// contains the settlement date. The syntax of the function is:
//
//	COUPDAYS(settlement,maturity,frequency,[basis])
func (fn *formulaFuncs) COUPDAYS(argsList *list.List) formulaArg {
	args := fn.prepareCouponArgs("COUPDAYS", argsList)
	if args.Type != ArgList {
		return args
	}
	freq := args.List[2].Number
	basis := int(args.List[3].Number)
	if basis == 1 {
		pcd := timeFromExcelTime(fn.COUPPCD(argsList).Number, false)
		next := pcd.AddDate(0, 12/int(freq), 0)
		return newNumberFormulaArg(coupdays(pcd, next, basis))
	}
	return newNumberFormulaArg(float64(getYearDays(0, basis)) / freq)
}

// COUPDAYSNC function calculates the number of days from the settlement date
// to the next coupon date. The syntax of the function is:
//
//	COUPDAYSNC(settlement,maturity,frequency,[basis])
func (fn *formulaFuncs) COUPDAYSNC(argsList *list.List) formulaArg {
	args := fn.prepareCouponArgs("COUPDAYSNC", argsList)
	if args.Type != ArgList {
		return args
	}
	settlement := timeFromExcelTime(args.List[0].Number, false)
	basis := int(args.List[3].Number)
	ncd := timeFromExcelTime(fn.COUPNCD(argsList).Number, false)
	return newNumberFormulaArg(coupdays(settlement, ncd, basis))
}

// coupons is an implementation of the formula functions COUPNCD and COUPPCD.
func (fn *formulaFuncs) coupons(name string, arg formulaArg) formulaArg {
	settlement := timeFromExcelTime(arg.List[0].Number, false)
	maturity := timeFromExcelTime(arg.List[1].Number, false)
	maturityDays := (maturity.Year()-settlement.Year())*12 + (int(maturity.Month()) - int(settlement.Month()))
	coupon := 12 / int(arg.List[2].Number)
	mod := maturityDays % coupon
	year := settlement.Year()
	month := int(settlement.Month())
	if mod == 0 && settlement.Day() >= maturity.Day() {
		month += coupon
	} else {
		month += mod
	}
	if name != "COUPNCD" {
		month -= coupon
	}
	if month > 11 {
		year++
		month -= 12
	} else if month < 0 {
		year--
		month += 12
	}
	day, lastDay := maturity.Day(), time.Date(year, time.Month(month), 1, 0, 0, 0, 0, time.UTC)
	days := getDaysInMonth(lastDay.Year(), int(lastDay.Month()))
	if getDaysInMonth(maturity.Year(), int(maturity.Month())) == maturity.Day() {
		day = days
	} else if day > 27 && day > days {
		day = days
	}
	return newNumberFormulaArg(daysBetween(excelMinTime1900.Unix(), makeDate(year, time.Month(month), day)) + 1)
}

// COUPNCD function calculates the number of coupons payable, between a
// security's settlement date and maturity date, rounded up to the nearest
// whole coupon. The syntax of the function is:
//
//	COUPNCD(settlement,maturity,frequency,[basis])
func (fn *formulaFuncs) COUPNCD(argsList *list.List) formulaArg {
	args := fn.prepareCouponArgs("COUPNCD", argsList)
	if args.Type != ArgList {
		return args
	}
	return fn.coupons("COUPNCD", args)
}

// COUPNUM function calculates the number of coupons payable, between a
// security's settlement date and maturity date, rounded up to the nearest
// whole coupon. The syntax of the function is:
//
//	COUPNUM(settlement,maturity,frequency,[basis])
func (fn *formulaFuncs) COUPNUM(argsList *list.List) formulaArg {
	args := fn.prepareCouponArgs("COUPNUM", argsList)
	if args.Type != ArgList {
		return args
	}
	frac := yearFrac(args.List[0].Number, args.List[1].Number, 0)
	return newNumberFormulaArg(math.Ceil(frac.Number * args.List[2].Number))
}

// COUPPCD function returns the previous coupon date, before the settlement
// date for a security. The syntax of the function is:
//
//	COUPPCD(settlement,maturity,frequency,[basis])
func (fn *formulaFuncs) COUPPCD(argsList *list.List) formulaArg {
	args := fn.prepareCouponArgs("COUPPCD", argsList)
	if args.Type != ArgList {
		return args
	}
	return fn.coupons("COUPPCD", args)
}

// CUMIPMT function calculates the cumulative interest paid on a loan or
// investment, between two specified periods. The syntax of the function is:
//
//	CUMIPMT(rate,nper,pv,start_period,end_period,type)
func (fn *formulaFuncs) CUMIPMT(argsList *list.List) formulaArg {
	return fn.cumip("CUMIPMT", argsList)
}

// CUMPRINC function calculates the cumulative payment on the principal of a
// loan or investment, between two specified periods. The syntax of the
// function is:
//
//	CUMPRINC(rate,nper,pv,start_period,end_period,type)
func (fn *formulaFuncs) CUMPRINC(argsList *list.List) formulaArg {
	return fn.cumip("CUMPRINC", argsList)
}

// cumip is an implementation of the formula functions CUMIPMT and CUMPRINC.
func (fn *formulaFuncs) cumip(name string, argsList *list.List) formulaArg {
	if argsList.Len() != 6 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires 6 arguments", name))
	}
	rate := argsList.Front().Value.(formulaArg).ToNumber()
	if rate.Type != ArgNumber {
		return rate
	}
	nper := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if nper.Type != ArgNumber {
		return nper
	}
	pv := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if pv.Type != ArgNumber {
		return pv
	}
	start := argsList.Back().Prev().Prev().Value.(formulaArg).ToNumber()
	if start.Type != ArgNumber {
		return start
	}
	end := argsList.Back().Prev().Value.(formulaArg).ToNumber()
	if end.Type != ArgNumber {
		return end
	}
	typ := argsList.Back().Value.(formulaArg).ToNumber()
	if typ.Type != ArgNumber {
		return typ
	}
	if typ.Number != 0 && typ.Number != 1 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	if start.Number < 1 || start.Number > end.Number {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	num := 0.0
	for per := start.Number; per <= end.Number; per++ {
		args := list.New().Init()
		args.PushBack(rate)
		args.PushBack(newNumberFormulaArg(per))
		args.PushBack(nper)
		args.PushBack(pv)
		args.PushBack(newNumberFormulaArg(0))
		args.PushBack(typ)
		if name == "CUMIPMT" {
			num += fn.IPMT(args).Number
			continue
		}
		num += fn.PPMT(args).Number
	}
	return newNumberFormulaArg(num)
}

// calcDbArgsCompare implements common arguments' comparison for DB and DDB.
func calcDbArgsCompare(cost, salvage, life, period formulaArg) bool {
	return (cost.Number <= 0) || ((salvage.Number / cost.Number) < 0) || (life.Number <= 0) || (period.Number < 1)
}

// DB function calculates the depreciation of an asset, using the Fixed
// Declining Balance Method, for each period of the asset's lifetime. The
// syntax of the function is:
//
//	DB(cost,salvage,life,period,[month])
func (fn *formulaFuncs) DB(argsList *list.List) formulaArg {
	if argsList.Len() < 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "DB requires at least 4 arguments")
	}
	if argsList.Len() > 5 {
		return newErrorFormulaArg(formulaErrorVALUE, "DB allows at most 5 arguments")
	}
	cost := argsList.Front().Value.(formulaArg).ToNumber()
	if cost.Type != ArgNumber {
		return cost
	}
	salvage := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if salvage.Type != ArgNumber {
		return salvage
	}
	life := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if life.Type != ArgNumber {
		return life
	}
	period := argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber()
	if period.Type != ArgNumber {
		return period
	}
	month := newNumberFormulaArg(12)
	if argsList.Len() == 5 {
		if month = argsList.Back().Value.(formulaArg).ToNumber(); month.Type != ArgNumber {
			return month
		}
	}
	if cost.Number == 0 {
		return newNumberFormulaArg(0)
	}
	if calcDbArgsCompare(cost, salvage, life, period) || (month.Number < 1) {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	dr := 1 - math.Pow(salvage.Number/cost.Number, 1/life.Number)
	dr = math.Round(dr*1000) / 1000
	pd, depreciation := 0.0, 0.0
	for per := 1; per <= int(period.Number); per++ {
		if per == 1 {
			depreciation = cost.Number * dr * month.Number / 12
		} else if per == int(life.Number+1) {
			depreciation = (cost.Number - pd) * dr * (12 - month.Number) / 12
		} else {
			depreciation = (cost.Number - pd) * dr
		}
		pd += depreciation
	}
	return newNumberFormulaArg(depreciation)
}

// DDB function calculates the depreciation of an asset, using the Double
// Declining Balance Method, or another specified depreciation rate. The
// syntax of the function is:
//
//	DDB(cost,salvage,life,period,[factor])
func (fn *formulaFuncs) DDB(argsList *list.List) formulaArg {
	if argsList.Len() < 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "DDB requires at least 4 arguments")
	}
	if argsList.Len() > 5 {
		return newErrorFormulaArg(formulaErrorVALUE, "DDB allows at most 5 arguments")
	}
	cost := argsList.Front().Value.(formulaArg).ToNumber()
	if cost.Type != ArgNumber {
		return cost
	}
	salvage := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if salvage.Type != ArgNumber {
		return salvage
	}
	life := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if life.Type != ArgNumber {
		return life
	}
	period := argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber()
	if period.Type != ArgNumber {
		return period
	}
	factor := newNumberFormulaArg(2)
	if argsList.Len() == 5 {
		if factor = argsList.Back().Value.(formulaArg).ToNumber(); factor.Type != ArgNumber {
			return factor
		}
	}
	if cost.Number == 0 {
		return newNumberFormulaArg(0)
	}
	if calcDbArgsCompare(cost, salvage, life, period) || (factor.Number <= 0.0) || (period.Number > life.Number) {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	pd, depreciation := 0.0, 0.0
	for per := 1; per <= int(period.Number); per++ {
		depreciation = math.Min((cost.Number-pd)*(factor.Number/life.Number), cost.Number-salvage.Number-pd)
		pd += depreciation
	}
	return newNumberFormulaArg(depreciation)
}

// prepareDataValueArgs convert first N arguments to data value for the
// formula functions.
func (fn *formulaFuncs) prepareDataValueArgs(n int, argsList *list.List) formulaArg {
	l := list.New()
	var dataValues []formulaArg
	getDateValue := func(arg formulaArg, l *list.List) formulaArg {
		switch arg.Type {
		case ArgNumber:
			break
		case ArgString:
			num := arg.ToNumber()
			if num.Type == ArgNumber {
				arg = num
				break
			}
			l.Init()
			l.PushBack(arg)
			arg = fn.DATEVALUE(l)
			if arg.Type == ArgError {
				return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
			}
		default:
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
		return arg
	}
	for i, arg := 0, argsList.Front(); i < n; arg = arg.Next() {
		dataValue := getDateValue(arg.Value.(formulaArg), l)
		if dataValue.Type != ArgNumber {
			return dataValue
		}
		dataValues = append(dataValues, dataValue)
		i++
	}
	return newListFormulaArg(dataValues)
}

// discIntrate is an implementation of the formula functions DISC and INTRATE.
func (fn *formulaFuncs) discIntrate(name string, argsList *list.List) formulaArg {
	if argsList.Len() != 4 && argsList.Len() != 5 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires 4 or 5 arguments", name))
	}
	args := fn.prepareDataValueArgs(2, argsList)
	if args.Type != ArgList {
		return args
	}
	settlement, maturity, argName := args.List[0], args.List[1], "pr"
	if maturity.Number <= settlement.Number {
		return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s requires maturity > settlement", name))
	}
	prInvestment := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if prInvestment.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	if prInvestment.Number <= 0 {
		if name == "INTRATE" {
			argName = "investment"
		}
		return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s requires %s > 0", name, argName))
	}
	redemption := argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber()
	if redemption.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	if redemption.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s requires redemption > 0", name))
	}
	basis := newNumberFormulaArg(0)
	if argsList.Len() == 5 {
		if basis = argsList.Back().Value.(formulaArg).ToNumber(); basis.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
	}
	frac := yearFrac(settlement.Number, maturity.Number, int(basis.Number))
	if frac.Type != ArgNumber {
		return frac
	}
	if name == "INTRATE" {
		return newNumberFormulaArg((redemption.Number - prInvestment.Number) / prInvestment.Number / frac.Number)
	}
	return newNumberFormulaArg((redemption.Number - prInvestment.Number) / redemption.Number / frac.Number)
}

// DISC function calculates the Discount Rate for a security. The syntax of
// the function is:
//
//	DISC(settlement,maturity,pr,redemption,[basis])
func (fn *formulaFuncs) DISC(argsList *list.List) formulaArg {
	return fn.discIntrate("DISC", argsList)
}

// DOLLAR function rounds a supplied number to a specified number of decimal
// places and then converts this into a text string with a currency format. The
// syntax of the function is:
//
//	DOLLAR(number,[decimals])
func (fn *formulaFuncs) DOLLAR(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "DOLLAR requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "DOLLAR requires 1 or 2 arguments")
	}
	numArg := argsList.Front().Value.(formulaArg)
	n := numArg.ToNumber()
	if n.Type != ArgNumber {
		return n
	}
	decimals, dot, value := 2, ".", numArg.Value()
	if argsList.Len() == 2 {
		d := argsList.Back().Value.(formulaArg).ToNumber()
		if d.Type != ArgNumber {
			return d
		}
		if d.Number < 0 {
			value = strconv.FormatFloat(fn.round(n.Number, d.Number, down), 'f', -1, 64)
		}
		if d.Number >= 128 {
			return newErrorFormulaArg(formulaErrorVALUE, "decimal value should be less than 128")
		}
		if decimals = int(d.Number); decimals < 0 {
			decimals, dot = 0, ""
		}
	}
	symbol := map[CultureName]string{
		CultureNameUnknown: "$",
		CultureNameEnUS:    "$",
		CultureNameJaJP:    "¥",
		CultureNameKoKR:    "\u20a9",
		CultureNameZhCN:    "¥",
		CultureNameZhTW:    "NT$",
	}[fn.f.options.CultureInfo]
	numFmtCode := fmt.Sprintf("%s#,##0%s%s;(%s#,##0%s%s)",
		symbol, dot, strings.Repeat("0", decimals), symbol, dot, strings.Repeat("0", decimals))
	return newStringFormulaArg(format(value, numFmtCode, false, CellTypeNumber, nil))
}

// DOLLARDE function converts a dollar value in fractional notation, into a
// dollar value expressed as a decimal. The syntax of the function is:
//
//	DOLLARDE(fractional_dollar,fraction)
func (fn *formulaFuncs) DOLLARDE(argsList *list.List) formulaArg {
	return fn.dollar("DOLLARDE", argsList)
}

// DOLLARFR function converts a dollar value in decimal notation, into a
// dollar value that is expressed in fractional notation. The syntax of the
// function is:
//
//	DOLLARFR(decimal_dollar,fraction)
func (fn *formulaFuncs) DOLLARFR(argsList *list.List) formulaArg {
	return fn.dollar("DOLLARFR", argsList)
}

// dollar is an implementation of the formula functions DOLLARDE and DOLLARFR.
func (fn *formulaFuncs) dollar(name string, argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires 2 arguments", name))
	}
	dollar := argsList.Front().Value.(formulaArg).ToNumber()
	if dollar.Type != ArgNumber {
		return dollar
	}
	frac := argsList.Back().Value.(formulaArg).ToNumber()
	if frac.Type != ArgNumber {
		return frac
	}
	if frac.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if frac.Number == 0 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	cents := math.Mod(dollar.Number, 1)
	if name == "DOLLARDE" {
		cents /= frac.Number
		cents *= math.Pow(10, math.Ceil(math.Log10(frac.Number)))
	} else {
		cents *= frac.Number
		cents *= math.Pow(10, -math.Ceil(math.Log10(frac.Number)))
	}
	return newNumberFormulaArg(math.Floor(dollar.Number) + cents)
}

// prepareDurationArgs checking and prepare arguments for the formula
// functions DURATION and MDURATION.
func (fn *formulaFuncs) prepareDurationArgs(name string, argsList *list.List) formulaArg {
	if argsList.Len() != 5 && argsList.Len() != 6 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires 5 or 6 arguments", name))
	}
	args := fn.prepareDataValueArgs(2, argsList)
	if args.Type != ArgList {
		return args
	}
	settlement, maturity := args.List[0], args.List[1]
	if settlement.Number >= maturity.Number {
		return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s requires maturity > settlement", name))
	}
	coupon := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if coupon.Type != ArgNumber {
		return coupon
	}
	if coupon.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s requires coupon >= 0", name))
	}
	yld := argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber()
	if yld.Type != ArgNumber {
		return yld
	}
	if yld.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s requires yld >= 0", name))
	}
	frequency := argsList.Front().Next().Next().Next().Next().Value.(formulaArg).ToNumber()
	if frequency.Type != ArgNumber {
		return frequency
	}
	if !validateFrequency(frequency.Number) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	basis := newNumberFormulaArg(0)
	if argsList.Len() == 6 {
		if basis = argsList.Back().Value.(formulaArg).ToNumber(); basis.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
	}
	return newListFormulaArg([]formulaArg{settlement, maturity, coupon, yld, frequency, basis})
}

// duration is an implementation of the formula function DURATION.
func (fn *formulaFuncs) duration(settlement, maturity, coupon, yld, frequency, basis formulaArg) formulaArg {
	frac := yearFrac(settlement.Number, maturity.Number, int(basis.Number))
	if frac.Type != ArgNumber {
		return frac
	}
	argumments := list.New().Init()
	argumments.PushBack(settlement)
	argumments.PushBack(maturity)
	argumments.PushBack(frequency)
	argumments.PushBack(basis)
	coups := fn.COUPNUM(argumments)
	duration := 0.0
	p := 0.0
	coupon.Number *= 100 / frequency.Number
	yld.Number /= frequency.Number
	yld.Number++
	diff := frac.Number*frequency.Number - coups.Number
	for t := 1.0; t < coups.Number; t++ {
		tDiff := t + diff
		add := coupon.Number / math.Pow(yld.Number, tDiff)
		p += add
		duration += tDiff * add
	}
	add := (coupon.Number + 100) / math.Pow(yld.Number, coups.Number+diff)
	p += add
	duration += (coups.Number + diff) * add
	duration /= p
	duration /= frequency.Number
	return newNumberFormulaArg(duration)
}

// DURATION function calculates the Duration (specifically, the Macaulay
// Duration) of a security that pays periodic interest, assuming a par value
// of $100. The syntax of the function is:
//
//	DURATION(settlement,maturity,coupon,yld,frequency,[basis])
func (fn *formulaFuncs) DURATION(argsList *list.List) formulaArg {
	args := fn.prepareDurationArgs("DURATION", argsList)
	if args.Type != ArgList {
		return args
	}
	return fn.duration(args.List[0], args.List[1], args.List[2], args.List[3], args.List[4], args.List[5])
}

// EFFECT function returns the effective annual interest rate for a given
// nominal interest rate and number of compounding periods per year. The
// syntax of the function is:
//
//	EFFECT(nominal_rate,npery)
func (fn *formulaFuncs) EFFECT(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "EFFECT requires 2 arguments")
	}
	rate := argsList.Front().Value.(formulaArg).ToNumber()
	if rate.Type != ArgNumber {
		return rate
	}
	npery := argsList.Back().Value.(formulaArg).ToNumber()
	if npery.Type != ArgNumber {
		return npery
	}
	if rate.Number <= 0 || npery.Number < 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(math.Pow(1+rate.Number/npery.Number, npery.Number) - 1)
}

// EUROCONVERT function convert a number to euro or from euro to a
// participating currency. You can also use it to convert a number from one
// participating currency to another by using the euro as an intermediary
// (triangulation). The syntax of the function is:
//
//	EUROCONVERT(number,sourcecurrency,targetcurrency[,fullprecision,triangulationprecision])
func (fn *formulaFuncs) EUROCONVERT(argsList *list.List) formulaArg {
	if argsList.Len() < 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "EUROCONVERT requires at least 3 arguments")
	}
	if argsList.Len() > 5 {
		return newErrorFormulaArg(formulaErrorVALUE, "EUROCONVERT allows at most 5 arguments")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type != ArgNumber {
		return number
	}
	sourceCurrency := argsList.Front().Next().Value.(formulaArg).Value()
	targetCurrency := argsList.Front().Next().Next().Value.(formulaArg).Value()
	fullPrec, triangulationPrec := newBoolFormulaArg(false), newNumberFormulaArg(0)
	if argsList.Len() >= 4 {
		if fullPrec = argsList.Front().Next().Next().Next().Value.(formulaArg).ToBool(); fullPrec.Type != ArgNumber {
			return fullPrec
		}
	}
	if argsList.Len() == 5 {
		if triangulationPrec = argsList.Back().Value.(formulaArg).ToNumber(); triangulationPrec.Type != ArgNumber {
			return triangulationPrec
		}
	}
	convertTable := map[string][]float64{
		"EUR": {1.0, 2},
		"ATS": {13.7603, 2},
		"BEF": {40.3399, 0},
		"DEM": {1.95583, 2},
		"ESP": {166.386, 0},
		"FIM": {5.94573, 2},
		"FRF": {6.55957, 2},
		"IEP": {0.787564, 2},
		"ITL": {1936.27, 0},
		"LUF": {40.3399, 0},
		"NLG": {2.20371, 2},
		"PTE": {200.482, 2},
		"GRD": {340.750, 2},
		"SIT": {239.640, 2},
		"MTL": {0.429300, 2},
		"CYP": {0.585274, 2},
		"SKK": {30.1260, 2},
		"EEK": {15.6466, 2},
		"LVL": {0.702804, 2},
		"LTL": {3.45280, 2},
	}
	source, ok := convertTable[sourceCurrency]
	if !ok {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	target, ok := convertTable[targetCurrency]
	if !ok {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	if sourceCurrency == targetCurrency {
		return number
	}
	var res float64
	if sourceCurrency == "EUR" {
		res = number.Number * target[0]
	} else {
		intermediate := number.Number / source[0]
		if triangulationPrec.Number != 0 {
			ratio := math.Pow(10, triangulationPrec.Number)
			intermediate = math.Round(intermediate*ratio) / ratio
		}
		res = intermediate * target[0]
	}
	if fullPrec.Number != 1 {
		ratio := math.Pow(10, target[1])
		res = math.Round(res*ratio) / ratio
	}
	return newNumberFormulaArg(res)
}

// FV function calculates the Future Value of an investment with periodic
// constant payments and a constant interest rate. The syntax of the function
// is:
//
//	FV(rate,nper,[pmt],[pv],[type])
func (fn *formulaFuncs) FV(argsList *list.List) formulaArg {
	if argsList.Len() < 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "FV requires at least 3 arguments")
	}
	if argsList.Len() > 5 {
		return newErrorFormulaArg(formulaErrorVALUE, "FV allows at most 5 arguments")
	}
	rate := argsList.Front().Value.(formulaArg).ToNumber()
	if rate.Type != ArgNumber {
		return rate
	}
	nper := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if nper.Type != ArgNumber {
		return nper
	}
	pmt := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if pmt.Type != ArgNumber {
		return pmt
	}
	pv, typ := newNumberFormulaArg(0), newNumberFormulaArg(0)
	if argsList.Len() >= 4 {
		if pv = argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber(); pv.Type != ArgNumber {
			return pv
		}
	}
	if argsList.Len() == 5 {
		if typ = argsList.Back().Value.(formulaArg).ToNumber(); typ.Type != ArgNumber {
			return typ
		}
	}
	if typ.Number != 0 && typ.Number != 1 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	if rate.Number != 0 {
		return newNumberFormulaArg(-pv.Number*math.Pow(1+rate.Number, nper.Number) - pmt.Number*(1+rate.Number*typ.Number)*(math.Pow(1+rate.Number, nper.Number)-1)/rate.Number)
	}
	return newNumberFormulaArg(-pv.Number - pmt.Number*nper.Number)
}

// FVSCHEDULE function calculates the Future Value of an investment with a
// variable interest rate. The syntax of the function is:
//
//	FVSCHEDULE(principal,schedule)
func (fn *formulaFuncs) FVSCHEDULE(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "FVSCHEDULE requires 2 arguments")
	}
	pri := argsList.Front().Value.(formulaArg).ToNumber()
	if pri.Type != ArgNumber {
		return pri
	}
	principal := pri.Number
	for _, arg := range argsList.Back().Value.(formulaArg).ToList() {
		if arg.Value() == "" {
			continue
		}
		rate := arg.ToNumber()
		if rate.Type != ArgNumber {
			return rate
		}
		principal *= 1 + rate.Number
	}
	return newNumberFormulaArg(principal)
}

// INTRATE function calculates the interest rate for a fully invested
// security. The syntax of the function is:
//
//	INTRATE(settlement,maturity,investment,redemption,[basis])
func (fn *formulaFuncs) INTRATE(argsList *list.List) formulaArg {
	return fn.discIntrate("INTRATE", argsList)
}

// IPMT function calculates the interest payment, during a specific period of a
// loan or investment that is paid in constant periodic payments, with a
// constant interest rate. The syntax of the function is:
//
//	IPMT(rate,per,nper,pv,[fv],[type])
func (fn *formulaFuncs) IPMT(argsList *list.List) formulaArg {
	return fn.ipmt("IPMT", argsList)
}

// calcIpmt is part of the implementation ipmt.
func calcIpmt(name string, typ, per, pmt, pv, rate formulaArg) formulaArg {
	capital, interest, principal := pv.Number, 0.0, 0.0
	for i := 1; i <= int(per.Number); i++ {
		if typ.Number != 0 && i == 1 {
			interest = 0
		} else {
			interest = -capital * rate.Number
		}
		principal = pmt.Number - interest
		capital += principal
	}
	if name == "IPMT" {
		return newNumberFormulaArg(interest)
	}
	return newNumberFormulaArg(principal)
}

// ipmt is an implementation of the formula functions IPMT and PPMT.
func (fn *formulaFuncs) ipmt(name string, argsList *list.List) formulaArg {
	if argsList.Len() < 4 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires at least 4 arguments", name))
	}
	if argsList.Len() > 6 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s allows at most 6 arguments", name))
	}
	rate := argsList.Front().Value.(formulaArg).ToNumber()
	if rate.Type != ArgNumber {
		return rate
	}
	per := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if per.Type != ArgNumber {
		return per
	}
	nper := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if nper.Type != ArgNumber {
		return nper
	}
	pv := argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber()
	if pv.Type != ArgNumber {
		return pv
	}
	fv, typ := newNumberFormulaArg(0), newNumberFormulaArg(0)
	if argsList.Len() >= 5 {
		if fv = argsList.Front().Next().Next().Next().Next().Value.(formulaArg).ToNumber(); fv.Type != ArgNumber {
			return fv
		}
	}
	if argsList.Len() == 6 {
		if typ = argsList.Back().Value.(formulaArg).ToNumber(); typ.Type != ArgNumber {
			return typ
		}
	}
	if typ.Number != 0 && typ.Number != 1 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	if per.Number <= 0 || per.Number > nper.Number {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	args := list.New().Init()
	args.PushBack(rate)
	args.PushBack(nper)
	args.PushBack(pv)
	args.PushBack(fv)
	args.PushBack(typ)
	pmt := fn.PMT(args)
	return calcIpmt(name, typ, per, pmt, pv, rate)
}

// IRR function returns the Internal Rate of Return for a supplied series of
// periodic cash flows (i.e. an initial investment value and a series of net
// income values). The syntax of the function is:
//
//	IRR(values,[guess])
func (fn *formulaFuncs) IRR(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IRR requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "IRR allows at most 2 arguments")
	}
	values, guess := argsList.Front().Value.(formulaArg).ToList(), newNumberFormulaArg(0.1)
	if argsList.Len() > 1 {
		if guess = argsList.Back().Value.(formulaArg).ToNumber(); guess.Type != ArgNumber {
			return guess
		}
	}
	x1, x2 := newNumberFormulaArg(0), guess
	args := list.New().Init()
	args.PushBack(x1)
	for _, v := range values {
		args.PushBack(v)
	}
	f1 := fn.NPV(args)
	args.Front().Value = x2
	f2 := fn.NPV(args)
	for i := 0; i < maxFinancialIterations; i++ {
		if f1.Number*f2.Number < 0 {
			break
		}
		if math.Abs(f1.Number) < math.Abs(f2.Number) {
			x1.Number += 1.6 * (x1.Number - x2.Number)
			args.Front().Value = x1
			f1 = fn.NPV(args)
			continue
		}
		x2.Number += 1.6 * (x2.Number - x1.Number)
		args.Front().Value = x2
		f2 = fn.NPV(args)
	}
	if f1.Number*f2.Number > 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	args.Front().Value = x1
	f := fn.NPV(args)
	var rtb, dx, xMid, fMid float64
	if f.Number < 0 {
		rtb = x1.Number
		dx = x2.Number - x1.Number
	} else {
		rtb = x2.Number
		dx = x1.Number - x2.Number
	}
	for i := 0; i < maxFinancialIterations; i++ {
		dx *= 0.5
		xMid = rtb + dx
		args.Front().Value = newNumberFormulaArg(xMid)
		fMid = fn.NPV(args).Number
		if fMid <= 0 {
			rtb = xMid
		}
		if math.Abs(fMid) < financialPrecision || math.Abs(dx) < financialPrecision {
			break
		}
	}
	return newNumberFormulaArg(xMid)
}

// ISPMT function calculates the interest paid during a specific period of a
// loan or investment. The syntax of the function is:
//
//	ISPMT(rate,per,nper,pv)
func (fn *formulaFuncs) ISPMT(argsList *list.List) formulaArg {
	if argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "ISPMT requires 4 arguments")
	}
	rate := argsList.Front().Value.(formulaArg).ToNumber()
	if rate.Type != ArgNumber {
		return rate
	}
	per := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if per.Type != ArgNumber {
		return per
	}
	nper := argsList.Back().Prev().Value.(formulaArg).ToNumber()
	if nper.Type != ArgNumber {
		return nper
	}
	pv := argsList.Back().Value.(formulaArg).ToNumber()
	if pv.Type != ArgNumber {
		return pv
	}
	pr, payment, num := pv.Number, pv.Number/nper.Number, 0.0
	for i := 0; i <= int(per.Number); i++ {
		num = rate.Number * pr * -1
		pr -= payment
		if i == int(nper.Number) {
			num = 0
		}
	}
	return newNumberFormulaArg(num)
}

// MDURATION function calculates the Modified Macaulay Duration of a security
// that pays periodic interest, assuming a par value of $100. The syntax of
// the function is:
//
//	MDURATION(settlement,maturity,coupon,yld,frequency,[basis])
func (fn *formulaFuncs) MDURATION(argsList *list.List) formulaArg {
	args := fn.prepareDurationArgs("MDURATION", argsList)
	if args.Type != ArgList {
		return args
	}
	duration := fn.duration(args.List[0], args.List[1], args.List[2], args.List[3], args.List[4], args.List[5])
	if duration.Type != ArgNumber {
		return duration
	}
	return newNumberFormulaArg(duration.Number / (1 + args.List[3].Number/args.List[4].Number))
}

// MIRR function returns the Modified Internal Rate of Return for a supplied
// series of periodic cash flows (i.e. a set of values, which includes an
// initial investment value and a series of net income values). The syntax of
// the function is:
//
//	MIRR(values,finance_rate,reinvest_rate)
func (fn *formulaFuncs) MIRR(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "MIRR requires 3 arguments")
	}
	values := argsList.Front().Value.(formulaArg).ToList()
	financeRate := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if financeRate.Type != ArgNumber {
		return financeRate
	}
	reinvestRate := argsList.Back().Value.(formulaArg).ToNumber()
	if reinvestRate.Type != ArgNumber {
		return reinvestRate
	}
	n, fr, rr, npvPos, npvNeg := len(values), 1+financeRate.Number, 1+reinvestRate.Number, 0.0, 0.0
	for i, v := range values {
		val := v.ToNumber()
		if val.Number >= 0 {
			npvPos += val.Number / math.Pow(rr, float64(i))
			continue
		}
		npvNeg += val.Number / math.Pow(fr, float64(i))
	}
	if npvNeg == 0 || npvPos == 0 || reinvestRate.Number <= -1 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	return newNumberFormulaArg(math.Pow(-npvPos*math.Pow(rr, float64(n))/(npvNeg*rr), 1/(float64(n)-1)) - 1)
}

// NOMINAL function returns the nominal interest rate for a given effective
// interest rate and number of compounding periods per year. The syntax of
// the function is:
//
//	NOMINAL(effect_rate,npery)
func (fn *formulaFuncs) NOMINAL(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "NOMINAL requires 2 arguments")
	}
	rate := argsList.Front().Value.(formulaArg).ToNumber()
	if rate.Type != ArgNumber {
		return rate
	}
	npery := argsList.Back().Value.(formulaArg).ToNumber()
	if npery.Type != ArgNumber {
		return npery
	}
	if rate.Number <= 0 || npery.Number < 1 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(npery.Number * (math.Pow(rate.Number+1, 1/npery.Number) - 1))
}

// NPER function calculates the number of periods required to pay off a loan,
// for a constant periodic payment and a constant interest rate. The syntax
// of the function is:
//
//	NPER(rate,pmt,pv,[fv],[type])
func (fn *formulaFuncs) NPER(argsList *list.List) formulaArg {
	if argsList.Len() < 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "NPER requires at least 3 arguments")
	}
	if argsList.Len() > 5 {
		return newErrorFormulaArg(formulaErrorVALUE, "NPER allows at most 5 arguments")
	}
	rate := argsList.Front().Value.(formulaArg).ToNumber()
	if rate.Type != ArgNumber {
		return rate
	}
	pmt := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if pmt.Type != ArgNumber {
		return pmt
	}
	pv := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if pv.Type != ArgNumber {
		return pv
	}
	fv, typ := newNumberFormulaArg(0), newNumberFormulaArg(0)
	if argsList.Len() >= 4 {
		if fv = argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber(); fv.Type != ArgNumber {
			return fv
		}
	}
	if argsList.Len() == 5 {
		if typ = argsList.Back().Value.(formulaArg).ToNumber(); typ.Type != ArgNumber {
			return typ
		}
	}
	if typ.Number != 0 && typ.Number != 1 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	if pmt.Number == 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if rate.Number != 0 {
		p := math.Log((pmt.Number*(1+rate.Number*typ.Number)/rate.Number-fv.Number)/(pv.Number+pmt.Number*(1+rate.Number*typ.Number)/rate.Number)) / math.Log(1+rate.Number)
		return newNumberFormulaArg(p)
	}
	return newNumberFormulaArg((-pv.Number - fv.Number) / pmt.Number)
}

// NPV function calculates the Net Present Value of an investment, based on a
// supplied discount rate, and a series of future payments and income. The
// syntax of the function is:
//
//	NPV(rate,value1,[value2],[value3],...)
func (fn *formulaFuncs) NPV(argsList *list.List) formulaArg {
	if argsList.Len() < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "NPV requires at least 2 arguments")
	}
	rate := argsList.Front().Value.(formulaArg).ToNumber()
	if rate.Type != ArgNumber {
		return rate
	}
	val, i := 0.0, 1
	for arg := argsList.Front().Next(); arg != nil; arg = arg.Next() {
		num := arg.Value.(formulaArg).ToNumber()
		if num.Type != ArgNumber {
			continue
		}
		val += num.Number / math.Pow(1+rate.Number, float64(i))
		i++
	}
	return newNumberFormulaArg(val)
}

// aggrBetween is a part of implementation of the formula function ODDFPRICE.
func aggrBetween(startPeriod, endPeriod float64, initialValue []float64, f func(acc []float64, index float64) []float64) []float64 {
	var s []float64
	if startPeriod <= endPeriod {
		for i := startPeriod; i <= endPeriod; i++ {
			s = append(s, i)
		}
	} else {
		for i := startPeriod; i >= endPeriod; i-- {
			s = append(s, i)
		}
	}
	return fold(f, initialValue, s)
}

// fold is a part of implementation of the formula function ODDFPRICE.
func fold(f func(acc []float64, index float64) []float64, state []float64, source []float64) []float64 {
	length, value := len(source), state
	for index := 0; length > index; index++ {
		value = f(value, source[index])
	}
	return value
}

// changeMonth is a part of implementation of the formula function ODDFPRICE.
func changeMonth(date time.Time, numMonths float64, returnLastMonth bool) time.Time {
	offsetDay := 0
	if returnLastMonth && date.Day() == getDaysInMonth(date.Year(), int(date.Month())) {
		offsetDay--
	}
	newDate := date.AddDate(0, int(numMonths), offsetDay)
	if returnLastMonth {
		lastDay := getDaysInMonth(newDate.Year(), int(newDate.Month()))
		return timeFromExcelTime(daysBetween(excelMinTime1900.Unix(), makeDate(newDate.Year(), newDate.Month(), lastDay))+1, false)
	}
	return newDate
}

// datesAggregate is a part of implementation of the formula function
// ODDFPRICE.
func datesAggregate(startDate, endDate time.Time, numMonths float64, f func(pcd, ncd time.Time) float64, acc float64, returnLastMonth bool) (time.Time, time.Time, float64) {
	frontDate, trailingDate := startDate, endDate
	s1 := frontDate.After(endDate) || frontDate.Equal(endDate)
	s2 := endDate.After(frontDate) || endDate.Equal(frontDate)
	stop := s2
	if numMonths > 0 {
		stop = s1
	}
	for !stop {
		trailingDate = frontDate
		frontDate = changeMonth(frontDate, numMonths, returnLastMonth)
		fn := f(frontDate, trailingDate)
		acc += fn
		s1 = frontDate.After(endDate) || frontDate.Equal(endDate)
		s2 = endDate.After(frontDate) || endDate.Equal(frontDate)
		stop = s2
		if numMonths > 0 {
			stop = s1
		}
	}
	return frontDate, trailingDate, acc
}

// coupNumber is a part of implementation of the formula function ODDFPRICE.
func coupNumber(maturity, settlement, numMonths float64) float64 {
	maturityTime, settlementTime := timeFromExcelTime(maturity, false), timeFromExcelTime(settlement, false)
	my, mm, md := maturityTime.Year(), maturityTime.Month(), maturityTime.Day()
	sy, sm, sd := settlementTime.Year(), settlementTime.Month(), settlementTime.Day()
	couponsTemp, endOfMonthTemp := 0.0, getDaysInMonth(my, int(mm)) == md
	endOfMonth := endOfMonthTemp
	if !endOfMonthTemp && mm != 2 && md > 28 && md < getDaysInMonth(my, int(mm)) {
		endOfMonth = getDaysInMonth(sy, int(sm)) == sd
	}
	startDate := changeMonth(settlementTime, 0, endOfMonth)
	coupons := couponsTemp
	if startDate.After(settlementTime) {
		coupons++
	}
	date := changeMonth(startDate, numMonths, endOfMonth)
	f := func(pcd, ncd time.Time) float64 {
		return 1
	}
	_, _, result := datesAggregate(date, maturityTime, numMonths, f, coupons, endOfMonth)
	return result
}

// prepareOddYldOrPrArg checking and prepare yield or price arguments for the
// formula functions ODDFPRICE, ODDFYIELD, ODDLPRICE and ODDLYIELD.
func prepareOddYldOrPrArg(name string, arg formulaArg) formulaArg {
	yldOrPr := arg.ToNumber()
	if yldOrPr.Type != ArgNumber {
		return yldOrPr
	}
	if (name == "ODDFPRICE" || name == "ODDLPRICE") && yldOrPr.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s requires yld >= 0", name))
	}
	if (name == "ODDFYIELD" || name == "ODDLYIELD") && yldOrPr.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s requires pr > 0", name))
	}
	return yldOrPr
}

// prepareOddfArgs checking and prepare arguments for the formula
// functions ODDFPRICE and ODDFYIELD.
func (fn *formulaFuncs) prepareOddfArgs(name string, argsList *list.List) formulaArg {
	dateValues := fn.prepareDataValueArgs(4, argsList)
	if dateValues.Type != ArgList {
		return dateValues
	}
	settlement, maturity, issue, firstCoupon := dateValues.List[0], dateValues.List[1], dateValues.List[2], dateValues.List[3]
	if issue.Number >= settlement.Number {
		return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s requires settlement > issue", name))
	}
	if settlement.Number >= firstCoupon.Number {
		return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s requires first_coupon > settlement", name))
	}
	if firstCoupon.Number >= maturity.Number {
		return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s requires maturity > first_coupon", name))
	}
	rate := argsList.Front().Next().Next().Next().Next().Value.(formulaArg).ToNumber()
	if rate.Type != ArgNumber {
		return rate
	}
	if rate.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s requires rate >= 0", name))
	}
	yldOrPr := prepareOddYldOrPrArg(name, argsList.Front().Next().Next().Next().Next().Next().Value.(formulaArg))
	if yldOrPr.Type != ArgNumber {
		return yldOrPr
	}
	redemption := argsList.Front().Next().Next().Next().Next().Next().Next().Value.(formulaArg).ToNumber()
	if redemption.Type != ArgNumber {
		return redemption
	}
	if redemption.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s requires redemption > 0", name))
	}
	frequency := argsList.Front().Next().Next().Next().Next().Next().Next().Next().Value.(formulaArg).ToNumber()
	if frequency.Type != ArgNumber {
		return frequency
	}
	if !validateFrequency(frequency.Number) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	basis := newNumberFormulaArg(0)
	if argsList.Len() == 9 {
		if basis = argsList.Back().Value.(formulaArg).ToNumber(); basis.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
	}
	return newListFormulaArg([]formulaArg{settlement, maturity, issue, firstCoupon, rate, yldOrPr, redemption, frequency, basis})
}

// ODDFPRICE function calculates the price per $100 face value of a security
// with an odd (short or long) first period. The syntax of the function is:
//
//	ODDFPRICE(settlement,maturity,issue,first_coupon,rate,yld,redemption,frequency,[basis])
func (fn *formulaFuncs) ODDFPRICE(argsList *list.List) formulaArg {
	if argsList.Len() != 8 && argsList.Len() != 9 {
		return newErrorFormulaArg(formulaErrorVALUE, "ODDFPRICE requires 8 or 9 arguments")
	}
	args := fn.prepareOddfArgs("ODDFPRICE", argsList)
	if args.Type != ArgList {
		return args
	}
	settlement, maturity, issue, firstCoupon, rate, yld, redemption, frequency, basisArg := args.List[0], args.List[1], args.List[2], args.List[3], args.List[4], args.List[5], args.List[6], args.List[7], args.List[8]
	if basisArg.Number < 0 || basisArg.Number > 4 {
		return newErrorFormulaArg(formulaErrorNUM, "invalid basis")
	}
	issueTime := timeFromExcelTime(issue.Number, false)
	settlementTime := timeFromExcelTime(settlement.Number, false)
	maturityTime := timeFromExcelTime(maturity.Number, false)
	firstCouponTime := timeFromExcelTime(firstCoupon.Number, false)
	basis := int(basisArg.Number)
	monthDays := getDaysInMonth(maturityTime.Year(), int(maturityTime.Month()))
	returnLastMonth := monthDays == maturityTime.Day()
	numMonths := 12 / frequency.Number
	numMonthsNeg := -numMonths
	mat := changeMonth(maturityTime, numMonthsNeg, returnLastMonth)
	pcd, _, _ := datesAggregate(mat, firstCouponTime, numMonthsNeg, func(d1, d2 time.Time) float64 {
		return 0
	}, 0, returnLastMonth)
	if !pcd.Equal(firstCouponTime) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	fnArgs := list.New().Init()
	fnArgs.PushBack(settlement)
	fnArgs.PushBack(maturity)
	fnArgs.PushBack(frequency)
	fnArgs.PushBack(basisArg)
	e := fn.COUPDAYS(fnArgs)
	n := fn.COUPNUM(fnArgs)
	m := frequency.Number
	dfc := coupdays(issueTime, firstCouponTime, basis)
	if dfc < e.Number {
		dsc := coupdays(settlementTime, firstCouponTime, basis)
		a := coupdays(issueTime, settlementTime, basis)
		x := yld.Number/m + 1
		y := dsc / e.Number
		p1 := x
		p3 := math.Pow(p1, n.Number-1+y)
		term1 := redemption.Number / p3
		term2 := 100 * rate.Number / m * dfc / e.Number / math.Pow(p1, y)
		f := func(acc []float64, index float64) []float64 {
			return []float64{acc[0] + 100*rate.Number/m/math.Pow(p1, index-1+y)}
		}
		term3 := aggrBetween(2, math.Floor(n.Number), []float64{0}, f)
		p2 := rate.Number / m
		term4 := a / e.Number * p2 * 100
		return newNumberFormulaArg(term1 + term2 + term3[0] - term4)
	}
	fnArgs.Init()
	fnArgs.PushBack(issue)
	fnArgs.PushBack(firstCoupon)
	fnArgs.PushBack(frequency)
	nc := fn.COUPNUM(fnArgs)
	lastCoupon := firstCoupon.Number
	aggrFunc := func(acc []float64, index float64) []float64 {
		lastCouponTime := timeFromExcelTime(lastCoupon, false)
		earlyCoupon := daysBetween(excelMinTime1900.Unix(), makeDate(lastCouponTime.Year(), time.Month(float64(lastCouponTime.Month())+numMonthsNeg), lastCouponTime.Day())) + 1
		earlyCouponTime := timeFromExcelTime(earlyCoupon, false)
		nl := e.Number
		if basis == 1 {
			nl = coupdays(earlyCouponTime, lastCouponTime, basis)
		}
		dci := coupdays(issueTime, lastCouponTime, basis)
		if index > 1 {
			dci = nl
		}
		startDate := earlyCoupon
		if issue.Number > earlyCoupon {
			startDate = issue.Number
		}
		endDate := lastCoupon
		if settlement.Number < lastCoupon {
			endDate = settlement.Number
		}
		startDateTime := timeFromExcelTime(startDate, false)
		endDateTime := timeFromExcelTime(endDate, false)
		a := coupdays(startDateTime, endDateTime, basis)
		lastCoupon = earlyCoupon
		dcnl := acc[0]
		anl := acc[1]
		return []float64{dcnl + dci/nl, anl + a/nl}
	}
	ag := aggrBetween(math.Floor(nc.Number), 1, []float64{0, 0}, aggrFunc)
	dcnl, anl := ag[0], ag[1]
	dsc := 0.0
	fnArgs.Init()
	fnArgs.PushBack(settlement)
	fnArgs.PushBack(firstCoupon)
	fnArgs.PushBack(frequency)
	if basis == 2 || basis == 3 {
		d := timeFromExcelTime(fn.COUPNCD(fnArgs).Number, false)
		dsc = coupdays(settlementTime, d, basis)
	} else {
		d := timeFromExcelTime(fn.COUPPCD(fnArgs).Number, false)
		a := coupdays(d, settlementTime, basis)
		dsc = e.Number - a
	}
	nq := coupNumber(firstCoupon.Number, settlement.Number, numMonths)
	fnArgs.Init()
	fnArgs.PushBack(firstCoupon)
	fnArgs.PushBack(maturity)
	fnArgs.PushBack(frequency)
	fnArgs.PushBack(basisArg)
	n = fn.COUPNUM(fnArgs)
	x := yld.Number/m + 1
	y := dsc / e.Number
	p1 := x
	p3 := math.Pow(p1, y+nq+n.Number)
	term1 := redemption.Number / p3
	term2 := 100 * rate.Number / m * dcnl / math.Pow(p1, nq+y)
	f := func(acc []float64, index float64) []float64 {
		return []float64{acc[0] + 100*rate.Number/m/math.Pow(p1, index+nq+y)}
	}
	term3 := aggrBetween(1, math.Floor(n.Number), []float64{0}, f)
	term4 := 100 * rate.Number / m * anl
	return newNumberFormulaArg(term1 + term2 + term3[0] - term4)
}

// getODDFPRICE is a part of implementation of the formula function ODDFPRICE.
func getODDFPRICE(f func(yld float64) float64, x, cnt, prec float64) float64 {
	const maxCnt = 20.0
	d := func(f func(yld float64) float64, x float64) float64 {
		return (f(x+prec) - f(x-prec)) / (2 * prec)
	}
	fx, Fx := f(x), d(f, x)
	newX := x - (fx / Fx)
	if math.Abs(newX-x) < prec {
		return newX
	} else if cnt > maxCnt {
		return newX
	}
	return getODDFPRICE(f, newX, cnt+1, prec)
}

// ODDFYIELD function calculates the yield of a security with an odd (short or
// long) first period. The syntax of the function is:
//
//	ODDFYIELD(settlement,maturity,issue,first_coupon,rate,pr,redemption,frequency,[basis])
func (fn *formulaFuncs) ODDFYIELD(argsList *list.List) formulaArg {
	if argsList.Len() != 8 && argsList.Len() != 9 {
		return newErrorFormulaArg(formulaErrorVALUE, "ODDFYIELD requires 8 or 9 arguments")
	}
	args := fn.prepareOddfArgs("ODDFYIELD", argsList)
	if args.Type != ArgList {
		return args
	}
	settlement, maturity, issue, firstCoupon, rate, pr, redemption, frequency, basisArg := args.List[0], args.List[1], args.List[2], args.List[3], args.List[4], args.List[5], args.List[6], args.List[7], args.List[8]
	if basisArg.Number < 0 || basisArg.Number > 4 {
		return newErrorFormulaArg(formulaErrorNUM, "invalid basis")
	}
	settlementTime := timeFromExcelTime(settlement.Number, false)
	maturityTime := timeFromExcelTime(maturity.Number, false)
	years := coupdays(settlementTime, maturityTime, int(basisArg.Number))
	px := pr.Number - 100
	num := rate.Number*years*100 - px
	denum := px/4 + years*px/2 + years*100
	guess := num / denum
	f := func(yld float64) float64 {
		fnArgs := list.New().Init()
		fnArgs.PushBack(settlement)
		fnArgs.PushBack(maturity)
		fnArgs.PushBack(issue)
		fnArgs.PushBack(firstCoupon)
		fnArgs.PushBack(rate)
		fnArgs.PushBack(newNumberFormulaArg(yld))
		fnArgs.PushBack(redemption)
		fnArgs.PushBack(frequency)
		fnArgs.PushBack(basisArg)
		return pr.Number - fn.ODDFPRICE(fnArgs).Number
	}
	if result := getODDFPRICE(f, guess, 0, 1e-7); !math.IsInf(result, 0) {
		return newNumberFormulaArg(result)
	}
	return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
}

// prepareOddlArgs checking and prepare arguments for the formula
// functions ODDLPRICE and ODDLYIELD.
func (fn *formulaFuncs) prepareOddlArgs(name string, argsList *list.List) formulaArg {
	dateValues := fn.prepareDataValueArgs(3, argsList)
	if dateValues.Type != ArgList {
		return dateValues
	}
	settlement, maturity, lastInterest := dateValues.List[0], dateValues.List[1], dateValues.List[2]
	if lastInterest.Number >= settlement.Number {
		return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s requires settlement > last_interest", name))
	}
	if settlement.Number >= maturity.Number {
		return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s requires maturity > settlement", name))
	}
	rate := argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber()
	if rate.Type != ArgNumber {
		return rate
	}
	if rate.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s requires rate >= 0", name))
	}
	yldOrPr := prepareOddYldOrPrArg(name, argsList.Front().Next().Next().Next().Next().Value.(formulaArg))
	if yldOrPr.Type != ArgNumber {
		return yldOrPr
	}
	redemption := argsList.Front().Next().Next().Next().Next().Next().Value.(formulaArg).ToNumber()
	if redemption.Type != ArgNumber {
		return redemption
	}
	if redemption.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s requires redemption > 0", name))
	}
	frequency := argsList.Front().Next().Next().Next().Next().Next().Next().Value.(formulaArg).ToNumber()
	if frequency.Type != ArgNumber {
		return frequency
	}
	if !validateFrequency(frequency.Number) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	basis := newNumberFormulaArg(0)
	if argsList.Len() == 8 {
		if basis = argsList.Back().Value.(formulaArg).ToNumber(); basis.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
	}
	return newListFormulaArg([]formulaArg{settlement, maturity, lastInterest, rate, yldOrPr, redemption, frequency, basis})
}

// oddl is an implementation of the formula functions ODDLPRICE and ODDLYIELD.
func (fn *formulaFuncs) oddl(name string, argsList *list.List) formulaArg {
	if argsList.Len() != 7 && argsList.Len() != 8 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires 7 or 8 arguments", name))
	}
	args := fn.prepareOddlArgs(name, argsList)
	if args.Type != ArgList {
		return args
	}
	settlement, maturity, lastInterest, rate, prOrYld, redemption, frequency, basisArg := args.List[0], args.List[1], args.List[2], args.List[3], args.List[4], args.List[5], args.List[6], args.List[7]
	if basisArg.Number < 0 || basisArg.Number > 4 {
		return newErrorFormulaArg(formulaErrorNUM, "invalid basis")
	}
	settlementTime := timeFromExcelTime(settlement.Number, false)
	maturityTime := timeFromExcelTime(maturity.Number, false)
	basis := int(basisArg.Number)
	numMonths := 12 / frequency.Number
	fnArgs := list.New().Init()
	fnArgs.PushBack(lastInterest)
	fnArgs.PushBack(maturity)
	fnArgs.PushBack(frequency)
	fnArgs.PushBack(basisArg)
	nc := fn.COUPNUM(fnArgs)
	earlyCoupon := lastInterest.Number
	aggrFunc := func(acc []float64, index float64) []float64 {
		earlyCouponTime := timeFromExcelTime(earlyCoupon, false)
		lateCouponTime := changeMonth(earlyCouponTime, numMonths, false)
		lateCoupon, _ := timeToExcelTime(lateCouponTime, false)
		nl := coupdays(earlyCouponTime, lateCouponTime, basis)
		dci := coupdays(earlyCouponTime, maturityTime, basis)
		if index < nc.Number {
			dci = nl
		}
		var a float64
		if lateCoupon < settlement.Number {
			a = dci
		} else if earlyCoupon < settlement.Number {
			a = coupdays(earlyCouponTime, settlementTime, basis)
		}
		startDate := earlyCoupon
		if settlement.Number > earlyCoupon {
			startDate = settlement.Number
		}
		endDate := lateCoupon
		if maturity.Number < lateCoupon {
			endDate = maturity.Number
		}
		startDateTime := timeFromExcelTime(startDate, false)
		endDateTime := timeFromExcelTime(endDate, false)
		dsc := coupdays(startDateTime, endDateTime, basis)
		earlyCoupon = lateCoupon
		dcnl := acc[0]
		anl := acc[1]
		dscnl := acc[2]
		return []float64{dcnl + dci/nl, anl + a/nl, dscnl + dsc/nl}
	}
	ag := aggrBetween(1, math.Floor(nc.Number), []float64{0, 0, 0}, aggrFunc)
	dcnl, anl, dscnl := ag[0], ag[1], ag[2]
	x := 100.0 * rate.Number / frequency.Number
	term1 := dcnl*x + redemption.Number
	if name == "ODDLPRICE" {
		term2 := dscnl*prOrYld.Number/frequency.Number + 1
		term3 := anl * x
		return newNumberFormulaArg(term1/term2 - term3)
	}
	term2 := anl*x + prOrYld.Number
	term3 := frequency.Number / dscnl
	return newNumberFormulaArg((term1 - term2) / term2 * term3)
}

// ODDLPRICE function calculates the price per $100 face value of a security
// with an odd (short or long) last period. The syntax of the function is:
//
//	ODDLPRICE(settlement,maturity,last_interest,rate,yld,redemption,frequency,[basis])
func (fn *formulaFuncs) ODDLPRICE(argsList *list.List) formulaArg {
	return fn.oddl("ODDLPRICE", argsList)
}

// ODDLYIELD function calculates the yield of a security with an odd (short or
// long) last period. The syntax of the function is:
//
//	ODDLYIELD(settlement,maturity,last_interest,rate,pr,redemption,frequency,[basis])
func (fn *formulaFuncs) ODDLYIELD(argsList *list.List) formulaArg {
	return fn.oddl("ODDLYIELD", argsList)
}

// PDURATION function calculates the number of periods required for an
// investment to reach a specified future value. The syntax of the function
// is:
//
//	PDURATION(rate,pv,fv)
func (fn *formulaFuncs) PDURATION(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "PDURATION requires 3 arguments")
	}
	rate := argsList.Front().Value.(formulaArg).ToNumber()
	if rate.Type != ArgNumber {
		return rate
	}
	pv := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if pv.Type != ArgNumber {
		return pv
	}
	fv := argsList.Back().Value.(formulaArg).ToNumber()
	if fv.Type != ArgNumber {
		return fv
	}
	if rate.Number <= 0 || pv.Number <= 0 || fv.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg((math.Log(fv.Number) - math.Log(pv.Number)) / math.Log(1+rate.Number))
}

// PMT function calculates the constant periodic payment required to pay off
// (or partially pay off) a loan or investment, with a constant interest
// rate, over a specified period. The syntax of the function is:
//
//	PMT(rate,nper,pv,[fv],[type])
func (fn *formulaFuncs) PMT(argsList *list.List) formulaArg {
	if argsList.Len() < 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "PMT requires at least 3 arguments")
	}
	if argsList.Len() > 5 {
		return newErrorFormulaArg(formulaErrorVALUE, "PMT allows at most 5 arguments")
	}
	rate := argsList.Front().Value.(formulaArg).ToNumber()
	if rate.Type != ArgNumber {
		return rate
	}
	nper := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if nper.Type != ArgNumber {
		return nper
	}
	pv := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if pv.Type != ArgNumber {
		return pv
	}
	fv, typ := newNumberFormulaArg(0), newNumberFormulaArg(0)
	if argsList.Len() >= 4 {
		if fv = argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber(); fv.Type != ArgNumber {
			return fv
		}
	}
	if argsList.Len() == 5 {
		if typ = argsList.Back().Value.(formulaArg).ToNumber(); typ.Type != ArgNumber {
			return typ
		}
	}
	if typ.Number != 0 && typ.Number != 1 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	if rate.Number != 0 {
		p := (-fv.Number - pv.Number*math.Pow(1+rate.Number, nper.Number)) / (1 + rate.Number*typ.Number) / ((math.Pow(1+rate.Number, nper.Number) - 1) / rate.Number)
		return newNumberFormulaArg(p)
	}
	return newNumberFormulaArg((-pv.Number - fv.Number) / nper.Number)
}

// PPMT function calculates the payment on the principal, during a specific
// period of a loan or investment that is paid in constant periodic payments,
// with a constant interest rate. The syntax of the function is:
//
//	PPMT(rate,per,nper,pv,[fv],[type])
func (fn *formulaFuncs) PPMT(argsList *list.List) formulaArg {
	return fn.ipmt("PPMT", argsList)
}

// price is an implementation of the formula function PRICE.
func (fn *formulaFuncs) price(settlement, maturity, rate, yld, redemption, frequency, basis formulaArg) formulaArg {
	if basis.Number < 0 || basis.Number > 4 {
		return newErrorFormulaArg(formulaErrorNUM, "invalid basis")
	}
	argsList := list.New().Init()
	argsList.PushBack(settlement)
	argsList.PushBack(maturity)
	argsList.PushBack(frequency)
	argsList.PushBack(basis)
	e := fn.COUPDAYS(argsList)
	dsc := fn.COUPDAYSNC(argsList).Number / e.Number
	n := fn.COUPNUM(argsList)
	a := fn.COUPDAYBS(argsList)
	ret := 0.0
	if n.Number > 1 {
		ret = redemption.Number / math.Pow(1+yld.Number/frequency.Number, n.Number-1+dsc)
		ret -= 100 * rate.Number / frequency.Number * a.Number / e.Number
		t1 := 100 * rate.Number / frequency.Number
		t2 := 1 + yld.Number/frequency.Number
		for k := 0.0; k < n.Number; k++ {
			ret += t1 / math.Pow(t2, k+dsc)
		}
	} else {
		dsc = e.Number - a.Number
		t1 := 100*(rate.Number/frequency.Number) + redemption.Number
		t2 := (yld.Number/frequency.Number)*(dsc/e.Number) + 1
		t3 := 100 * (rate.Number / frequency.Number) * (a.Number / e.Number)
		ret = t1/t2 - t3
	}
	return newNumberFormulaArg(ret)
}

// checkPriceYieldArgs checking and prepare arguments for the formula functions
// PRICE and YIELD.
func checkPriceYieldArgs(name string, rate, prYld, redemption, frequency formulaArg) formulaArg {
	if rate.Type != ArgNumber {
		return rate
	}
	if rate.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, fmt.Sprintf("%s requires rate >= 0", name))
	}
	if prYld.Type != ArgNumber {
		return prYld
	}
	if redemption.Type != ArgNumber {
		return redemption
	}
	if name == "PRICE" {
		if prYld.Number < 0 {
			return newErrorFormulaArg(formulaErrorNUM, "PRICE requires yld >= 0")
		}
		if redemption.Number <= 0 {
			return newErrorFormulaArg(formulaErrorNUM, "PRICE requires redemption > 0")
		}
	}
	if name == "YIELD" {
		if prYld.Number <= 0 {
			return newErrorFormulaArg(formulaErrorNUM, "YIELD requires pr > 0")
		}
		if redemption.Number < 0 {
			return newErrorFormulaArg(formulaErrorNUM, "YIELD requires redemption >= 0")
		}
	}
	if frequency.Type != ArgNumber {
		return frequency
	}
	if !validateFrequency(frequency.Number) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newEmptyFormulaArg()
}

// priceYield is an implementation of the formula functions PRICE and YIELD.
func (fn *formulaFuncs) priceYield(name string, argsList *list.List) formulaArg {
	if argsList.Len() != 6 && argsList.Len() != 7 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires 6 or 7 arguments", name))
	}
	args := fn.prepareDataValueArgs(2, argsList)
	if args.Type != ArgList {
		return args
	}
	settlement, maturity := args.List[0], args.List[1]
	rate := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	prYld := argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber()
	redemption := argsList.Front().Next().Next().Next().Next().Value.(formulaArg).ToNumber()
	frequency := argsList.Front().Next().Next().Next().Next().Next().Value.(formulaArg).ToNumber()
	if arg := checkPriceYieldArgs(name, rate, prYld, redemption, frequency); arg.Type != ArgEmpty {
		return arg
	}
	basis := newNumberFormulaArg(0)
	if argsList.Len() == 7 {
		if basis = argsList.Back().Value.(formulaArg).ToNumber(); basis.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
	}
	if name == "PRICE" {
		return fn.price(settlement, maturity, rate, prYld, redemption, frequency, basis)
	}
	return fn.yield(settlement, maturity, rate, prYld, redemption, frequency, basis)
}

// PRICE function calculates the price, per $100 face value of a security that
// pays periodic interest. The syntax of the function is:
//
//	PRICE(settlement,maturity,rate,yld,redemption,frequency,[basis])
func (fn *formulaFuncs) PRICE(argsList *list.List) formulaArg {
	return fn.priceYield("PRICE", argsList)
}

// PRICEDISC function calculates the price, per $100 face value of a
// discounted security. The syntax of the function is:
//
//	PRICEDISC(settlement,maturity,discount,redemption,[basis])
func (fn *formulaFuncs) PRICEDISC(argsList *list.List) formulaArg {
	if argsList.Len() != 4 && argsList.Len() != 5 {
		return newErrorFormulaArg(formulaErrorVALUE, "PRICEDISC requires 4 or 5 arguments")
	}
	args := fn.prepareDataValueArgs(2, argsList)
	if args.Type != ArgList {
		return args
	}
	settlement, maturity := args.List[0], args.List[1]
	if maturity.Number <= settlement.Number {
		return newErrorFormulaArg(formulaErrorNUM, "PRICEDISC requires maturity > settlement")
	}
	discount := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if discount.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	if discount.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, "PRICEDISC requires discount > 0")
	}
	redemption := argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber()
	if redemption.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	if redemption.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, "PRICEDISC requires redemption > 0")
	}
	basis := newNumberFormulaArg(0)
	if argsList.Len() == 5 {
		if basis = argsList.Back().Value.(formulaArg).ToNumber(); basis.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
	}
	frac := yearFrac(settlement.Number, maturity.Number, int(basis.Number))
	if frac.Type != ArgNumber {
		return frac
	}
	return newNumberFormulaArg(redemption.Number * (1 - discount.Number*frac.Number))
}

// PRICEMAT function calculates the price, per $100 face value of a security
// that pays interest at maturity. The syntax of the function is:
//
//	PRICEMAT(settlement,maturity,issue,rate,yld,[basis])
func (fn *formulaFuncs) PRICEMAT(argsList *list.List) formulaArg {
	if argsList.Len() != 5 && argsList.Len() != 6 {
		return newErrorFormulaArg(formulaErrorVALUE, "PRICEMAT requires 5 or 6 arguments")
	}
	args := fn.prepareDataValueArgs(3, argsList)
	if args.Type != ArgList {
		return args
	}
	settlement, maturity, issue := args.List[0], args.List[1], args.List[2]
	if settlement.Number >= maturity.Number {
		return newErrorFormulaArg(formulaErrorNUM, "PRICEMAT requires maturity > settlement")
	}
	if issue.Number >= settlement.Number {
		return newErrorFormulaArg(formulaErrorNUM, "PRICEMAT requires settlement > issue")
	}
	rate := argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber()
	if rate.Type != ArgNumber {
		return rate
	}
	if rate.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, "PRICEMAT requires rate >= 0")
	}
	yld := argsList.Front().Next().Next().Next().Next().Value.(formulaArg).ToNumber()
	if yld.Type != ArgNumber {
		return yld
	}
	if yld.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, "PRICEMAT requires yld >= 0")
	}
	basis := newNumberFormulaArg(0)
	if argsList.Len() == 6 {
		if basis = argsList.Back().Value.(formulaArg).ToNumber(); basis.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
	}
	dsm := yearFrac(settlement.Number, maturity.Number, int(basis.Number))
	if dsm.Type != ArgNumber {
		return dsm
	}
	dis := yearFrac(issue.Number, settlement.Number, int(basis.Number))
	dim := yearFrac(issue.Number, maturity.Number, int(basis.Number))
	return newNumberFormulaArg(((1+dim.Number*rate.Number)/(1+dsm.Number*yld.Number) - dis.Number*rate.Number) * 100)
}

// PV function calculates the Present Value of an investment, based on a
// series of future payments. The syntax of the function is:
//
//	PV(rate,nper,pmt,[fv],[type])
func (fn *formulaFuncs) PV(argsList *list.List) formulaArg {
	if argsList.Len() < 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "PV requires at least 3 arguments")
	}
	if argsList.Len() > 5 {
		return newErrorFormulaArg(formulaErrorVALUE, "PV allows at most 5 arguments")
	}
	rate := argsList.Front().Value.(formulaArg).ToNumber()
	if rate.Type != ArgNumber {
		return rate
	}
	nper := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if nper.Type != ArgNumber {
		return nper
	}
	pmt := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if pmt.Type != ArgNumber {
		return pmt
	}
	fv := newNumberFormulaArg(0)
	if argsList.Len() >= 4 {
		if fv = argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber(); fv.Type != ArgNumber {
			return fv
		}
	}
	t := newNumberFormulaArg(0)
	if argsList.Len() == 5 {
		if t = argsList.Back().Value.(formulaArg).ToNumber(); t.Type != ArgNumber {
			return t
		}
		if t.Number != 0 {
			t.Number = 1
		}
	}
	if rate.Number == 0 {
		return newNumberFormulaArg(-pmt.Number*nper.Number - fv.Number)
	}
	return newNumberFormulaArg((((1-math.Pow(1+rate.Number, nper.Number))/rate.Number)*pmt.Number*(1+rate.Number*t.Number) - fv.Number) / math.Pow(1+rate.Number, nper.Number))
}

// rate is an implementation of the formula function RATE.
func (fn *formulaFuncs) rate(nper, pmt, pv, fv, t, guess formulaArg) formulaArg {
	maxIter, iter, isClose, epsMax, rate := 100, 0, false, 1e-6, guess.Number
	for iter < maxIter && !isClose {
		t1 := math.Pow(rate+1, nper.Number)
		t2 := math.Pow(rate+1, nper.Number-1)
		rt := rate*t.Number + 1
		p0 := pmt.Number * (t1 - 1)
		f1 := fv.Number + t1*pv.Number + p0*rt/rate
		n1 := nper.Number * t2 * pv.Number
		n2 := p0 * rt / math.Pow(rate, 2)
		f2 := math.Nextafter(n1, n1) - math.Nextafter(n2, n2)
		f3 := (nper.Number*pmt.Number*t2*rt + p0*t.Number) / rate
		delta := f1 / (f2 + f3)
		if math.Abs(delta) < epsMax {
			isClose = true
		}
		iter++
		rate -= delta
	}
	return newNumberFormulaArg(rate)
}

// RATE function calculates the interest rate required to pay off a specified
// amount of a loan, or to reach a target amount on an investment, over a
// given period. The syntax of the function is:
//
//	RATE(nper,pmt,pv,[fv],[type],[guess])
func (fn *formulaFuncs) RATE(argsList *list.List) formulaArg {
	if argsList.Len() < 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "RATE requires at least 3 arguments")
	}
	if argsList.Len() > 6 {
		return newErrorFormulaArg(formulaErrorVALUE, "RATE allows at most 6 arguments")
	}
	nper := argsList.Front().Value.(formulaArg).ToNumber()
	if nper.Type != ArgNumber {
		return nper
	}
	pmt := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if pmt.Type != ArgNumber {
		return pmt
	}
	pv := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if pv.Type != ArgNumber {
		return pv
	}
	fv := newNumberFormulaArg(0)
	if argsList.Len() >= 4 {
		if fv = argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber(); fv.Type != ArgNumber {
			return fv
		}
	}
	t := newNumberFormulaArg(0)
	if argsList.Len() >= 5 {
		if t = argsList.Front().Next().Next().Next().Next().Value.(formulaArg).ToNumber(); t.Type != ArgNumber {
			return t
		}
		if t.Number != 0 {
			t.Number = 1
		}
	}
	guess := newNumberFormulaArg(0.1)
	if argsList.Len() == 6 {
		if guess = argsList.Back().Value.(formulaArg).ToNumber(); guess.Type != ArgNumber {
			return guess
		}
	}
	return fn.rate(nper, pmt, pv, fv, t, guess)
}

// RECEIVED function calculates the amount received at maturity for a fully
// invested security. The syntax of the function is:
//
//	RECEIVED(settlement,maturity,investment,discount,[basis])
func (fn *formulaFuncs) RECEIVED(argsList *list.List) formulaArg {
	if argsList.Len() < 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "RECEIVED requires at least 4 arguments")
	}
	if argsList.Len() > 5 {
		return newErrorFormulaArg(formulaErrorVALUE, "RECEIVED allows at most 5 arguments")
	}
	args := fn.prepareDataValueArgs(2, argsList)
	if args.Type != ArgList {
		return args
	}
	settlement, maturity := args.List[0], args.List[1]
	investment := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if investment.Type != ArgNumber {
		return investment
	}
	discount := argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber()
	if discount.Type != ArgNumber {
		return discount
	}
	if discount.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, "RECEIVED requires discount > 0")
	}
	basis := newNumberFormulaArg(0)
	if argsList.Len() == 5 {
		if basis = argsList.Back().Value.(formulaArg).ToNumber(); basis.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
	}
	frac := yearFrac(settlement.Number, maturity.Number, int(basis.Number))
	if frac.Type != ArgNumber {
		return frac
	}
	return newNumberFormulaArg(investment.Number / (1 - discount.Number*frac.Number))
}

// RRI function calculates the equivalent interest rate for an investment with
// specified present value, future value and duration. The syntax of the
// function is:
//
//	RRI(nper,pv,fv)
func (fn *formulaFuncs) RRI(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "RRI requires 3 arguments")
	}
	nper := argsList.Front().Value.(formulaArg).ToNumber()
	pv := argsList.Front().Next().Value.(formulaArg).ToNumber()
	fv := argsList.Back().Value.(formulaArg).ToNumber()
	if nper.Type != ArgNumber || pv.Type != ArgNumber || fv.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if nper.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, "RRI requires nper argument to be > 0")
	}
	if pv.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, "RRI requires pv argument to be > 0")
	}
	if fv.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, "RRI requires fv argument to be >= 0")
	}
	return newNumberFormulaArg(math.Pow(fv.Number/pv.Number, 1/nper.Number) - 1)
}

// SLN function calculates the straight line depreciation of an asset for one
// period. The syntax of the function is:
//
//	SLN(cost,salvage,life)
func (fn *formulaFuncs) SLN(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "SLN requires 3 arguments")
	}
	cost := argsList.Front().Value.(formulaArg).ToNumber()
	salvage := argsList.Front().Next().Value.(formulaArg).ToNumber()
	life := argsList.Back().Value.(formulaArg).ToNumber()
	if cost.Type != ArgNumber || salvage.Type != ArgNumber || life.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if life.Number == 0 {
		return newErrorFormulaArg(formulaErrorNUM, "SLN requires life argument to be > 0")
	}
	return newNumberFormulaArg((cost.Number - salvage.Number) / life.Number)
}

// SYD function calculates the sum-of-years' digits depreciation for a
// specified period in the lifetime of an asset. The syntax of the function
// is:
//
//	SYD(cost,salvage,life,per)
func (fn *formulaFuncs) SYD(argsList *list.List) formulaArg {
	if argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "SYD requires 4 arguments")
	}
	cost := argsList.Front().Value.(formulaArg).ToNumber()
	salvage := argsList.Front().Next().Value.(formulaArg).ToNumber()
	life := argsList.Back().Prev().Value.(formulaArg).ToNumber()
	per := argsList.Back().Value.(formulaArg).ToNumber()
	if cost.Type != ArgNumber || salvage.Type != ArgNumber || life.Type != ArgNumber || per.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if life.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, "SYD requires life argument to be > 0")
	}
	if per.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, "SYD requires per argument to be > 0")
	}
	if per.Number > life.Number {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(((cost.Number - salvage.Number) * (life.Number - per.Number + 1) * 2) / (life.Number * (life.Number + 1)))
}

// TBILLEQ function calculates the bond-equivalent yield for a Treasury Bill.
// The syntax of the function is:
//
//	TBILLEQ(settlement,maturity,discount)
func (fn *formulaFuncs) TBILLEQ(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "TBILLEQ requires 3 arguments")
	}
	args := fn.prepareDataValueArgs(2, argsList)
	if args.Type != ArgList {
		return args
	}
	settlement, maturity := args.List[0], args.List[1]
	dsm := maturity.Number - settlement.Number
	if dsm > 365 || maturity.Number <= settlement.Number {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	discount := argsList.Back().Value.(formulaArg).ToNumber()
	if discount.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	if discount.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg((365 * discount.Number) / (360 - discount.Number*dsm))
}

// TBILLPRICE function returns the price, per $100 face value, of a Treasury
// Bill. The syntax of the function is:
//
//	TBILLPRICE(settlement,maturity,discount)
func (fn *formulaFuncs) TBILLPRICE(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "TBILLPRICE requires 3 arguments")
	}
	args := fn.prepareDataValueArgs(2, argsList)
	if args.Type != ArgList {
		return args
	}
	settlement, maturity := args.List[0], args.List[1]
	dsm := maturity.Number - settlement.Number
	if dsm > 365 || maturity.Number <= settlement.Number {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	discount := argsList.Back().Value.(formulaArg).ToNumber()
	if discount.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	if discount.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(100 * (1 - discount.Number*dsm/360))
}

// TBILLYIELD function calculates the yield of a Treasury Bill. The syntax of
// the function is:
//
//	TBILLYIELD(settlement,maturity,pr)
func (fn *formulaFuncs) TBILLYIELD(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "TBILLYIELD requires 3 arguments")
	}
	args := fn.prepareDataValueArgs(2, argsList)
	if args.Type != ArgList {
		return args
	}
	settlement, maturity := args.List[0], args.List[1]
	dsm := maturity.Number - settlement.Number
	if dsm > 365 || maturity.Number <= settlement.Number {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	pr := argsList.Back().Value.(formulaArg).ToNumber()
	if pr.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	if pr.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(((100 - pr.Number) / pr.Number) * (360 / dsm))
}

// prepareVdbArgs checking and prepare arguments for the formula function
// VDB.
func (fn *formulaFuncs) prepareVdbArgs(argsList *list.List) formulaArg {
	cost := argsList.Front().Value.(formulaArg).ToNumber()
	if cost.Type != ArgNumber {
		return cost
	}
	if cost.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, "VDB requires cost >= 0")
	}
	salvage := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if salvage.Type != ArgNumber {
		return salvage
	}
	if salvage.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, "VDB requires salvage >= 0")
	}
	life := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if life.Type != ArgNumber {
		return life
	}
	if life.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, "VDB requires life > 0")
	}
	startPeriod := argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber()
	if startPeriod.Type != ArgNumber {
		return startPeriod
	}
	if startPeriod.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, "VDB requires start_period > 0")
	}
	endPeriod := argsList.Front().Next().Next().Next().Next().Value.(formulaArg).ToNumber()
	if endPeriod.Type != ArgNumber {
		return endPeriod
	}
	if startPeriod.Number > endPeriod.Number {
		return newErrorFormulaArg(formulaErrorNUM, "VDB requires start_period <= end_period")
	}
	if endPeriod.Number > life.Number {
		return newErrorFormulaArg(formulaErrorNUM, "VDB requires end_period <= life")
	}
	factor := newNumberFormulaArg(2)
	if argsList.Len() > 5 {
		if factor = argsList.Front().Next().Next().Next().Next().Next().Value.(formulaArg).ToNumber(); factor.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
		if factor.Number < 0 {
			return newErrorFormulaArg(formulaErrorVALUE, "VDB requires factor >= 0")
		}
	}
	return newListFormulaArg([]formulaArg{cost, salvage, life, startPeriod, endPeriod, factor})
}

// vdb is a part of implementation of the formula function VDB.
func (fn *formulaFuncs) vdb(cost, salvage, life, life1, period, factor formulaArg) formulaArg {
	var ddb, vdb, sln, term float64
	endInt, cs, nowSln := math.Ceil(period.Number), cost.Number-salvage.Number, false
	ddbArgs := list.New()
	for i := 1.0; i <= endInt; i++ {
		if !nowSln {
			ddbArgs.Init()
			ddbArgs.PushBack(cost)
			ddbArgs.PushBack(salvage)
			ddbArgs.PushBack(life)
			ddbArgs.PushBack(newNumberFormulaArg(i))
			ddbArgs.PushBack(factor)
			ddb = fn.DDB(ddbArgs).Number
			sln = cs / (life1.Number - i + 1)
			if sln > ddb && i != endInt {
				term = sln
				nowSln = true
			} else {
				term = ddb
				cs -= ddb
			}
		} else {
			term = sln
		}
		if i == endInt {
			term *= period.Number + 1 - endInt
		}
		vdb += term
	}
	return newNumberFormulaArg(vdb)
}

// VDB function calculates the depreciation of an asset, using the Double
// Declining Balance Method, or another specified depreciation rate, for a
// specified period (including partial periods). The syntax of the function
// is:
//
//	VDB(cost,salvage,life,start_period,end_period,[factor],[no_switch])
func (fn *formulaFuncs) VDB(argsList *list.List) formulaArg {
	if argsList.Len() < 5 || argsList.Len() > 7 {
		return newErrorFormulaArg(formulaErrorVALUE, "VDB requires 5 or 7 arguments")
	}
	args := fn.prepareVdbArgs(argsList)
	if args.Type != ArgList {
		return args
	}
	cost, salvage, life, startPeriod, endPeriod, factor := args.List[0], args.List[1], args.List[2], args.List[3], args.List[4], args.List[5]
	noSwitch := newBoolFormulaArg(false)
	if argsList.Len() > 6 {
		if noSwitch = argsList.Back().Value.(formulaArg).ToBool(); noSwitch.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
	}
	startInt, endInt, vdb, ddbArgs := math.Floor(startPeriod.Number), math.Ceil(endPeriod.Number), newNumberFormulaArg(0), list.New()
	if noSwitch.Number == 1 {
		for i := startInt + 1; i <= endInt; i++ {
			ddbArgs.Init()
			ddbArgs.PushBack(cost)
			ddbArgs.PushBack(salvage)
			ddbArgs.PushBack(life)
			ddbArgs.PushBack(newNumberFormulaArg(i))
			ddbArgs.PushBack(factor)
			term := fn.DDB(ddbArgs)
			if i == startInt+1 {
				term.Number *= math.Min(endPeriod.Number, startInt+1) - startPeriod.Number
			} else if i == endInt {
				term.Number *= endPeriod.Number + 1 - endInt
			}
			vdb.Number += term.Number
		}
		return vdb
	}
	cost.Number -= fn.vdb(cost, salvage, life, life, startPeriod, factor).Number
	return fn.vdb(cost, salvage, life, newNumberFormulaArg(life.Number-startPeriod.Number), newNumberFormulaArg(endPeriod.Number-startPeriod.Number), factor)
}

// prepareXArgs prepare arguments for the formula function XIRR and XNPV.
func (fn *formulaFuncs) prepareXArgs(values, dates formulaArg) (valuesArg, datesArg []float64, err formulaArg) {
	for _, arg := range values.ToList() {
		if numArg := arg.ToNumber(); numArg.Type == ArgNumber {
			valuesArg = append(valuesArg, numArg.Number)
			continue
		}
		err = newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		return
	}
	if len(valuesArg) < 2 {
		err = newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		return
	}
	date := 0.0
	for _, arg := range dates.ToList() {
		if arg.Type == ArgNumber {
			datesArg = append(datesArg, arg.Number)
			if arg.Number < date {
				err = newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
				return
			}
			date = arg.Number
			continue
		}
		err = newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		return
	}
	if len(valuesArg) != len(datesArg) {
		err = newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		return
	}
	err = newEmptyFormulaArg()
	return
}

// xirr is an implementation of the formula function XIRR.
func (fn *formulaFuncs) xirr(values, dates []float64, guess float64) formulaArg {
	positive, negative := false, false
	for i := 0; i < len(values); i++ {
		if values[i] > 0 {
			positive = true
		}
		if values[i] < 0 {
			negative = true
		}
	}
	if !positive || !negative {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	result, epsMax, count, maxIterate, err := guess, 1e-10, 0, 50, false
	for {
		resultValue := xirrPart1(values, dates, result)
		newRate := result - resultValue/xirrPart2(values, dates, result)
		epsRate := math.Abs(newRate - result)
		result = newRate
		count++
		if epsRate <= epsMax || math.Abs(resultValue) <= epsMax {
			break
		}
		if count > maxIterate {
			err = true
			break
		}
	}
	if err || math.IsNaN(result) || math.IsInf(result, 0) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(result)
}

// xirrPart1 is a part of implementation of the formula function XIRR.
func xirrPart1(values, dates []float64, rate float64) float64 {
	r := rate + 1
	result := values[0]
	vlen := len(values)
	firstDate := dates[0]
	for i := 1; i < vlen; i++ {
		result += values[i] / math.Pow(r, (dates[i]-firstDate)/365)
	}
	return result
}

// xirrPart2 is a part of implementation of the formula function XIRR.
func xirrPart2(values, dates []float64, rate float64) float64 {
	r := rate + 1
	result := 0.0
	vlen := len(values)
	firstDate := dates[0]
	for i := 1; i < vlen; i++ {
		frac := (dates[i] - firstDate) / 365
		result -= frac * values[i] / math.Pow(r, frac+1)
	}
	return result
}

// XIRR function returns the Internal Rate of Return for a supplied series of
// cash flows (i.e. a set of values, which includes an initial investment
// value and a series of net income values) occurring at a series of supplied
// dates. The syntax of the function is:
//
//	XIRR(values,dates,[guess])
func (fn *formulaFuncs) XIRR(argsList *list.List) formulaArg {
	if argsList.Len() != 2 && argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "XIRR requires 2 or 3 arguments")
	}
	values, dates, err := fn.prepareXArgs(argsList.Front().Value.(formulaArg), argsList.Front().Next().Value.(formulaArg))
	if err.Type != ArgEmpty {
		return err
	}
	guess := newNumberFormulaArg(0)
	if argsList.Len() == 3 {
		if guess = argsList.Back().Value.(formulaArg).ToNumber(); guess.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
		if guess.Number <= -1 {
			return newErrorFormulaArg(formulaErrorVALUE, "XIRR requires guess > -1")
		}
	}
	return fn.xirr(values, dates, guess.Number)
}

// XNPV function calculates the Net Present Value for a schedule of cash flows
// that is not necessarily periodic. The syntax of the function is:
//
//	XNPV(rate,values,dates)
func (fn *formulaFuncs) XNPV(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "XNPV requires 3 arguments")
	}
	rate := argsList.Front().Value.(formulaArg).ToNumber()
	if rate.Type != ArgNumber {
		return rate
	}
	if rate.Number <= 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "XNPV requires rate > 0")
	}
	values, dates, err := fn.prepareXArgs(argsList.Front().Next().Value.(formulaArg), argsList.Back().Value.(formulaArg))
	if err.Type != ArgEmpty {
		return err
	}
	date1, xnpv := dates[0], 0.0
	for idx, value := range values {
		xnpv += value / math.Pow(1+rate.Number, (dates[idx]-date1)/365)
	}
	return newNumberFormulaArg(xnpv)
}

// yield is an implementation of the formula function YIELD.
func (fn *formulaFuncs) yield(settlement, maturity, rate, pr, redemption, frequency, basis formulaArg) formulaArg {
	priceN, yield1, yield2 := newNumberFormulaArg(0), newNumberFormulaArg(0), newNumberFormulaArg(1)
	price1 := fn.price(settlement, maturity, rate, yield1, redemption, frequency, basis)
	if price1.Type != ArgNumber {
		return price1
	}
	price2 := fn.price(settlement, maturity, rate, yield2, redemption, frequency, basis)
	yieldN := newNumberFormulaArg((yield2.Number - yield1.Number) * 0.5)
	for iter := 0; iter < 100 && priceN.Number != pr.Number; iter++ {
		priceN = fn.price(settlement, maturity, rate, yieldN, redemption, frequency, basis)
		if pr.Number == price1.Number {
			return yield1
		} else if pr.Number == price2.Number {
			return yield2
		} else if pr.Number == priceN.Number {
			return yieldN
		} else if pr.Number < price2.Number {
			yield2.Number *= 2.0
			price2 = fn.price(settlement, maturity, rate, yield2, redemption, frequency, basis)
			yieldN.Number = (yield2.Number - yield1.Number) * 0.5
		} else {
			if pr.Number < priceN.Number {
				yield1 = yieldN
				price1 = priceN
			} else {
				yield2 = yieldN
				price2 = priceN
			}
			f1 := (yield2.Number - yield1.Number) * ((pr.Number - price2.Number) / (price1.Number - price2.Number))
			yieldN.Number = yield2.Number - math.Nextafter(f1, f1)
		}
	}
	return yieldN
}

// YIELD function calculates the Yield of a security that pays periodic
// interest. The syntax of the function is:
//
//	YIELD(settlement,maturity,rate,pr,redemption,frequency,[basis])
func (fn *formulaFuncs) YIELD(argsList *list.List) formulaArg {
	return fn.priceYield("YIELD", argsList)
}

// YIELDDISC function calculates the annual yield of a discounted security.
// The syntax of the function is:
//
//	YIELDDISC(settlement,maturity,pr,redemption,[basis])
func (fn *formulaFuncs) YIELDDISC(argsList *list.List) formulaArg {
	if argsList.Len() != 4 && argsList.Len() != 5 {
		return newErrorFormulaArg(formulaErrorVALUE, "YIELDDISC requires 4 or 5 arguments")
	}
	args := fn.prepareDataValueArgs(2, argsList)
	if args.Type != ArgList {
		return args
	}
	settlement, maturity := args.List[0], args.List[1]
	pr := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if pr.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	if pr.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, "YIELDDISC requires pr > 0")
	}
	redemption := argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber()
	if redemption.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	if redemption.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, "YIELDDISC requires redemption > 0")
	}
	basis := newNumberFormulaArg(0)
	if argsList.Len() == 5 {
		if basis = argsList.Back().Value.(formulaArg).ToNumber(); basis.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
	}
	frac := yearFrac(settlement.Number, maturity.Number, int(basis.Number))
	if frac.Type != ArgNumber {
		return frac
	}
	return newNumberFormulaArg((redemption.Number/pr.Number - 1) / frac.Number)
}

// YIELDMAT function calculates the annual yield of a security that pays
// interest at maturity. The syntax of the function is:
//
//	YIELDMAT(settlement,maturity,issue,rate,pr,[basis])
func (fn *formulaFuncs) YIELDMAT(argsList *list.List) formulaArg {
	if argsList.Len() != 5 && argsList.Len() != 6 {
		return newErrorFormulaArg(formulaErrorVALUE, "YIELDMAT requires 5 or 6 arguments")
	}
	args := fn.prepareDataValueArgs(2, argsList)
	if args.Type != ArgList {
		return args
	}
	settlement, maturity := args.List[0], args.List[1]
	arg := list.New().Init()
	issue := argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if issue.Type != ArgNumber {
		arg.PushBack(argsList.Front().Next().Next().Value.(formulaArg))
		issue = fn.DATEVALUE(arg)
		if issue.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
	}
	if issue.Number >= settlement.Number {
		return newErrorFormulaArg(formulaErrorNUM, "YIELDMAT requires settlement > issue")
	}
	rate := argsList.Front().Next().Next().Next().Value.(formulaArg).ToNumber()
	if rate.Type != ArgNumber {
		return rate
	}
	if rate.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, "YIELDMAT requires rate >= 0")
	}
	pr := argsList.Front().Next().Next().Next().Next().Value.(formulaArg).ToNumber()
	if pr.Type != ArgNumber {
		return pr
	}
	if pr.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNUM, "YIELDMAT requires pr > 0")
	}
	basis := newNumberFormulaArg(0)
	if argsList.Len() == 6 {
		if basis = argsList.Back().Value.(formulaArg).ToNumber(); basis.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
	}
	dim := yearFrac(issue.Number, maturity.Number, int(basis.Number))
	if dim.Type != ArgNumber {
		return dim
	}
	dis := yearFrac(issue.Number, settlement.Number, int(basis.Number))
	dsm := yearFrac(settlement.Number, maturity.Number, int(basis.Number))
	f1 := dim.Number * rate.Number
	result := 1 + math.Nextafter(f1, f1)
	result /= pr.Number/100 + dis.Number*rate.Number
	result--
	result /= dsm.Number
	return newNumberFormulaArg(result)
}
