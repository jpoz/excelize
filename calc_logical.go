// Copyright 2016 - 2025 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.24.0 or later.

package excelize

import (
	"container/list"
	"math"
	"strconv"
	"strings"
)

func (fn *formulaFuncs) AND(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "AND requires at least 1 argument")
	}
	if argsList.Len() > 30 {
		return newErrorFormulaArg(formulaErrorVALUE, "AND accepts at most 30 arguments")
	}
	and := true
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		token := arg.Value.(formulaArg)
		switch token.Type {
		case ArgUnknown:
			continue
		case ArgString:
			if token.String == "TRUE" {
				continue
			}
			if token.String == "FALSE" {
				return newStringFormulaArg(token.String)
			}
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		case ArgNumber:
			and = and && token.Number != 0
		case ArgMatrix:
			// TODO
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
	}
	return newBoolFormulaArg(and)
}

// FALSE function returns the logical value FALSE. The syntax of the
// function is:
//
//	FALSE()
func (fn *formulaFuncs) FALSE(argsList *list.List) formulaArg {
	if argsList.Len() != 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "FALSE takes no arguments")
	}
	return newBoolFormulaArg(false)
}

// IFERROR function receives two values (or expressions) and tests if the
// first of these evaluates to an error. The syntax of the function is:
//
//	IFERROR(value,value_if_error)
func (fn *formulaFuncs) IFERROR(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "IFERROR requires 2 arguments")
	}
	value := argsList.Front().Value.(formulaArg)
	if value.Type != ArgError {
		if value.Type == ArgEmpty {
			return newNumberFormulaArg(0)
		}
		return value
	}
	return argsList.Back().Value.(formulaArg)
}

// IFNA function tests if an initial supplied value (or expression) evaluates
// to the Excel #N/A error. If so, the function returns a second supplied
// value; Otherwise the function returns the first supplied value. The syntax
// of the function is:
//
//	IFNA(value,value_if_na)
func (fn *formulaFuncs) IFNA(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "IFNA requires 2 arguments")
	}
	arg := argsList.Front().Value.(formulaArg)
	if arg.Type == ArgError && arg.String == formulaErrorNA {
		return argsList.Back().Value.(formulaArg)
	}
	return arg
}

// IFS function tests a number of supplied conditions and returns the result
// corresponding to the first condition that evaluates to TRUE. If none of
// the supplied conditions evaluate to TRUE, the function returns the #N/A
// error.
//
//	IFS(logical_test1,value_if_true1,[logical_test2,value_if_true2],...)
func (fn *formulaFuncs) IFS(argsList *list.List) formulaArg {
	if argsList.Len() < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "IFS requires at least 2 arguments")
	}
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		if arg.Value.(formulaArg).ToBool().Number == 1 {
			return arg.Next().Value.(formulaArg)
		}
		arg = arg.Next()
	}
	return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
}

// NOT function returns the opposite to a supplied logical value. The syntax
// of the function is:
//
//	NOT(logical)
func (fn *formulaFuncs) NOT(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "NOT requires 1 argument")
	}
	token := argsList.Front().Value.(formulaArg)
	switch token.Type {
	case ArgString, ArgList:
		if strings.ToUpper(token.String) == "TRUE" {
			return newBoolFormulaArg(false)
		}
		if strings.ToUpper(token.String) == "FALSE" {
			return newBoolFormulaArg(true)
		}
	case ArgNumber:
		return newBoolFormulaArg(!(token.Number != 0))
	case ArgError:
		return token
	}
	return newErrorFormulaArg(formulaErrorVALUE, "NOT expects 1 boolean or numeric argument")
}

// OR function tests a number of supplied conditions and returns either TRUE
// or FALSE. The syntax of the function is:
//
//	OR(logical_test1,[logical_test2],...)
func (fn *formulaFuncs) OR(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "OR requires at least 1 argument")
	}
	if argsList.Len() > 30 {
		return newErrorFormulaArg(formulaErrorVALUE, "OR accepts at most 30 arguments")
	}
	var or bool
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		token := arg.Value.(formulaArg)
		switch token.Type {
		case ArgUnknown:
			continue
		case ArgString:
			if token.String == "FALSE" {
				continue
			}
			if token.String == "TRUE" {
				or = true
				continue
			}
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		case ArgNumber:
			if or = token.Number != 0; or {
				return newStringFormulaArg(strings.ToUpper(strconv.FormatBool(or)))
			}
		case ArgMatrix:
			args := list.New()
			for _, arg := range token.ToList() {
				args.PushBack(arg)
			}
			return fn.OR(args)
		}
	}
	return newBoolFormulaArg(or)
}

// SWITCH function compares a number of supplied values to a supplied test
// expression and returns a result corresponding to the first value that
// matches the test expression. A default value can be supplied, to be
// returned if none of the supplied values match the test expression. The
// syntax of the function is:
//
//	SWITCH(expression,value1,result1,[value2,result2],[value3,result3],...,[default])
func (fn *formulaFuncs) SWITCH(argsList *list.List) formulaArg {
	if argsList.Len() < 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "SWITCH requires at least 3 arguments")
	}
	target := argsList.Front().Value.(formulaArg)
	argCount := argsList.Len() - 1
	switchCount := int(math.Floor(float64(argCount) / 2))
	hasDefaultClause := argCount%2 != 0
	result := newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	if hasDefaultClause {
		result = argsList.Back().Value.(formulaArg)
	}
	if switchCount > 0 {
		arg := argsList.Front()
		for i := 0; i < switchCount; i++ {
			arg = arg.Next()
			if target.Value() == arg.Value.(formulaArg).Value() {
				result = arg.Next().Value.(formulaArg)
				break
			}
			arg = arg.Next()
		}
	}
	return result
}

// TRUE function returns the logical value TRUE. The syntax of the function
// is:
//
//	TRUE()
func (fn *formulaFuncs) TRUE(argsList *list.List) formulaArg {
	if argsList.Len() != 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "TRUE takes no arguments")
	}
	return newBoolFormulaArg(true)
}

// calcXor checking if numeric cell exists and count it by given arguments
// sequence for the formula function XOR.
func calcXor(argsList *list.List) formulaArg {
	count, ok := 0, false
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		token := arg.Value.(formulaArg)
		switch token.Type {
		case ArgError:
			return token
		case ArgNumber:
			ok = true
			if token.Number != 0 {
				count++
			}
		case ArgMatrix:
			for _, value := range token.ToList() {
				if num := value.ToNumber(); num.Type == ArgNumber {
					ok = true
					if num.Number != 0 {
						count++
					}
				}
			}
		}
	}
	if !ok {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	return newBoolFormulaArg(count%2 != 0)
}

// XOR function returns the Exclusive Or logical operation for one or more
// supplied conditions. I.e. the Xor function returns TRUE if an odd number
// of the supplied conditions evaluate to TRUE, and FALSE otherwise. The
// syntax of the function is:
//
//	XOR(logical_test1,[logical_test2],...)
func (fn *formulaFuncs) XOR(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "XOR requires at least 1 argument")
	}
	return calcXor(argsList)
}

// Date and Time Functions

// DATE returns a date, from a user-supplied year, month and day. The syntax
// of the function is:
//
//	DATE(year,month,day)
