// Copyright 2016 - 2025 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.24.0 or later.

package excelize

import (
	"container/list"
	"fmt"
	"net/url"
	"regexp"
	"strconv"
	"strings"
	"unicode/utf8"
)

func (fn *formulaFuncs) IF(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "IF requires at least 1 argument")
	}
	if argsList.Len() > 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "IF accepts at most 3 arguments")
	}
	token := argsList.Front().Value.(formulaArg)
	var (
		cond   bool
		err    error
		result formulaArg
	)
	switch token.Type {
	case ArgString:
		if cond, err = strconv.ParseBool(token.Value()); err != nil {
			return newErrorFormulaArg(formulaErrorVALUE, err.Error())
		}
	case ArgNumber:
		cond = token.Number == 1
	}

	if argsList.Len() == 1 {
		return newBoolFormulaArg(cond)
	}
	if cond {
		value := argsList.Front().Next().Value.(formulaArg)
		switch value.Type {
		case ArgNumber:
			result = value.ToNumber()
		default:
			result = newStringFormulaArg(value.Value())
		}
		return result
	}
	if argsList.Len() == 3 {
		value := argsList.Back().Value.(formulaArg)
		switch value.Type {
		case ArgNumber:
			result = value.ToNumber()
		default:
			result = newStringFormulaArg(value.Value())
		}
	}
	return result
}

// Lookup and Reference Functions

// ADDRESS function takes a row and a column number and returns a cell
// reference as a text string. The syntax of the function is:
//
//	ADDRESS(row_num,column_num,[abs_num],[a1],[sheet_text])
func (fn *formulaFuncs) ADDRESS(argsList *list.List) formulaArg {
	if argsList.Len() < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "ADDRESS requires at least 2 arguments")
	}
	if argsList.Len() > 5 {
		return newErrorFormulaArg(formulaErrorVALUE, "ADDRESS requires at most 5 arguments")
	}
	rowNum := argsList.Front().Value.(formulaArg).ToNumber()
	if rowNum.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	if rowNum.Number > TotalRows {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	colNum := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if colNum.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	absNum := newNumberFormulaArg(1)
	if argsList.Len() >= 3 {
		absNum = argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
		if absNum.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
	}
	if absNum.Number < 1 || absNum.Number > 4 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	a1 := newBoolFormulaArg(true)
	if argsList.Len() >= 4 {
		a1 = argsList.Front().Next().Next().Next().Value.(formulaArg).ToBool()
		if a1.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
	}
	var sheetText string
	if argsList.Len() == 5 {
		sheetText = fmt.Sprintf("%s!", argsList.Back().Value.(formulaArg).Value())
	}
	formatter := addressFmtMaps[fmt.Sprintf("%d_%s", int(absNum.Number), a1.Value())]
	addr, err := formatter(int(colNum.Number), int(rowNum.Number))
	if err != nil {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	return newStringFormulaArg(fmt.Sprintf("%s%s", sheetText, addr))
}

// ANCHORARRAY function returns the entire spilled range for the dynamic array
// in cell. The syntax of the function is:
//
//	ANCHORARRAY(cell)
func (fn *formulaFuncs) ANCHORARRAY(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ANCHORARRAY requires 1 numeric argument")
	}
	ws, err := fn.f.workSheetReader(fn.sheet)
	if err != nil {
		return newErrorFormulaArg(formulaErrorVALUE, err.Error())
	}
	ref := argsList.Front().Value.(formulaArg).cellRefs.Front().Value.(cellRef)
	cell := ws.SheetData.Row[ref.Row-1].C[ref.Col-1]
	if cell.F == nil {
		return newEmptyFormulaArg()
	}
	coordinates, err := rangeRefToCoordinates(cell.F.Ref)
	if err != nil {
		return newErrorFormulaArg(formulaErrorVALUE, err.Error())
	}
	_ = sortCoordinates(coordinates)
	var mtx [][]formulaArg
	for c := coordinates[0]; c <= coordinates[2]; c++ {
		var row []formulaArg
		for r := coordinates[1]; r <= coordinates[3]; r++ {
			cellName, _ := CoordinatesToCellName(c, r)
			result, err := fn.f.CalcCellValue(ref.Sheet, cellName, Options{RawCellValue: true})
			if err != nil {
				return newErrorFormulaArg(formulaErrorVALUE, err.Error())
			}
			arg := newStringFormulaArg(result)
			if num := arg.ToNumber(); num.Type == ArgNumber {
				arg = num
			}
			row = append(row, arg)
		}
		mtx = append(mtx, row)
	}
	return newMatrixFormulaArg(mtx)
}

// CHOOSE function returns a value from an array, that corresponds to a
// supplied index number (position). The syntax of the function is:
//
//	CHOOSE(index_num,value1,[value2],...)
func (fn *formulaFuncs) CHOOSE(argsList *list.List) formulaArg {
	if argsList.Len() < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "CHOOSE requires 2 arguments")
	}
	idx, err := strconv.Atoi(argsList.Front().Value.(formulaArg).Value())
	if err != nil {
		return newErrorFormulaArg(formulaErrorVALUE, "CHOOSE requires first argument of type number")
	}
	if argsList.Len() <= idx {
		return newErrorFormulaArg(formulaErrorVALUE, "index_num should be <= to the number of values")
	}
	arg := argsList.Front()
	for i := 0; i < idx; i++ {
		arg = arg.Next()
	}
	return arg.Value.(formulaArg)
}

// matchPatternToRegExp convert find text pattern to regular expression.
func matchPatternToRegExp(findText string, dbcs bool) (string, bool) {
	var (
		exp      string
		wildCard bool
		mark     = "."
	)
	if dbcs {
		mark = "(?:(?:[\\x00-\\x0081])|(?:[\\xFF61-\\xFFA0])|(?:[\\xF8F1-\\xF8F4])|[0-9A-Za-z])"
	}
	for _, char := range findText {
		if strings.ContainsAny(string(char), ".+$^[](){}|/") {
			exp += fmt.Sprintf("\\%s", string(char))
			continue
		}
		if char == '?' {
			wildCard = true
			exp += mark
			continue
		}
		if char == '*' {
			wildCard = true
			exp += ".*"
			continue
		}
		exp += string(char)
	}
	return fmt.Sprintf("^%s", exp), wildCard
}

// matchPattern finds whether the text matches or satisfies the pattern
// string. The pattern supports '*' and '?' wildcards in the pattern string.
func matchPattern(findText, withinText string, dbcs bool, startNum int) (int, bool) {
	exp, wildCard := matchPatternToRegExp(findText, dbcs)
	offset := 1
	for idx := range withinText {
		if offset < startNum {
			offset++
			continue
		}
		if wildCard {
			if ok, _ := regexp.MatchString(exp, withinText[idx:]); ok {
				break
			}
		}
		if strings.Index(withinText[idx:], findText) == 0 {
			break
		}
		offset++
	}
	return offset, utf8.RuneCountInString(withinText) != offset-1
}

// compareFormulaArg compares the left-hand sides and the right-hand sides'
// formula arguments by given conditions such as case-sensitive, if exact
// match, and make compare result as formula criteria condition type.
func compareFormulaArg(lhs, rhs, matchMode formulaArg, caseSensitive bool) byte {
	if lhs.Type != rhs.Type {
		return criteriaNe
	}
	switch lhs.Type {
	case ArgNumber:
		if lhs.Number == rhs.Number {
			return criteriaEq
		}
		if lhs.Number < rhs.Number {
			return criteriaL
		}
		return criteriaG
	case ArgString:
		ls, rs := lhs.Value(), rhs.Value()
		if !caseSensitive {
			ls, rs = strings.ToLower(ls), strings.ToLower(rs)
		}
		if matchMode.Number == matchModeWildcard {
			if _, ok := matchPattern(rs, ls, false, 0); ok {
				return criteriaEq
			}
		}
		return map[int]byte{1: criteriaG, -1: criteriaL, 0: criteriaEq}[strings.Compare(ls, rs)]
	case ArgEmpty:
		return criteriaEq
	case ArgList:
		return compareFormulaArgList(lhs, rhs, matchMode, caseSensitive)
	case ArgMatrix:
		return compareFormulaArgMatrix(lhs, rhs, matchMode, caseSensitive)
	default:
		return criteriaErr
	}
}

// compareFormulaArgList compares the left-hand sides and the right-hand sides
// list type formula arguments.
func compareFormulaArgList(lhs, rhs, matchMode formulaArg, caseSensitive bool) byte {
	if len(lhs.List) < len(rhs.List) {
		return criteriaL
	}
	if len(lhs.List) > len(rhs.List) {
		return criteriaG
	}
	for arg := range lhs.List {
		criteria := compareFormulaArg(lhs.List[arg], rhs.List[arg], matchMode, caseSensitive)
		if criteria != criteriaEq {
			return criteria
		}
	}
	return criteriaEq
}

// compareFormulaArgMatrix compares the left-hand sides and the right-hand sides'
// matrix type formula arguments.
func compareFormulaArgMatrix(lhs, rhs, matchMode formulaArg, caseSensitive bool) byte {
	if len(lhs.Matrix) < len(rhs.Matrix) {
		return criteriaL
	}
	if len(lhs.Matrix) > len(rhs.Matrix) {
		return criteriaG
	}
	for i := range lhs.Matrix {
		left, right := lhs.Matrix[i], rhs.Matrix[i]
		if len(left) < len(right) {
			return criteriaL
		}
		if len(left) > len(right) {
			return criteriaG
		}
		for arg := range left {
			criteria := compareFormulaArg(left[arg], right[arg], matchMode, caseSensitive)
			if criteria != criteriaEq {
				return criteria
			}
		}
	}
	return criteriaEq
}

// COLUMN function returns the first column number within a supplied reference
// or the number of the current column. The syntax of the function is:
//
//	COLUMN([reference])
func (fn *formulaFuncs) COLUMN(argsList *list.List) formulaArg {
	if argsList.Len() > 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "COLUMN requires at most 1 argument")
	}
	if argsList.Len() == 1 {
		if argsList.Front().Value.(formulaArg).cellRanges != nil && argsList.Front().Value.(formulaArg).cellRanges.Len() > 0 {
			return newNumberFormulaArg(float64(argsList.Front().Value.(formulaArg).cellRanges.Front().Value.(cellRange).From.Col))
		}
		if argsList.Front().Value.(formulaArg).cellRefs != nil && argsList.Front().Value.(formulaArg).cellRefs.Len() > 0 {
			return newNumberFormulaArg(float64(argsList.Front().Value.(formulaArg).cellRefs.Front().Value.(cellRef).Col))
		}
		return newErrorFormulaArg(formulaErrorVALUE, "invalid reference")
	}
	col, _, _ := CellNameToCoordinates(fn.cell)
	return newNumberFormulaArg(float64(col))
}

// calcColsRowsMinMax calculation min and max value for given formula arguments
// sequence of the formula functions COLUMNS and ROWS.
func calcColsRowsMinMax(cols bool, argsList *list.List) (minVal, maxVal int) {
	getVal := func(cols bool, cell cellRef) int {
		if cols {
			return cell.Col
		}
		return cell.Row
	}
	if argsList.Front().Value.(formulaArg).cellRanges != nil && argsList.Front().Value.(formulaArg).cellRanges.Len() > 0 {
		crs := argsList.Front().Value.(formulaArg).cellRanges
		for cr := crs.Front(); cr != nil; cr = cr.Next() {
			if minVal == 0 {
				minVal = getVal(cols, cr.Value.(cellRange).From)
			}
			if maxVal < getVal(cols, cr.Value.(cellRange).To) {
				maxVal = getVal(cols, cr.Value.(cellRange).To)
			}
		}
	}
	if argsList.Front().Value.(formulaArg).cellRefs != nil && argsList.Front().Value.(formulaArg).cellRefs.Len() > 0 {
		cr := argsList.Front().Value.(formulaArg).cellRefs
		for refs := cr.Front(); refs != nil; refs = refs.Next() {
			if minVal == 0 {
				minVal = getVal(cols, refs.Value.(cellRef))
			}
			if maxVal < getVal(cols, refs.Value.(cellRef)) {
				maxVal = getVal(cols, refs.Value.(cellRef))
			}
		}
	}
	return
}

// COLUMNS function receives an Excel range and returns the number of columns
// that are contained within the range. The syntax of the function is:
//
//	COLUMNS(array)
func (fn *formulaFuncs) COLUMNS(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "COLUMNS requires 1 argument")
	}
	minVal, maxVal := calcColsRowsMinMax(true, argsList)
	if maxVal == MaxColumns {
		return newNumberFormulaArg(float64(MaxColumns))
	}
	result := maxVal - minVal + 1
	if maxVal == minVal {
		if minVal == 0 {
			return newErrorFormulaArg(formulaErrorVALUE, "invalid reference")
		}
		return newNumberFormulaArg(float64(1))
	}
	return newNumberFormulaArg(float64(result))
}

// FORMULATEXT function returns a formula as a text string. The syntax of the
// function is:
//
//	FORMULATEXT(reference)
func (fn *formulaFuncs) FORMULATEXT(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "FORMULATEXT requires 1 argument")
	}
	refs := argsList.Front().Value.(formulaArg).cellRefs
	col, row := 0, 0
	if refs != nil && refs.Len() > 0 {
		col, row = refs.Front().Value.(cellRef).Col, refs.Front().Value.(cellRef).Row
	}
	ranges := argsList.Front().Value.(formulaArg).cellRanges
	if ranges != nil && ranges.Len() > 0 {
		col, row = ranges.Front().Value.(cellRange).From.Col, ranges.Front().Value.(cellRange).From.Row
	}
	cell, err := CoordinatesToCellName(col, row)
	if err != nil {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	formula, _ := fn.f.GetCellFormula(fn.sheet, cell)
	return newStringFormulaArg(formula)
}

// checkHVLookupArgs checking arguments, prepare extract mode, lookup value,
// and data for the formula functions HLOOKUP and VLOOKUP.
func checkHVLookupArgs(name string, argsList *list.List) (idx int, lookupValue, tableArray, matchMode, errArg formulaArg) {
	unit := map[string]string{
		"HLOOKUP": "row",
		"VLOOKUP": "col",
	}[name]
	if argsList.Len() < 3 {
		errArg = newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires at least 3 arguments", name))
		return
	}
	if argsList.Len() > 4 {
		errArg = newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires at most 4 arguments", name))
		return
	}
	lookupValue = argsList.Front().Value.(formulaArg)
	tableArray = argsList.Front().Next().Value.(formulaArg)
	if tableArray.Type != ArgMatrix {
		errArg = newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires second argument of table array", name))
		return
	}
	arg := argsList.Front().Next().Next().Value.(formulaArg)
	if arg.Type != ArgNumber || arg.Boolean {
		errArg = newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires numeric %s argument", name, unit))
		return
	}
	idx, matchMode = int(arg.Number)-1, newNumberFormulaArg(matchModeMaxLess)
	if argsList.Len() == 4 {
		rangeLookup := argsList.Back().Value.(formulaArg).ToBool()
		if rangeLookup.Type == ArgError {
			errArg = rangeLookup
			return
		}
		if rangeLookup.Number == 0 {
			matchMode = newNumberFormulaArg(matchModeWildcard)
		}
	}
	return
}

// HLOOKUP function 'looks up' a given value in the top row of a data array
// (or table), and returns the corresponding value from another row of the
// array. The syntax of the function is:
//
//	HLOOKUP(lookup_value,table_array,row_index_num,[range_lookup])
func (fn *formulaFuncs) HLOOKUP(argsList *list.List) formulaArg {
	rowIdx, lookupValue, tableArray, matchMode, errArg := checkHVLookupArgs("HLOOKUP", argsList)
	if errArg.Type == ArgError {
		return errArg
	}
	var matchIdx int
	var wasExact bool
	if matchMode.Number == matchModeWildcard || len(tableArray.Matrix) == TotalRows {
		matchIdx, wasExact = lookupLinearSearch(false, lookupValue, tableArray, matchMode, newNumberFormulaArg(searchModeLinear))
	} else {
		matchIdx, wasExact = lookupBinarySearch(false, lookupValue, tableArray, matchMode, newNumberFormulaArg(searchModeAscBinary))
	}
	if matchIdx == -1 {
		return newErrorFormulaArg(formulaErrorNA, "HLOOKUP no result found")
	}
	if rowIdx < 0 || rowIdx >= len(tableArray.Matrix) {
		return newErrorFormulaArg(formulaErrorNA, "HLOOKUP has invalid row index")
	}
	row := tableArray.Matrix[rowIdx]
	if wasExact || matchMode.Number == matchModeWildcard {
		return row[matchIdx]
	}
	return newErrorFormulaArg(formulaErrorNA, "HLOOKUP no result found")
}

// HYPERLINK function creates a hyperlink to a specified location. The syntax
// of the function is:
//
//	HYPERLINK(link_location,[friendly_name])
func (fn *formulaFuncs) HYPERLINK(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "HYPERLINK requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "HYPERLINK allows at most 2 arguments")
	}
	return newStringFormulaArg(argsList.Back().Value.(formulaArg).Value())
}

// calcMatch returns the position of the value by given match type, criteria
// and lookup array for the formula function MATCH.
// matchType only contains -1, and 1.
func calcMatchMatrix(vertical bool, matchType int, criteria *formulaCriteria, lookupArray [][]formulaArg) formulaArg {
	idx := -1
	calc := func(i int, arg formulaArg) bool {
		switch matchType {
		case -1:
			if ok, _ := formulaCriteriaEval(arg, &formulaCriteria{
				Type: criteriaGe, Condition: criteria.Condition,
			}); ok {
				idx = i
				return false
			}
			if criteria.Condition.Type == ArgNumber {
				return true
			}
		case 1:
			if ok, _ := formulaCriteriaEval(arg, &formulaCriteria{
				Type: criteriaLe, Condition: criteria.Condition,
			}); ok {
				idx = i
				return false
			}
			if criteria.Condition.Type == ArgNumber {
				return true
			}
		}
		return false
	}

	if vertical {
		for i, row := range lookupArray {
			if ok := calc(i, row[0]); ok {
				break
			}
		}
	} else {
		for i, cell := range lookupArray[0] {
			if ok := calc(i, cell); ok {
				break
			}
		}
	}
	if idx == -1 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	return newNumberFormulaArg(float64(idx + 1))
}

// calcMatch returns the position of the value by given match type, criteria
// and lookup array for the formula function MATCH.
func calcMatch(matchType int, criteria *formulaCriteria, lookupArray []formulaArg) formulaArg {
	idx := -1
	switch matchType {
	case 0:
		for i, arg := range lookupArray {
			if ok, _ := formulaCriteriaEval(arg, criteria); ok {
				return newNumberFormulaArg(float64(i + 1))
			}
		}
	case -1:
		for i, arg := range lookupArray {
			if ok, _ := formulaCriteriaEval(arg, &formulaCriteria{
				Type: criteriaGe, Condition: criteria.Condition,
			}); ok {
				idx = i
				continue
			}
			if criteria.Condition.Type == ArgNumber {
				break
			}
		}
	case 1:
		for i, arg := range lookupArray {
			if ok, _ := formulaCriteriaEval(arg, &formulaCriteria{
				Type: criteriaLe, Condition: criteria.Condition,
			}); ok {
				idx = i
				continue
			}
			if criteria.Condition.Type == ArgNumber {
				break
			}
		}
	}
	if idx == -1 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	return newNumberFormulaArg(float64(idx + 1))
}

// MATCH function looks up a value in an array, and returns the position of
// the value within the array. The user can specify that the function should
// only return a result if an exact match is found, or that the function
// should return the position of the closest match (above or below), if an
// exact match is not found. The syntax of the Match function is:
//
//	MATCH(lookup_value,lookup_array,[match_type])
func (fn *formulaFuncs) MATCH(argsList *list.List) formulaArg {
	if argsList.Len() != 2 && argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "MATCH requires 1 or 2 arguments")
	}
	var (
		matchType      = 1
		lookupArray    []formulaArg
		lookupArrayArg = argsList.Front().Next().Value.(formulaArg)
		lookupArrayErr = "MATCH arguments lookup_array should be one-dimensional array"
	)
	if argsList.Len() == 3 {
		matchTypeArg := argsList.Back().Value.(formulaArg).ToNumber()
		if matchTypeArg.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorVALUE, "MATCH requires numeric match_type argument")
		}
		if matchTypeArg.Number == -1 || matchTypeArg.Number == 0 {
			matchType = int(matchTypeArg.Number)
		}
	}
	switch lookupArrayArg.Type {
	case ArgMatrix:
		if len(lookupArrayArg.Matrix) != 1 && len(lookupArrayArg.Matrix[0]) != 1 {
			return newErrorFormulaArg(formulaErrorNA, lookupArrayErr)
		}
		lookupArray = lookupArrayArg.ToList()
	default:
		return newErrorFormulaArg(formulaErrorNA, lookupArrayErr)
	}
	return calcMatch(matchType, formulaCriteriaParser(argsList.Front().Value.(formulaArg)), lookupArray)
}

// TRANSPOSE function 'transposes' an array of cells (i.e. the function copies
// a horizontal range of cells into a vertical range and vice versa). The
// syntax of the function is:
//
//	TRANSPOSE(array)
func (fn *formulaFuncs) TRANSPOSE(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "TRANSPOSE requires 1 argument")
	}
	args := argsList.Back().Value.(formulaArg).ToList()
	rmin, rmax := calcColsRowsMinMax(false, argsList)
	cmin, cmax := calcColsRowsMinMax(true, argsList)
	cols, rows := cmax-cmin+1, rmax-rmin+1
	src := make([][]formulaArg, 0)
	for i := 0; i < len(args); i += cols {
		src = append(src, args[i:i+cols])
	}
	mtx := make([][]formulaArg, cols)
	for r, row := range src {
		colIdx := r % rows
		for c, cell := range row {
			rowIdx := c % cols
			if len(mtx[rowIdx]) == 0 {
				mtx[rowIdx] = make([]formulaArg, rows)
			}
			mtx[rowIdx][colIdx] = cell
		}
	}
	return newMatrixFormulaArg(mtx)
}

// lookupLinearSearch sequentially checks each look value of the lookup array until
// a match is found or the whole list has been searched.
func lookupLinearSearch(vertical bool, lookupValue, lookupArray, matchMode, searchMode formulaArg) (int, bool) {
	matchIdx, wasExact := -1, false
	linearSearch := func(i int, cell, lhs formulaArg) bool {
		if lookupValue.Type == ArgNumber {
			if lhs = cell.ToNumber(); lhs.Type == ArgError {
				lhs = cell
			}
		} else if lookupValue.Type == ArgMatrix {
			lhs = lookupArray
		} else if lookupArray.Type == ArgString {
			lhs = newStringFormulaArg(cell.Value())
		}
		if compareFormulaArg(lhs, lookupValue, matchMode, false) == criteriaEq {
			matchIdx = i
			wasExact = true
			if searchMode.Number == searchModeLinear {
				return true
			}
		}
		if matchMode.Number == matchModeMinGreater || matchMode.Number == matchModeMaxLess {
			matchIdx = int(calcMatchMatrix(vertical, int(matchMode.Number), formulaCriteriaParser(lookupValue), lookupArray.Matrix).Number)
			return false
		}
		return false
	}

	if vertical {
		for i, row := range lookupArray.Matrix {
			lhs := row[0]
			if linearSearch(i, lhs, lhs) {
				break
			}
		}
	} else {
		for i, lhs := range lookupArray.Matrix[0] {
			if linearSearch(i, lhs, lhs) {
				break
			}
		}
	}
	return matchIdx, wasExact
}

// VLOOKUP function 'looks up' a given value in the left-hand column of a
// data array (or table), and returns the corresponding value from another
// column of the array. The syntax of the function is:
//
//	VLOOKUP(lookup_value,table_array,col_index_num,[range_lookup])
func (fn *formulaFuncs) VLOOKUP(argsList *list.List) formulaArg {
	colIdx, lookupValue, tableArray, matchMode, errArg := checkHVLookupArgs("VLOOKUP", argsList)
	if errArg.Type == ArgError {
		return errArg
	}
	var matchIdx int
	var wasExact bool
	if matchMode.Number == matchModeWildcard || len(tableArray.Matrix) == TotalRows {
		matchIdx, wasExact = lookupLinearSearch(true, lookupValue, tableArray, matchMode, newNumberFormulaArg(searchModeLinear))
	} else {
		matchIdx, wasExact = lookupBinarySearch(true, lookupValue, tableArray, matchMode, newNumberFormulaArg(searchModeAscBinary))
	}
	if matchIdx == -1 {
		return newErrorFormulaArg(formulaErrorNA, "VLOOKUP no result found")
	}
	mtx := tableArray.Matrix[matchIdx]
	if colIdx < 0 || colIdx >= len(mtx) {
		return newErrorFormulaArg(formulaErrorNA, "VLOOKUP has invalid column index")
	}
	if wasExact || matchMode.Number == matchModeWildcard {
		return mtx[colIdx]
	}
	return newErrorFormulaArg(formulaErrorNA, "VLOOKUP no result found")
}

// lookupBinarySearch finds the position of a target value when range lookup
// is TRUE, if the data of table array can't guarantee be sorted, it will
// return wrong result.
func lookupBinarySearch(vertical bool, lookupValue, lookupArray, matchMode, searchMode formulaArg) (matchIdx int, wasExact bool) {
	var tableArray []formulaArg
	if vertical {
		for _, row := range lookupArray.Matrix {
			tableArray = append(tableArray, row[0])
		}
	} else {
		tableArray = lookupArray.Matrix[0]
	}
	low, high, lastMatchIdx := 0, len(tableArray)-1, -1
	count := high
	for low <= high {
		mid := low + (high-low)/2
		cell := tableArray[mid]
		lhs := cell
		if lookupValue.Type == ArgNumber {
			if lhs = cell.ToNumber(); lhs.Type == ArgError {
				lhs = cell
			}
		} else if lookupValue.Type == ArgMatrix && vertical {
			lhs = lookupArray
		} else if lookupValue.Type == ArgString {
			lhs = newStringFormulaArg(cell.Value())
		}
		result := compareFormulaArg(lhs, lookupValue, matchMode, false)
		if result == criteriaEq {
			matchIdx, wasExact = mid, true
			if searchMode.Number == searchModeDescBinary {
				matchIdx = count - matchIdx
			}
			return
		} else if result == criteriaG {
			high = mid - 1
		} else if result == criteriaL {
			matchIdx = mid
			if cell.Type != ArgEmpty {
				lastMatchIdx = matchIdx
			}
			low = mid + 1
		} else {
			return -1, false
		}
	}
	matchIdx, wasExact = lastMatchIdx, true
	return
}

// checkLookupArgs checking arguments, prepare lookup value, and data for the
// formula function LOOKUP.
func checkLookupArgs(argsList *list.List) (arrayForm bool, lookupValue, lookupVector, errArg formulaArg) {
	if argsList.Len() < 2 {
		errArg = newErrorFormulaArg(formulaErrorVALUE, "LOOKUP requires at least 2 arguments")
		return
	}
	if argsList.Len() > 3 {
		errArg = newErrorFormulaArg(formulaErrorVALUE, "LOOKUP requires at most 3 arguments")
		return
	}
	lookupValue = newStringFormulaArg(argsList.Front().Value.(formulaArg).Value())
	lookupVector = argsList.Front().Next().Value.(formulaArg)
	if lookupVector.Type != ArgMatrix && lookupVector.Type != ArgList {
		errArg = newErrorFormulaArg(formulaErrorVALUE, "LOOKUP requires second argument of table array")
		return
	}
	arrayForm = lookupVector.Type == ArgMatrix
	if arrayForm && len(lookupVector.Matrix) == 0 {
		errArg = newErrorFormulaArg(formulaErrorVALUE, "LOOKUP requires not empty range as second argument")
	}
	return
}

// iterateLookupArgs iterate arguments to extract columns and calculate match
// index for the formula function LOOKUP.
func iterateLookupArgs(lookupValue, lookupVector formulaArg) ([]formulaArg, int, bool) {
	cols, matchIdx, ok := lookupCol(lookupVector, 0), -1, false
	for idx, col := range cols {
		lhs := lookupValue
		switch col.Type {
		case ArgNumber:
			lhs = lhs.ToNumber()
			if !col.Boolean {
				if lhs.Type == ArgError {
					lhs = lookupValue
				}
			}
		}
		compare := compareFormulaArg(lhs, col, newNumberFormulaArg(matchModeMaxLess), false)
		// Find exact match
		if compare == criteriaEq {
			matchIdx = idx
			break
		}
		// Find the nearest match if lookup value is more than or equal to the first value in lookup vector
		if idx == 0 {
			ok = compare == criteriaG
		} else if ok && compare == criteriaL && matchIdx == -1 {
			matchIdx = idx - 1
		}
	}
	return cols, matchIdx, ok
}

// index is an implementation of the formula function INDEX.
func (fn *formulaFuncs) index(array formulaArg, rowIdx, colIdx int) formulaArg {
	var cells []formulaArg
	if array.Type == ArgMatrix {
		cellMatrix := array.Matrix
		if rowIdx < -1 || rowIdx >= len(cellMatrix) {
			return newErrorFormulaArg(formulaErrorREF, "INDEX row_num out of range")
		}
		if rowIdx == -1 {
			if colIdx >= len(cellMatrix[0]) {
				return newErrorFormulaArg(formulaErrorREF, "INDEX col_num out of range")
			}
			var column [][]formulaArg
			for _, cells = range cellMatrix {
				column = append(column, []formulaArg{cells[colIdx]})
			}
			return newMatrixFormulaArg(column)
		}
		cells = cellMatrix[rowIdx]
	}
	if colIdx < -1 || colIdx >= len(cells) {
		return newErrorFormulaArg(formulaErrorREF, "INDEX col_num out of range")
	}
	return newListFormulaArg(cells)
}

// validateMatchMode check the number of match mode if be equal to 0, 1, -1 or
// 2.
func validateMatchMode(mode float64) bool {
	return mode == matchModeExact || mode == matchModeMinGreater || mode == matchModeMaxLess || mode == matchModeWildcard
}

// validateSearchMode check the number of search mode if be equal to 1, -1, 2
// or -2.
func validateSearchMode(mode float64) bool {
	return mode == searchModeLinear || mode == searchModeReverseLinear || mode == searchModeAscBinary || mode == searchModeDescBinary
}

// prepareXlookupArgs checking and prepare arguments for the formula function
// XLOOKUP.
func (fn *formulaFuncs) prepareXlookupArgs(argsList *list.List) formulaArg {
	if argsList.Len() < 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "XLOOKUP requires at least 3 arguments")
	}
	if argsList.Len() > 6 {
		return newErrorFormulaArg(formulaErrorVALUE, "XLOOKUP allows at most 6 arguments")
	}
	lookupValue := argsList.Front().Value.(formulaArg)
	lookupArray := argsList.Front().Next().Value.(formulaArg)
	returnArray := argsList.Front().Next().Next().Value.(formulaArg)
	ifNotFond := newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	matchMode, searchMode := newNumberFormulaArg(matchModeExact), newNumberFormulaArg(searchModeLinear)
	if argsList.Len() > 3 {
		ifNotFond = argsList.Front().Next().Next().Next().Value.(formulaArg)
	}
	if argsList.Len() > 4 {
		if matchMode = argsList.Front().Next().Next().Next().Next().Value.(formulaArg).ToNumber(); matchMode.Type != ArgNumber {
			return matchMode
		}
	}
	if argsList.Len() > 5 {
		if searchMode = argsList.Back().Value.(formulaArg).ToNumber(); searchMode.Type != ArgNumber {
			return searchMode
		}
	}
	if lookupArray.Type != ArgMatrix || returnArray.Type != ArgMatrix {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	if !validateMatchMode(matchMode.Number) || !validateSearchMode(searchMode.Number) {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	return newListFormulaArg([]formulaArg{lookupValue, lookupArray, returnArray, ifNotFond, matchMode, searchMode})
}

// xlookup is an implementation of the formula function XLOOKUP.
func (fn *formulaFuncs) xlookup(lookupRows, lookupCols, returnArrayRows, returnArrayCols, matchIdx int,
	condition1, condition2, condition3, condition4 bool, returnArray formulaArg,
) formulaArg {
	var result [][]formulaArg
	for rowIdx, row := range returnArray.Matrix {
		for colIdx, cell := range row {
			if condition1 {
				if condition2 {
					result = append(result, []formulaArg{cell})
					continue
				}
				if returnArrayRows > 1 && returnArrayCols > 1 {
					return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
				}
			}
			if condition3 {
				if returnArrayCols != lookupCols {
					return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
				}
				if colIdx == matchIdx {
					result = append(result, []formulaArg{cell})
					continue
				}
			}
			if condition4 {
				if returnArrayRows != lookupRows {
					return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
				}
				if rowIdx == matchIdx {
					if len(result) == 0 {
						result = append(result, []formulaArg{cell})
						continue
					}
					result[0] = append(result[0], cell)
				}
			}
		}
	}
	array := newMatrixFormulaArg(result)
	cells := array.ToList()
	if len(cells) == 1 {
		return cells[0]
	}
	return array
}

// XLOOKUP function searches a range or an array, and then returns the item
// corresponding to the first match it finds. If no match exists, then
// XLOOKUP can return the closest (approximate) match. The syntax of the
// function is:
//
//	XLOOKUP(lookup_value,lookup_array,return_array,[if_not_found],[match_mode],[search_mode])
func (fn *formulaFuncs) XLOOKUP(argsList *list.List) formulaArg {
	args := fn.prepareXlookupArgs(argsList)
	if args.Type != ArgList {
		return args
	}
	lookupValue, lookupArray, returnArray, ifNotFond, matchMode, searchMode := args.List[0], args.List[1], args.List[2], args.List[3], args.List[4], args.List[5]
	lookupRows, lookupCols := len(lookupArray.Matrix), 0
	if lookupRows > 0 {
		lookupCols = len(lookupArray.Matrix[0])
	}
	if lookupRows != 1 && lookupCols != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	verticalLookup := lookupRows >= lookupCols
	var matchIdx int
	switch searchMode.Number {
	case searchModeLinear, searchModeReverseLinear:
		matchIdx, _ = lookupLinearSearch(verticalLookup, lookupValue, lookupArray, matchMode, searchMode)
	default:
		matchIdx, _ = lookupBinarySearch(verticalLookup, lookupValue, lookupArray, matchMode, searchMode)
	}
	if matchIdx == -1 {
		return ifNotFond
	}
	returnArrayRows, returnArrayCols := len(returnArray.Matrix), len(returnArray.Matrix[0])
	condition1 := lookupRows == 1 && lookupCols == 1
	condition2 := returnArrayRows == 1 || returnArrayCols == 1
	condition3 := lookupRows == 1 && lookupCols > 1
	condition4 := lookupRows > 1 && lookupCols == 1
	return fn.xlookup(lookupRows, lookupCols, returnArrayRows, returnArrayCols, matchIdx, condition1, condition2, condition3, condition4, returnArray)
}

// INDEX function returns a reference to a cell that lies in a specified row
// and column of a range of cells. The syntax of the function is:
//
//	INDEX(array,row_num,[col_num])
func (fn *formulaFuncs) INDEX(argsList *list.List) formulaArg {
	if argsList.Len() < 2 || argsList.Len() > 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "INDEX requires 2 or 3 arguments")
	}
	array := argsList.Front().Value.(formulaArg)
	if array.Type != ArgMatrix && array.Type != ArgList {
		array = newMatrixFormulaArg([][]formulaArg{{array}})
	}
	rowArg := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if rowArg.Type != ArgNumber {
		return rowArg
	}
	rowIdx, colIdx := int(rowArg.Number)-1, -1
	if argsList.Len() == 3 {
		colArg := argsList.Back().Value.(formulaArg).ToNumber()
		if colArg.Type != ArgNumber {
			return colArg
		}
		colIdx = int(colArg.Number) - 1
	}
	if rowIdx == -1 && colIdx == -1 {
		if len(array.ToList()) != 1 {
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
		return array.ToList()[0]
	}
	cells := fn.index(array, rowIdx, colIdx)
	if cells.Type != ArgList {
		return cells
	}
	if colIdx == -1 {
		return newMatrixFormulaArg([][]formulaArg{cells.List})
	}
	return cells.List[colIdx]
}

// INDIRECT function converts a text string into a cell reference. The syntax
// of the Indirect function is:
//
//	INDIRECT(ref_text,[a1])
func (fn *formulaFuncs) INDIRECT(argsList *list.List) formulaArg {
	if argsList.Len() != 1 && argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "INDIRECT requires 1 or 2 arguments")
	}
	refText := argsList.Front().Value.(formulaArg).Value()
	a1 := newBoolFormulaArg(true)
	if argsList.Len() == 2 {
		if a1 = argsList.Back().Value.(formulaArg).ToBool(); a1.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
	}
	R1C1ToA1 := func(ref string) (cell string, err error) {
		parts := strings.Split(strings.TrimLeft(ref, "R"), "C")
		if len(parts) != 2 {
			return
		}
		row, err := strconv.Atoi(parts[0])
		if err != nil {
			return
		}
		col, err := strconv.Atoi(parts[1])
		if err != nil {
			return
		}
		cell, err = CoordinatesToCellName(col, row)
		return
	}
	refs := strings.Split(refText, ":")
	fromRef, toRef := refs[0], ""
	if len(refs) == 2 {
		toRef = refs[1]
	}
	if a1.Number == 0 {
		from, err := R1C1ToA1(refs[0])
		if err != nil {
			return newErrorFormulaArg(formulaErrorREF, formulaErrorREF)
		}
		fromRef = from
		if len(refs) == 2 {
			to, err := R1C1ToA1(refs[1])
			if err != nil {
				return newErrorFormulaArg(formulaErrorREF, formulaErrorREF)
			}
			toRef = to
		}
	}
	if len(refs) == 1 {
		value, err := fn.f.GetCellValue(fn.sheet, fromRef)
		if err != nil {
			return newErrorFormulaArg(formulaErrorREF, formulaErrorREF)
		}
		return newStringFormulaArg(value)
	}
	arg, _ := fn.f.parseReference(fn.ctx, fn.sheet, fromRef+":"+toRef)
	return arg
}

// LOOKUP function performs an approximate match lookup in a one-column or
// one-row range, and returns the corresponding value from another one-column
// or one-row range. The syntax of the function is:
//
//	LOOKUP(lookup_value,lookup_vector,[result_vector])
func (fn *formulaFuncs) LOOKUP(argsList *list.List) formulaArg {
	arrayForm, lookupValue, lookupVector, errArg := checkLookupArgs(argsList)
	if errArg.Type == ArgError {
		return errArg
	}
	cols, matchIdx, ok := iterateLookupArgs(lookupValue, lookupVector)
	if ok && matchIdx == -1 {
		matchIdx = len(cols) - 1
	}
	var column []formulaArg
	if argsList.Len() == 3 {
		column = lookupCol(argsList.Back().Value.(formulaArg), 0)
	} else if arrayForm && len(lookupVector.Matrix[0]) > 1 {
		column = lookupCol(lookupVector, 1)
	} else {
		column = cols
	}
	if matchIdx < 0 || matchIdx >= len(column) {
		return newErrorFormulaArg(formulaErrorNA, "LOOKUP no result found")
	}
	return column[matchIdx]
}

// lookupCol extract columns for LOOKUP.
func lookupCol(arr formulaArg, idx int) []formulaArg {
	col := arr.List
	if arr.Type == ArgMatrix {
		col = nil
		for _, r := range arr.Matrix {
			if len(r) > 0 {
				col = append(col, r[idx])
				continue
			}
			col = append(col, newEmptyFormulaArg())
		}
	}
	return col
}

// ROW function returns the first row number within a supplied reference or
// the number of the current row. The syntax of the function is:
//
//	ROW([reference])
func (fn *formulaFuncs) ROW(argsList *list.List) formulaArg {
	if argsList.Len() > 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ROW requires at most 1 argument")
	}
	if argsList.Len() == 1 {
		if argsList.Front().Value.(formulaArg).cellRanges != nil && argsList.Front().Value.(formulaArg).cellRanges.Len() > 0 {
			return newNumberFormulaArg(float64(argsList.Front().Value.(formulaArg).cellRanges.Front().Value.(cellRange).From.Row))
		}
		if argsList.Front().Value.(formulaArg).cellRefs != nil && argsList.Front().Value.(formulaArg).cellRefs.Len() > 0 {
			return newNumberFormulaArg(float64(argsList.Front().Value.(formulaArg).cellRefs.Front().Value.(cellRef).Row))
		}
		return newErrorFormulaArg(formulaErrorVALUE, "invalid reference")
	}
	_, row, _ := CellNameToCoordinates(fn.cell)
	return newNumberFormulaArg(float64(row))
}

// ROWS function takes an Excel range and returns the number of rows that are
// contained within the range. The syntax of the function is:
//
//	ROWS(array)
func (fn *formulaFuncs) ROWS(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ROWS requires 1 argument")
	}
	minVal, maxVal := calcColsRowsMinMax(false, argsList)
	if maxVal == TotalRows {
		return newNumberFormulaArg(TotalRows)
	}
	result := maxVal - minVal + 1
	if maxVal == minVal {
		if minVal == 0 {
			return newErrorFormulaArg(formulaErrorVALUE, "invalid reference")
		}
		return newNumberFormulaArg(float64(1))
	}
	return newNumberFormulaArg(float64(result))
}

// Web Functions

// ENCODEURL function returns a URL-encoded string, replacing certain
// non-alphanumeric characters with the percentage symbol (%) and a
// hexadecimal number. The syntax of the function is:
//
//	ENCODEURL(url)
func (fn *formulaFuncs) ENCODEURL(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ENCODEURL requires 1 argument")
	}
	token := argsList.Front().Value.(formulaArg).Value()
	return newStringFormulaArg(strings.ReplaceAll(url.QueryEscape(token), "+", "%20"))
}

// Financial Functions

// validateFrequency check the number of coupon payments per year if be equal to 1, 2 or 4.
