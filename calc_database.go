// Copyright 2016 - 2025 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.24.0 or later.

package excelize

import (
	"container/list"
	"fmt"
	"strings"
)

// Database Functions

// calcDatabase defines the structure for formula database.
type calcDatabase struct {
	col, row int
	indexMap map[int]int
	database [][]formulaArg
	criteria [][]formulaArg
}

// newCalcDatabase function returns formula database by given data range of
// cells containing the database, field and criteria range.
func newCalcDatabase(database, field, criteria formulaArg) *calcDatabase {
	db := calcDatabase{
		indexMap: make(map[int]int),
		database: database.Matrix,
		criteria: criteria.Matrix,
	}
	exp := len(database.Matrix) < 2 || len(database.Matrix[0]) < 1 ||
		len(criteria.Matrix) < 2 || len(criteria.Matrix[0]) < 1
	if field.Type != ArgEmpty {
		if db.col = db.columnIndex(database.Matrix, field); exp || db.col < 0 || len(db.database[0]) <= db.col {
			return nil
		}
		return &db
	}
	if db.col = -1; exp {
		return nil
	}
	return &db
}

// columnIndex return index by specifies column field within the database for
// which user want to return the count of non-blank cells.
func (db *calcDatabase) columnIndex(database [][]formulaArg, field formulaArg) int {
	num := field.ToNumber()
	if num.Type != ArgNumber && len(database) > 0 {
		for i := 0; i < len(database[0]); i++ {
			if title := database[0][i]; strings.EqualFold(title.Value(), field.Value()) {
				return i
			}
		}
		return -1
	}
	return int(num.Number - 1)
}

// criteriaEval evaluate formula criteria expression.
func (db *calcDatabase) criteriaEval() bool {
	var (
		columns, rows = len(db.criteria[0]), len(db.criteria)
		criteria      = db.criteria
		k             int
		matched       bool
	)
	if len(db.indexMap) == 0 {
		fields := criteria[0]
		for j := 0; j < columns; j++ {
			if k = db.columnIndex(db.database, fields[j]); k < 0 {
				return false
			}
			db.indexMap[j] = k
		}
	}
	for i := 1; !matched && i < rows; i++ {
		matched = true
		for j := 0; matched && j < columns; j++ {
			criteriaExp := db.criteria[i][j]
			if criteriaExp.Value() == "" {
				continue
			}
			criteria := formulaCriteriaParser(criteriaExp)
			cell := db.database[db.row][db.indexMap[j]]
			matched, _ = formulaCriteriaEval(cell, criteria)
		}
	}
	return matched
}

// value returns the current cell value.
func (db *calcDatabase) value() formulaArg {
	if db.col == -1 {
		return db.database[db.row][len(db.database[db.row])-1]
	}
	return db.database[db.row][db.col]
}

// next will return true if find the matched cell in the database.
func (db *calcDatabase) next() bool {
	matched, rows := false, len(db.database)
	for !matched && db.row < rows {
		if db.row++; db.row < rows {
			matched = db.criteriaEval()
		}
	}
	return matched
}

// database is an implementation of the formula functions DAVERAGE, DMAX and DMIN.
func (fn *formulaFuncs) database(name string, argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires 3 arguments", name))
	}
	database := argsList.Front().Value.(formulaArg)
	field := argsList.Front().Next().Value.(formulaArg)
	criteria := argsList.Back().Value.(formulaArg)
	db := newCalcDatabase(database, field, criteria)
	if db == nil {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	args := list.New()
	for db.next() {
		args.PushBack(db.value())
	}
	switch name {
	case "DMAX":
		return fn.MAX(args)
	case "DMIN":
		return fn.MIN(args)
	case "DPRODUCT":
		return fn.PRODUCT(args)
	case "DSTDEV":
		return fn.STDEV(args)
	case "DSTDEVP":
		return fn.STDEVP(args)
	case "DSUM":
		return fn.SUM(args)
	case "DVAR":
		return fn.VAR(args)
	case "DVARP":
		return fn.VARP(args)
	default:
		return fn.AVERAGE(args)
	}
}

// DAVERAGE function calculates the average (statistical mean) of values in a
// field (column) in a database for selected records, that satisfy
// user-specified criteria. The syntax of the function is:
//
//	DAVERAGE(database,field,criteria)
func (fn *formulaFuncs) DAVERAGE(argsList *list.List) formulaArg {
	return fn.database("DAVERAGE", argsList)
}

// dcount is an implementation of the formula functions DCOUNT and DCOUNTA.
func (fn *formulaFuncs) dcount(name string, argsList *list.List) formulaArg {
	if argsList.Len() < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires at least 2 arguments", name))
	}
	if argsList.Len() > 3 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s allows at most 3 arguments", name))
	}
	field := newEmptyFormulaArg()
	criteria := argsList.Back().Value.(formulaArg)
	if argsList.Len() > 2 {
		field = argsList.Front().Next().Value.(formulaArg)
	}
	database := argsList.Front().Value.(formulaArg)
	db := newCalcDatabase(database, field, criteria)
	if db == nil {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	args := list.New()
	for db.next() {
		args.PushBack(db.value())
	}
	if name == "DCOUNT" {
		return fn.COUNT(args)
	}
	return fn.COUNTA(args)
}

// DCOUNT function returns the number of cells containing numeric values, in a
// field (column) of a database for selected records only. The records to be
// included in the count are those that satisfy a set of one or more
// user-specified criteria. The syntax of the function is:
//
//	DCOUNT(database,[field],criteria)
func (fn *formulaFuncs) DCOUNT(argsList *list.List) formulaArg {
	return fn.dcount("DCOUNT", argsList)
}

// DCOUNTA function returns the number of non-blank cells, in a field
// (column) of a database for selected records only. The records to be
// included in the count are those that satisfy a set of one or more
// user-specified criteria. The syntax of the function is:
//
//	DCOUNTA(database,[field],criteria)
func (fn *formulaFuncs) DCOUNTA(argsList *list.List) formulaArg {
	return fn.dcount("DCOUNTA", argsList)
}

// DGET function returns a single value from a column of a database. The record
// is selected via a set of one or more user-specified criteria. The syntax of
// the function is:
//
//	DGET(database,field,criteria)
func (fn *formulaFuncs) DGET(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "DGET requires 3 arguments")
	}
	database := argsList.Front().Value.(formulaArg)
	field := argsList.Front().Next().Value.(formulaArg)
	criteria := argsList.Back().Value.(formulaArg)
	db := newCalcDatabase(database, field, criteria)
	if db == nil {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	value := newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	if db.next() {
		if value = db.value(); db.next() {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
	}
	return value
}

// DMAX function finds the maximum value in a field (column) in a database for
// selected records only. The records to be included in the calculation are
// defined by a set of one or more user-specified criteria. The syntax of the
// function is:
//
//	DMAX(database,field,criteria)
func (fn *formulaFuncs) DMAX(argsList *list.List) formulaArg {
	return fn.database("DMAX", argsList)
}

// DMIN function finds the minimum value in a field (column) in a database for
// selected records only. The records to be included in the calculation are
// defined by a set of one or more user-specified criteria. The syntax of the
// function is:
//
//	DMIN(database,field,criteria)
func (fn *formulaFuncs) DMIN(argsList *list.List) formulaArg {
	return fn.database("DMIN", argsList)
}

// DPRODUCT function calculates the product of a field (column) in a database
// for selected records, that satisfy user-specified criteria. The syntax of
// the function is:
//
//	DPRODUCT(database,field,criteria)
func (fn *formulaFuncs) DPRODUCT(argsList *list.List) formulaArg {
	return fn.database("DPRODUCT", argsList)
}

// DSTDEV function calculates the sample standard deviation of a field
// (column) in a database for selected records only. The records to be
// included in the calculation are defined by a set of one or more
// user-specified criteria. The syntax of the function is:
//
//	DSTDEV(database,field,criteria)
func (fn *formulaFuncs) DSTDEV(argsList *list.List) formulaArg {
	return fn.database("DSTDEV", argsList)
}

// DSTDEVP function calculates the standard deviation of a field (column) in a
// database for selected records only. The records to be included in the
// calculation are defined by a set of one or more user-specified criteria.
// The syntax of the function is:
//
//	DSTDEVP(database,field,criteria)
func (fn *formulaFuncs) DSTDEVP(argsList *list.List) formulaArg {
	return fn.database("DSTDEVP", argsList)
}

// DSUM function calculates the sum of a field (column) in a database for
// selected records, that satisfy user-specified criteria. The syntax of the
// function is:
//
//	DSUM(database,field,criteria)
func (fn *formulaFuncs) DSUM(argsList *list.List) formulaArg {
	return fn.database("DSUM", argsList)
}

// DVAR function calculates the sample variance of a field (column) in a
// database for selected records only. The records to be included in the
// calculation are defined by a set of one or more user-specified criteria.
// The syntax of the function is:
//
//	DVAR(database,field,criteria)
func (fn *formulaFuncs) DVAR(argsList *list.List) formulaArg {
	return fn.database("DVAR", argsList)
}

// DVARP function calculates the variance (for an entire population), of the
// values in a field (column) in a database for selected records only. The
// records to be included in the calculation are defined by a set of one or
// more user-specified criteria. The syntax of the function is:
//
//	DVARP(database,field,criteria)
func (fn *formulaFuncs) DVARP(argsList *list.List) formulaArg {
	return fn.database("DVARP", argsList)
}

// DISPIMG function calculates the Kingsoft WPS Office embedded image ID. The
// syntax of the function is:
//
//	DISPIMG(picture_name,display_mode)
func (fn *formulaFuncs) DISPIMG(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "DISPIMG requires 2 numeric arguments")
	}
	return argsList.Front().Value.(formulaArg)
}
