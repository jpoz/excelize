// Copyright 2016 - 2025 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.24.0 or later.

package excelize

import (
	"container/list"
	"math"
	"sort"
	"strconv"
	"strings"
	"time"
)

func (fn *formulaFuncs) DATE(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "DATE requires 3 number arguments")
	}
	year := argsList.Front().Value.(formulaArg).ToNumber()
	month := argsList.Front().Next().Value.(formulaArg).ToNumber()
	day := argsList.Back().Value.(formulaArg).ToNumber()
	if year.Type != ArgNumber || month.Type != ArgNumber || day.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, "DATE requires 3 number arguments")
	}
	d := makeDate(int(year.Number), time.Month(month.Number), int(day.Number))
	return newNumberFormulaArg(daysBetween(excelMinTime1900.Unix(), d) + 1)
}

// calcDateDif is an implementation of the formula function DATEDIF,
// calculation difference between two dates.
func calcDateDif(unit string, diff float64, seq []int, startArg, endArg formulaArg) float64 {
	ey, sy, em, sm, ed, sd := seq[0], seq[1], seq[2], seq[3], seq[4], seq[5]
	switch unit {
	case "d":
		diff = endArg.Number - startArg.Number
	case "md":
		smMD := em
		if ed < sd {
			smMD--
		}
		diff = endArg.Number - daysBetween(excelMinTime1900.Unix(), makeDate(ey, time.Month(smMD), sd)) - 1
	case "ym":
		diff = float64(em - sm)
		if ed < sd {
			diff--
		}
		if diff < 0 {
			diff += 12
		}
	case "yd":
		syYD := sy
		if em < sm || (em == sm && ed < sd) {
			syYD++
		}
		s := daysBetween(excelMinTime1900.Unix(), makeDate(syYD, time.Month(em), ed))
		e := daysBetween(excelMinTime1900.Unix(), makeDate(sy, time.Month(sm), sd))
		diff = s - e
	}
	return diff
}

// DATEDIF function calculates the number of days, months, or years between
// two dates. The syntax of the function is:
//
//	DATEDIF(start_date,end_date,unit)
func (fn *formulaFuncs) DATEDIF(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "DATEDIF requires 3 number arguments")
	}
	startArg, endArg := argsList.Front().Value.(formulaArg).ToNumber(), argsList.Front().Next().Value.(formulaArg).ToNumber()
	if startArg.Type != ArgNumber || endArg.Type != ArgNumber {
		return startArg
	}
	if startArg.Number > endArg.Number {
		return newErrorFormulaArg(formulaErrorNUM, "start_date > end_date")
	}
	if startArg.Number == endArg.Number {
		return newNumberFormulaArg(0)
	}
	unit := strings.ToLower(argsList.Back().Value.(formulaArg).Value())
	startDate, endDate := timeFromExcelTime(startArg.Number, false), timeFromExcelTime(endArg.Number, false)
	sy, smm, sd := startDate.Date()
	ey, emm, ed := endDate.Date()
	sm, em, diff := int(smm), int(emm), 0.0
	switch unit {
	case "y":
		diff = float64(ey - sy)
		if em < sm || (em == sm && ed < sd) {
			diff--
		}
	case "m":
		yDiff := ey - sy
		mDiff := em - sm
		if ed < sd {
			mDiff--
		}
		if mDiff < 0 {
			yDiff--
			mDiff += 12
		}
		diff = float64(yDiff*12 + mDiff)
	case "d", "md", "ym", "yd":
		diff = calcDateDif(unit, diff, []int{ey, sy, em, sm, ed, sd}, startArg, endArg)
	default:
		return newErrorFormulaArg(formulaErrorVALUE, "DATEDIF has invalid unit")
	}
	return newNumberFormulaArg(diff)
}

// isDateOnlyFmt check if the given string matches date-only format regular expressions.
func isDateOnlyFmt(dateString string) bool {
	for _, df := range dateOnlyFormats {
		subMatch := df.FindStringSubmatch(dateString)
		if len(subMatch) > 1 {
			return true
		}
	}
	return false
}

// isTimeOnlyFmt check if the given string matches time-only format regular expressions.
func isTimeOnlyFmt(timeString string) bool {
	for _, tf := range timeFormats {
		subMatch := tf.FindStringSubmatch(timeString)
		if len(subMatch) > 1 {
			return true
		}
	}
	return false
}

// strToTimePatternHandler1 parse and convert the given string in pattern
// hh to the time.
func strToTimePatternHandler1(subMatch []string) (h, m int, s float64, err error) {
	h, err = strconv.Atoi(subMatch[0])
	return
}

// strToTimePatternHandler2 parse and convert the given string in pattern
// hh:mm to the time.
func strToTimePatternHandler2(subMatch []string) (h, m int, s float64, err error) {
	if h, err = strconv.Atoi(subMatch[0]); err != nil {
		return
	}
	m, err = strconv.Atoi(subMatch[2])
	return
}

// strToTimePatternHandler3 parse and convert the given string in pattern
// mm:ss to the time.
func strToTimePatternHandler3(subMatch []string) (h, m int, s float64, err error) {
	if m, err = strconv.Atoi(subMatch[0]); err != nil {
		return
	}
	s, err = strconv.ParseFloat(subMatch[2], 64)
	return
}

// strToTimePatternHandler4 parse and convert the given string in pattern
// hh:mm:ss to the time.
func strToTimePatternHandler4(subMatch []string) (h, m int, s float64, err error) {
	if h, err = strconv.Atoi(subMatch[0]); err != nil {
		return
	}
	if m, err = strconv.Atoi(subMatch[2]); err != nil {
		return
	}
	s, err = strconv.ParseFloat(subMatch[4], 64)
	return
}

// strToTime parse and convert the given string to the time.
func strToTime(str string) (int, int, float64, bool, bool, formulaArg) {
	var subMatch []string
	pattern := ""
	for key, tf := range timeFormats {
		subMatch = tf.FindStringSubmatch(str)
		if len(subMatch) > 1 {
			pattern = key
			break
		}
	}
	if pattern == "" {
		return 0, 0, 0, false, false, newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	dateIsEmpty := subMatch[1] == ""
	subMatch = subMatch[49:]
	var (
		l              = len(subMatch)
		last           = subMatch[l-1]
		am             = last == "am"
		pm             = last == "pm"
		hours, minutes int
		seconds        float64
		err            error
	)
	if handler, ok := map[string]func(match []string) (int, int, float64, error){
		"hh":       strToTimePatternHandler1,
		"hh:mm":    strToTimePatternHandler2,
		"mm:ss":    strToTimePatternHandler3,
		"hh:mm:ss": strToTimePatternHandler4,
	}[pattern]; ok {
		if hours, minutes, seconds, err = handler(subMatch); err != nil {
			return 0, 0, 0, false, false, newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
	}
	if minutes >= 60 {
		return 0, 0, 0, false, false, newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	if am || pm {
		if hours > 12 || seconds >= 60 {
			return 0, 0, 0, false, false, newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		} else if hours == 12 {
			hours = 0
		}
	} else if hours >= 24 || seconds >= 10000 {
		return 0, 0, 0, false, false, newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	return hours, minutes, seconds, pm, dateIsEmpty, newEmptyFormulaArg()
}

// strToDatePatternHandler1 parse and convert the given string in pattern
// mm/dd/yy to the date.
func strToDatePatternHandler1(subMatch []string) (int, int, int, bool, error) {
	var year, month, day int
	var err error
	if month, err = strconv.Atoi(subMatch[1]); err != nil {
		return 0, 0, 0, false, err
	}
	if day, err = strconv.Atoi(subMatch[3]); err != nil {
		return 0, 0, 0, false, err
	}
	if year, err = strconv.Atoi(subMatch[5]); err != nil {
		return 0, 0, 0, false, err
	}
	if year < 0 || year > 9999 || (year > 99 && year < 1900) {
		return 0, 0, 0, false, ErrParameterInvalid
	}
	return formatYear(year), month, day, subMatch[8] == "", err
}

// strToDatePatternHandler2 parse and convert the given string in pattern mm
// dd, yy to the date.
func strToDatePatternHandler2(subMatch []string) (int, int, int, bool, error) {
	var year, month, day int
	var err error
	month = month2num[subMatch[1]]
	if day, err = strconv.Atoi(subMatch[14]); err != nil {
		return 0, 0, 0, false, err
	}
	if year, err = strconv.Atoi(subMatch[16]); err != nil {
		return 0, 0, 0, false, err
	}
	if year < 0 || year > 9999 || (year > 99 && year < 1900) {
		return 0, 0, 0, false, ErrParameterInvalid
	}
	return formatYear(year), month, day, subMatch[19] == "", err
}

// strToDatePatternHandler3 parse and convert the given string in pattern
// yy-mm-dd to the date.
func strToDatePatternHandler3(subMatch []string) (int, int, int, bool, error) {
	var year, month, day int
	v1, err := strconv.Atoi(subMatch[1])
	if err != nil {
		return 0, 0, 0, false, err
	}
	v2, err := strconv.Atoi(subMatch[3])
	if err != nil {
		return 0, 0, 0, false, err
	}
	v3, err := strconv.Atoi(subMatch[5])
	if err != nil {
		return 0, 0, 0, false, err
	}
	if v1 >= 1900 && v1 < 10000 {
		year = v1
		month = v2
		day = v3
	} else if v1 > 0 && v1 < 13 {
		month = v1
		day = v2
		year = v3
	} else {
		return 0, 0, 0, false, ErrParameterInvalid
	}
	return year, month, day, subMatch[8] == "", err
}

// strToDatePatternHandler4 parse and convert the given string in pattern
// yy-mmStr-dd, yy to the date.
func strToDatePatternHandler4(subMatch []string) (int, int, int, bool, error) {
	var year, month, day int
	var err error
	if year, err = strconv.Atoi(subMatch[16]); err != nil {
		return 0, 0, 0, false, err
	}
	month = month2num[subMatch[3]]
	if day, err = strconv.Atoi(subMatch[1]); err != nil {
		return 0, 0, 0, false, err
	}
	return formatYear(year), month, day, subMatch[19] == "", err
}

// strToDate parse and convert the given string to the date.
func strToDate(str string) (int, int, int, bool, formulaArg) {
	var subMatch []string
	pattern := ""
	for key, df := range dateFormats {
		subMatch = df.FindStringSubmatch(str)
		if len(subMatch) > 1 {
			pattern = key
			break
		}
	}
	if pattern == "" {
		return 0, 0, 0, false, newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	var (
		timeIsEmpty      bool
		year, month, day int
		err              error
	)
	if handler, ok := map[string]func(match []string) (int, int, int, bool, error){
		"mm/dd/yy":    strToDatePatternHandler1,
		"mm dd, yy":   strToDatePatternHandler2,
		"yy-mm-dd":    strToDatePatternHandler3,
		"yy-mmStr-dd": strToDatePatternHandler4,
	}[pattern]; ok {
		if year, month, day, timeIsEmpty, err = handler(subMatch); err != nil {
			return 0, 0, 0, false, newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
	}
	if !validateDate(year, month, day) {
		return 0, 0, 0, false, newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	return year, month, day, timeIsEmpty, newEmptyFormulaArg()
}

// DATEVALUE function converts a text representation of a date into an Excel
// date. For example, the function converts a text string representing a
// date, into the serial number that represents the date in Excels' date-time
// code. The syntax of the function is:
//
//	DATEVALUE(date_text)
func (fn *formulaFuncs) DATEVALUE(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "DATEVALUE requires 1 argument")
	}
	dateText := argsList.Front().Value.(formulaArg).Value()
	if !isDateOnlyFmt(dateText) {
		if _, _, _, _, _, err := strToTime(dateText); err.Type == ArgError {
			return err
		}
	}
	y, m, d, _, err := strToDate(dateText)
	if err.Type == ArgError {
		return err
	}
	return newNumberFormulaArg(daysBetween(excelMinTime1900.Unix(), makeDate(y, time.Month(m), d)) + 1)
}

// DAY function returns the day of a date, represented by a serial number. The
// day is given as an integer ranging from 1 to 31. The syntax of the
// function is:
//
//	DAY(serial_number)
func (fn *formulaFuncs) DAY(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "DAY requires exactly 1 argument")
	}
	arg := argsList.Front().Value.(formulaArg)
	num := arg.ToNumber()
	if num.Type != ArgNumber {
		dateString := strings.ToLower(arg.Value())
		if !isDateOnlyFmt(dateString) {
			if _, _, _, _, _, err := strToTime(dateString); err.Type == ArgError {
				return err
			}
		}
		_, _, day, _, err := strToDate(dateString)
		if err.Type == ArgError {
			return err
		}
		return newNumberFormulaArg(float64(day))
	}
	if num.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, "DAY only accepts positive argument")
	}
	if num.Number <= 60 {
		return newNumberFormulaArg(math.Mod(num.Number, 31.0))
	}
	return newNumberFormulaArg(float64(timeFromExcelTime(num.Number, false).Day()))
}

// DAYS function returns the number of days between two supplied dates. The
// syntax of the function is:
//
//	DAYS(end_date,start_date)
func (fn *formulaFuncs) DAYS(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "DAYS requires 2 arguments")
	}
	args := fn.prepareDataValueArgs(2, argsList)
	if args.Type != ArgList {
		return args
	}
	end, start := args.List[0], args.List[1]
	return newNumberFormulaArg(end.Number - start.Number)
}

// DAYS360 function returns the number of days between 2 dates, based on a
// 360-day year (12 x 30 months). The syntax of the function is:
//
//	DAYS360(start_date,end_date,[method])
func (fn *formulaFuncs) DAYS360(argsList *list.List) formulaArg {
	if argsList.Len() < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "DAYS360 requires at least 2 arguments")
	}
	if argsList.Len() > 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "DAYS360 requires at most 3 arguments")
	}
	startDate := toExcelDateArg(argsList.Front().Value.(formulaArg))
	if startDate.Type != ArgNumber {
		return startDate
	}
	endDate := toExcelDateArg(argsList.Front().Next().Value.(formulaArg))
	if endDate.Type != ArgNumber {
		return endDate
	}
	start, end := timeFromExcelTime(startDate.Number, false), timeFromExcelTime(endDate.Number, false)
	sy, sm, sd, ey, em, ed := start.Year(), int(start.Month()), start.Day(), end.Year(), int(end.Month()), end.Day()
	method := newBoolFormulaArg(false)
	if argsList.Len() > 2 {
		if method = argsList.Back().Value.(formulaArg).ToBool(); method.Type != ArgNumber {
			return method
		}
	}
	if method.Number == 1 {
		if sd == 31 {
			sd--
		}
		if ed == 31 {
			ed--
		}
	} else {
		if getDaysInMonth(sy, sm) == sd {
			sd = 30
		}
		if ed > 30 {
			if sd < 30 {
				em++
				ed = 1
			} else {
				ed = 30
			}
		}
	}
	return newNumberFormulaArg(float64(360*(ey-sy) + 30*(em-sm) + (ed - sd)))
}

// ISOWEEKNUM function returns the ISO week number of a supplied date. The
// syntax of the function is:
//
//	ISOWEEKNUM(date)
func (fn *formulaFuncs) ISOWEEKNUM(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ISOWEEKNUM requires 1 argument")
	}
	date := argsList.Front().Value.(formulaArg)
	num := date.ToNumber()
	weekNum := 0
	if num.Type != ArgNumber {
		dateString := strings.ToLower(date.Value())
		if !isDateOnlyFmt(dateString) {
			if _, _, _, _, _, err := strToTime(dateString); err.Type == ArgError {
				return err
			}
		}
		y, m, d, _, err := strToDate(dateString)
		if err.Type == ArgError {
			return err
		}
		_, weekNum = time.Date(y, time.Month(m), d, 0, 0, 0, 0, time.UTC).ISOWeek()
	} else {
		if num.Number < 0 {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
		_, weekNum = timeFromExcelTime(num.Number, false).ISOWeek()
	}
	return newNumberFormulaArg(float64(weekNum))
}

// EDATE function returns a date that is a specified number of months before or
// after a supplied start date. The syntax of function is:
//
//	EDATE(start_date,months)
func (fn *formulaFuncs) EDATE(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "EDATE requires 2 arguments")
	}
	date := argsList.Front().Value.(formulaArg)
	num := date.ToNumber()
	var dateTime time.Time
	if num.Type != ArgNumber {
		dateString := strings.ToLower(date.Value())
		if !isDateOnlyFmt(dateString) {
			if _, _, _, _, _, err := strToTime(dateString); err.Type == ArgError {
				return err
			}
		}
		y, m, d, _, err := strToDate(dateString)
		if err.Type == ArgError {
			return err
		}
		dateTime = time.Date(y, time.Month(m), d, 0, 0, 0, 0, time.Now().Location())
	} else {
		if num.Number < 0 {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
		dateTime = timeFromExcelTime(num.Number, false)
	}
	month := argsList.Back().Value.(formulaArg).ToNumber()
	if month.Type != ArgNumber {
		return month
	}
	y, d := dateTime.Year(), dateTime.Day()
	m := int(dateTime.Month()) + int(month.Number)
	if month.Number < 0 {
		y -= int(math.Ceil(-1 * float64(m) / 12))
	}
	if month.Number > 11 {
		y += int(math.Floor(float64(m) / 12))
	}
	if m = m % 12; m < 0 {
		m += 12
	}
	if d > 28 {
		if days := getDaysInMonth(y, m); d > days {
			d = days
		}
	}
	result, _ := timeToExcelTime(time.Date(y, time.Month(m), d, 0, 0, 0, 0, time.UTC), false)
	return newNumberFormulaArg(result)
}

// EOMONTH function returns the last day of the month, that is a specified
// number of months before or after an initial supplied start date. The syntax
// of the function is:
//
//	EOMONTH(start_date,months)
func (fn *formulaFuncs) EOMONTH(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "EOMONTH requires 2 arguments")
	}
	date := argsList.Front().Value.(formulaArg)
	num := date.ToNumber()
	var dateTime time.Time
	if num.Type != ArgNumber {
		dateString := strings.ToLower(date.Value())
		if !isDateOnlyFmt(dateString) {
			if _, _, _, _, _, err := strToTime(dateString); err.Type == ArgError {
				return err
			}
		}
		y, m, d, _, err := strToDate(dateString)
		if err.Type == ArgError {
			return err
		}
		dateTime = time.Date(y, time.Month(m), d, 0, 0, 0, 0, time.Now().Location())
	} else {
		if num.Number < 0 {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
		dateTime = timeFromExcelTime(num.Number, false)
	}
	months := argsList.Back().Value.(formulaArg).ToNumber()
	if months.Type != ArgNumber {
		return months
	}
	y, m := dateTime.Year(), int(dateTime.Month())+int(months.Number)-1
	if m < 0 {
		y -= int(math.Ceil(-1 * float64(m) / 12))
	}
	if m > 11 {
		y += int(math.Floor(float64(m) / 12))
	}
	if m = m % 12; m < 0 {
		m += 12
	}
	result, _ := timeToExcelTime(time.Date(y, time.Month(m+1), getDaysInMonth(y, m+1), 0, 0, 0, 0, time.UTC), false)
	return newNumberFormulaArg(result)
}

// HOUR function returns an integer representing the hour component of a
// supplied Excel time. The syntax of the function is:
//
//	HOUR(serial_number)
func (fn *formulaFuncs) HOUR(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "HOUR requires exactly 1 argument")
	}
	date := argsList.Front().Value.(formulaArg)
	num := date.ToNumber()
	if num.Type != ArgNumber {
		timeString := strings.ToLower(date.Value())
		if !isTimeOnlyFmt(timeString) {
			_, _, _, _, err := strToDate(timeString)
			if err.Type == ArgError {
				return err
			}
		}
		h, _, _, pm, _, err := strToTime(timeString)
		if err.Type == ArgError {
			return err
		}
		if pm {
			h += 12
		}
		return newNumberFormulaArg(float64(h))
	}
	if num.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, "HOUR only accepts positive argument")
	}
	return newNumberFormulaArg(float64(timeFromExcelTime(num.Number, false).Hour()))
}

// MINUTE function returns an integer representing the minute component of a
// supplied Excel time. The syntax of the function is:
//
//	MINUTE(serial_number)
func (fn *formulaFuncs) MINUTE(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "MINUTE requires exactly 1 argument")
	}
	date := argsList.Front().Value.(formulaArg)
	num := date.ToNumber()
	if num.Type != ArgNumber {
		timeString := strings.ToLower(date.Value())
		if !isTimeOnlyFmt(timeString) {
			_, _, _, _, err := strToDate(timeString)
			if err.Type == ArgError {
				return err
			}
		}
		_, m, _, _, _, err := strToTime(timeString)
		if err.Type == ArgError {
			return err
		}
		return newNumberFormulaArg(float64(m))
	}
	if num.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, "MINUTE only accepts positive argument")
	}
	return newNumberFormulaArg(float64(timeFromExcelTime(num.Number, false).Minute()))
}

// MONTH function returns the month of a date represented by a serial number.
// The month is given as an integer, ranging from 1 (January) to 12
// (December). The syntax of the function is:
//
//	MONTH(serial_number)
func (fn *formulaFuncs) MONTH(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "MONTH requires exactly 1 argument")
	}
	arg := argsList.Front().Value.(formulaArg)
	num := arg.ToNumber()
	if num.Type != ArgNumber {
		dateString := strings.ToLower(arg.Value())
		if !isDateOnlyFmt(dateString) {
			if _, _, _, _, _, err := strToTime(dateString); err.Type == ArgError {
				return err
			}
		}
		_, month, _, _, err := strToDate(dateString)
		if err.Type == ArgError {
			return err
		}
		return newNumberFormulaArg(float64(month))
	}
	if num.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, "MONTH only accepts positive argument")
	}
	return newNumberFormulaArg(float64(timeFromExcelTime(num.Number, false).Month()))
}

// genWeekendMask generate weekend mask of a series of seven 0's and 1's which
// represent the seven weekdays, starting from Monday.
func genWeekendMask(weekend int) []byte {
	if masks, ok := map[int][]int{
		1: {5, 6}, 2: {6, 0}, 3: {0, 1}, 4: {1, 2}, 5: {2, 3}, 6: {3, 4}, 7: {4, 5},
		11: {6}, 12: {0}, 13: {1}, 14: {2}, 15: {3}, 16: {4}, 17: {5},
	}[weekend]; ok {
		mask := make([]byte, 7)
		for _, idx := range masks {
			mask[idx] = 1
		}
		return mask
	}
	return nil
}

// isWorkday check if the date is workday.
func isWorkday(weekendMask []byte, date float64) bool {
	dateTime := timeFromExcelTime(date, false)
	weekday := dateTime.Weekday()
	if weekday == time.Sunday {
		weekday = 7
	}
	return weekendMask[weekday-1] == 0
}

// prepareWorkday returns weekend mask and workdays pre week by given days
// counted as weekend.
func prepareWorkday(weekend formulaArg) ([]byte, int) {
	weekendArg := weekend.ToNumber()
	if weekendArg.Type != ArgNumber {
		return nil, 0
	}
	var weekendMask []byte
	var workdaysPerWeek int
	if len(weekend.Value()) == 7 {
		// possible string values for the weekend argument
		for _, mask := range weekend.Value() {
			if mask != '0' && mask != '1' {
				return nil, 0
			}
			weekendMask = append(weekendMask, byte(mask)-48)
		}
	} else {
		weekendMask = genWeekendMask(int(weekendArg.Number))
	}
	for _, mask := range weekendMask {
		if mask == 0 {
			workdaysPerWeek++
		}
	}
	return weekendMask, workdaysPerWeek
}

// toExcelDateArg function converts a text representation of a time, into an
// Excel date time number formula argument.
func toExcelDateArg(arg formulaArg) formulaArg {
	num := arg.ToNumber()
	if num.Type != ArgNumber {
		dateString := strings.ToLower(arg.Value())
		if !isDateOnlyFmt(dateString) {
			if _, _, _, _, _, err := strToTime(dateString); err.Type == ArgError {
				return err
			}
		}
		y, m, d, _, err := strToDate(dateString)
		if err.Type == ArgError {
			return err
		}
		num.Number, _ = timeToExcelTime(time.Date(y, time.Month(m), d, 0, 0, 0, 0, time.UTC), false)
		return newNumberFormulaArg(num.Number)
	}
	if arg.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return num
}

// prepareHolidays function converts array type formula arguments to into an
// Excel date time number formula arguments list.
func prepareHolidays(args formulaArg) []int {
	var holidays []int
	for _, arg := range args.ToList() {
		num := toExcelDateArg(arg)
		if num.Type != ArgNumber {
			continue
		}
		holidays = append(holidays, int(math.Ceil(num.Number)))
	}
	return holidays
}

// workdayIntl is an implementation of the formula function WORKDAY.INTL.
func workdayIntl(endDate, sign int, holidays []int, weekendMask []byte, startDate float64) int {
	for i := 0; i < len(holidays); i++ {
		holiday := holidays[i]
		if sign > 0 {
			if holiday > endDate {
				break
			}
		} else {
			if holiday < endDate {
				break
			}
		}
		if sign > 0 {
			if holiday > int(math.Ceil(startDate)) {
				if isWorkday(weekendMask, float64(holiday)) {
					endDate += sign
					for !isWorkday(weekendMask, float64(endDate)) {
						endDate += sign
					}
				}
			}
		} else {
			if holiday < int(math.Ceil(startDate)) {
				if isWorkday(weekendMask, float64(holiday)) {
					endDate += sign
					for !isWorkday(weekendMask, float64(endDate)) {
						endDate += sign
					}
				}
			}
		}
	}
	return endDate
}

// NETWORKDAYS function calculates the number of work days between two supplied
// dates (including the start and end date). The calculation includes all
// weekdays (Mon - Fri), excluding a supplied list of holidays. The syntax of
// the function is:
//
//	NETWORKDAYS(start_date,end_date,[holidays])
func (fn *formulaFuncs) NETWORKDAYS(argsList *list.List) formulaArg {
	if argsList.Len() < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "NETWORKDAYS requires at least 2 arguments")
	}
	if argsList.Len() > 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "NETWORKDAYS requires at most 3 arguments")
	}
	args := list.New()
	args.PushBack(argsList.Front().Value.(formulaArg))
	args.PushBack(argsList.Front().Next().Value.(formulaArg))
	args.PushBack(newNumberFormulaArg(1))
	if argsList.Len() == 3 {
		args.PushBack(argsList.Back().Value.(formulaArg))
	}
	return fn.NETWORKDAYSdotINTL(args)
}

// NETWORKDAYSdotINTL function calculates the number of whole work days between
// two supplied dates, excluding weekends and holidays. The function allows
// the user to specify which days are counted as weekends and holidays. The
// syntax of the function is:
//
//	NETWORKDAYS.INTL(start_date,end_date,[weekend],[holidays])
func (fn *formulaFuncs) NETWORKDAYSdotINTL(argsList *list.List) formulaArg {
	if argsList.Len() < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "NETWORKDAYS.INTL requires at least 2 arguments")
	}
	if argsList.Len() > 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "NETWORKDAYS.INTL requires at most 4 arguments")
	}
	startDate := toExcelDateArg(argsList.Front().Value.(formulaArg))
	if startDate.Type != ArgNumber {
		return startDate
	}
	endDate := toExcelDateArg(argsList.Front().Next().Value.(formulaArg))
	if endDate.Type != ArgNumber {
		return endDate
	}
	weekend := newNumberFormulaArg(1)
	if argsList.Len() > 2 {
		weekend = argsList.Front().Next().Next().Value.(formulaArg)
	}
	var holidays []int
	if argsList.Len() == 4 {
		holidays = prepareHolidays(argsList.Back().Value.(formulaArg))
		sort.Ints(holidays)
	}
	weekendMask, workdaysPerWeek := prepareWorkday(weekend)
	if workdaysPerWeek == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	sign := 1
	if startDate.Number > endDate.Number {
		sign = -1
		startDate.Number, endDate.Number = endDate.Number, startDate.Number
	}
	offset := endDate.Number - startDate.Number
	count := int(math.Floor(offset/7) * float64(workdaysPerWeek))
	daysMod := int(offset) % 7
	for daysMod >= 0 {
		if isWorkday(weekendMask, endDate.Number-float64(daysMod)) {
			count++
		}
		daysMod--
	}
	for i := 0; i < len(holidays); i++ {
		holiday := float64(holidays[i])
		if isWorkday(weekendMask, holiday) && holiday >= startDate.Number && holiday <= endDate.Number {
			count--
		}
	}
	return newNumberFormulaArg(float64(sign * count))
}

// WORKDAY function returns a date that is a supplied number of working days
// (excluding weekends and holidays) ahead of a given start date. The syntax
// of the function is:
//
//	WORKDAY(start_date,days,[holidays])
func (fn *formulaFuncs) WORKDAY(argsList *list.List) formulaArg {
	if argsList.Len() < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "WORKDAY requires at least 2 arguments")
	}
	if argsList.Len() > 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "WORKDAY requires at most 3 arguments")
	}
	args := list.New()
	args.PushBack(argsList.Front().Value.(formulaArg))
	args.PushBack(argsList.Front().Next().Value.(formulaArg))
	args.PushBack(newNumberFormulaArg(1))
	if argsList.Len() == 3 {
		args.PushBack(argsList.Back().Value.(formulaArg))
	}
	return fn.WORKDAYdotINTL(args)
}

// WORKDAYdotINTL function returns a date that is a supplied number of working
// days (excluding weekends and holidays) ahead of a given start date. The
// function allows the user to specify which days of the week are counted as
// weekends. The syntax of the function is:
//
//	WORKDAY.INTL(start_date,days,[weekend],[holidays])
func (fn *formulaFuncs) WORKDAYdotINTL(argsList *list.List) formulaArg {
	if argsList.Len() < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "WORKDAY.INTL requires at least 2 arguments")
	}
	if argsList.Len() > 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "WORKDAY.INTL requires at most 4 arguments")
	}
	startDate := toExcelDateArg(argsList.Front().Value.(formulaArg))
	if startDate.Type != ArgNumber {
		return startDate
	}
	days := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if days.Type != ArgNumber {
		return days
	}
	weekend := newNumberFormulaArg(1)
	if argsList.Len() > 2 {
		weekend = argsList.Front().Next().Next().Value.(formulaArg)
	}
	var holidays []int
	if argsList.Len() == 4 {
		holidays = prepareHolidays(argsList.Back().Value.(formulaArg))
		sort.Ints(holidays)
	}
	if days.Number == 0 {
		return newNumberFormulaArg(math.Ceil(startDate.Number))
	}
	weekendMask, workdaysPerWeek := prepareWorkday(weekend)
	if workdaysPerWeek == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	sign := 1
	if days.Number < 0 {
		sign = -1
	}
	offset := int(days.Number) / workdaysPerWeek
	daysMod := int(days.Number) % workdaysPerWeek
	endDate := int(math.Ceil(startDate.Number)) + offset*7
	if daysMod == 0 {
		for !isWorkday(weekendMask, float64(endDate)) {
			endDate -= sign
		}
	} else {
		for daysMod != 0 {
			endDate += sign
			if isWorkday(weekendMask, float64(endDate)) {
				if daysMod < 0 {
					daysMod++
					continue
				}
				daysMod--
			}
		}
	}
	return newNumberFormulaArg(float64(workdayIntl(endDate, sign, holidays, weekendMask, startDate.Number)))
}

// YEAR function returns an integer representing the year of a supplied date.
// The syntax of the function is:
//
//	YEAR(serial_number)
func (fn *formulaFuncs) YEAR(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "YEAR requires exactly 1 argument")
	}
	arg := argsList.Front().Value.(formulaArg)
	num := arg.ToNumber()
	if num.Type != ArgNumber {
		dateString := strings.ToLower(arg.Value())
		if !isDateOnlyFmt(dateString) {
			if _, _, _, _, _, err := strToTime(dateString); err.Type == ArgError {
				return err
			}
		}
		year, _, _, _, err := strToDate(dateString)
		if err.Type == ArgError {
			return err
		}
		return newNumberFormulaArg(float64(year))
	}
	if num.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, "YEAR only accepts positive argument")
	}
	return newNumberFormulaArg(float64(timeFromExcelTime(num.Number, false).Year()))
}

// yearFracBasisCond is an implementation of the yearFracBasis1.
func yearFracBasisCond(sy, sm, sd, ey, em, ed int) bool {
	return (isLeapYear(sy) && (sm < 2 || (sm == 2 && sd <= 29))) || (isLeapYear(ey) && (em > 2 || (em == 2 && ed == 29)))
}

// yearFracBasis0 function returns the fraction of a year that between two
// supplied dates in US (NASD) 30/360 type of day.
func yearFracBasis0(startDate, endDate float64) (dayDiff, daysInYear float64) {
	startTime, endTime := timeFromExcelTime(startDate, false), timeFromExcelTime(endDate, false)
	sy, smM, sd := startTime.Date()
	ey, emM, ed := endTime.Date()
	sm, em := int(smM), int(emM)
	if sd == 31 {
		sd--
	}
	if sd == 30 && ed == 31 {
		ed--
	} else if leap := isLeapYear(sy); sm == 2 && ((leap && sd == 29) || (!leap && sd == 28)) {
		sd = 30
		if leap := isLeapYear(ey); em == 2 && ((leap && ed == 29) || (!leap && ed == 28)) {
			ed = 30
		}
	}
	dayDiff = float64((ey-sy)*360 + (em-sm)*30 + (ed - sd))
	daysInYear = 360
	return
}

// yearFracBasis1 function returns the fraction of a year that between two
// supplied dates in actual type of day.
func yearFracBasis1(startDate, endDate float64) (dayDiff, daysInYear float64) {
	startTime, endTime := timeFromExcelTime(startDate, false), timeFromExcelTime(endDate, false)
	sy, smM, sd := startTime.Date()
	ey, emM, ed := endTime.Date()
	sm, em := int(smM), int(emM)
	dayDiff = endDate - startDate
	isYearDifferent := sy != ey
	if isYearDifferent && (ey != sy+1 || sm < em || (sm == em && sd < ed)) {
		dayCount := 0
		for y := sy; y <= ey; y++ {
			dayCount += getYearDays(y, 1)
		}
		daysInYear = float64(dayCount) / float64(ey-sy+1)
	} else {
		if !isYearDifferent && isLeapYear(sy) {
			daysInYear = 366
		} else {
			if isYearDifferent && yearFracBasisCond(sy, sm, sd, ey, em, ed) {
				daysInYear = 366
			} else {
				daysInYear = 365
			}
		}
	}
	return
}

// yearFracBasis4 function returns the fraction of a year that between two
// supplied dates in European 30/360 type of day.
func yearFracBasis4(startDate, endDate float64) (dayDiff, daysInYear float64) {
	startTime, endTime := timeFromExcelTime(startDate, false), timeFromExcelTime(endDate, false)
	sy, smM, sd := startTime.Date()
	ey, emM, ed := endTime.Date()
	sm, em := int(smM), int(emM)
	if sd == 31 {
		sd--
	}
	if ed == 31 {
		ed--
	}
	dayDiff = float64((ey-sy)*360 + (em-sm)*30 + (ed - sd))
	daysInYear = 360
	return
}

// yearFrac is an implementation of the formula function YEARFRAC.
func yearFrac(startDate, endDate float64, basis int) formulaArg {
	startTime, endTime := timeFromExcelTime(startDate, false), timeFromExcelTime(endDate, false)
	if startTime == endTime {
		return newNumberFormulaArg(0)
	}
	var dayDiff, daysInYear float64
	switch basis {
	case 0:
		dayDiff, daysInYear = yearFracBasis0(startDate, endDate)
	case 1:
		dayDiff, daysInYear = yearFracBasis1(startDate, endDate)
	case 2:
		dayDiff = endDate - startDate
		daysInYear = 360
	case 3:
		dayDiff = endDate - startDate
		daysInYear = 365
	case 4:
		dayDiff, daysInYear = yearFracBasis4(startDate, endDate)
	default:
		return newErrorFormulaArg(formulaErrorNUM, "invalid basis")
	}
	return newNumberFormulaArg(dayDiff / daysInYear)
}

// getYearDays return days of the year with specifying the type of day count
// basis to be used.
func getYearDays(year, basis int) int {
	switch basis {
	case 1:
		if isLeapYear(year) {
			return 366
		}
		return 365
	case 3:
		return 365
	default:
		return 360
	}
}

// YEARFRAC function returns the fraction of a year that is represented by the
// number of whole days between two supplied dates. The syntax of the
// function is:
//
//	YEARFRAC(start_date,end_date,[basis])
func (fn *formulaFuncs) YEARFRAC(argsList *list.List) formulaArg {
	if argsList.Len() != 2 && argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "YEARFRAC requires 3 or 4 arguments")
	}
	args := fn.prepareDataValueArgs(2, argsList)
	if args.Type != ArgList {
		return args
	}
	start, end := args.List[0], args.List[1]
	basis := newNumberFormulaArg(0)
	if argsList.Len() == 3 {
		if basis = argsList.Back().Value.(formulaArg).ToNumber(); basis.Type != ArgNumber {
			return basis
		}
	}
	return yearFrac(start.Number, end.Number, int(basis.Number))
}

// NOW function returns the current date and time. The function receives no
// arguments and therefore. The syntax of the function is:
//
//	NOW()
func (fn *formulaFuncs) NOW(argsList *list.List) formulaArg {
	if argsList.Len() != 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "NOW accepts no arguments")
	}
	now := time.Now()
	_, offset := now.Zone()
	return newNumberFormulaArg(25569.0 + float64(now.Unix()+int64(offset))/86400)
}

// SECOND function returns an integer representing the second component of a
// supplied Excel time. The syntax of the function is:
//
//	SECOND(serial_number)
func (fn *formulaFuncs) SECOND(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "SECOND requires exactly 1 argument")
	}
	date := argsList.Front().Value.(formulaArg)
	num := date.ToNumber()
	if num.Type != ArgNumber {
		timeString := strings.ToLower(date.Value())
		if !isTimeOnlyFmt(timeString) {
			_, _, _, _, err := strToDate(timeString)
			if err.Type == ArgError {
				return err
			}
		}
		_, _, s, _, _, err := strToTime(timeString)
		if err.Type == ArgError {
			return err
		}
		return newNumberFormulaArg(float64(int(s) % 60))
	}
	if num.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, "SECOND only accepts positive argument")
	}
	return newNumberFormulaArg(float64(timeFromExcelTime(num.Number, false).Second()))
}

// TIME function accepts three integer arguments representing hours, minutes
// and seconds, and returns an Excel time. I.e. the function returns the
// decimal value that represents the time in Excel. The syntax of the
// function is:
//
//	TIME(hour,minute,second)
func (fn *formulaFuncs) TIME(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "TIME requires 3 number arguments")
	}
	h := argsList.Front().Value.(formulaArg).ToNumber()
	m := argsList.Front().Next().Value.(formulaArg).ToNumber()
	s := argsList.Back().Value.(formulaArg).ToNumber()
	if h.Type != ArgNumber || m.Type != ArgNumber || s.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, "TIME requires 3 number arguments")
	}
	t := (h.Number*3600 + m.Number*60 + s.Number) / 86400
	if t < 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(t)
}

// TIMEVALUE function converts a text representation of a time, into an Excel
// time. The syntax of the function is:
//
//	TIMEVALUE(time_text)
func (fn *formulaFuncs) TIMEVALUE(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "TIMEVALUE requires exactly 1 argument")
	}
	date := argsList.Front().Value.(formulaArg)
	timeString := strings.ToLower(date.Value())
	if !isTimeOnlyFmt(timeString) {
		_, _, _, _, err := strToDate(timeString)
		if err.Type == ArgError {
			return err
		}
	}
	h, m, s, pm, _, err := strToTime(timeString)
	if err.Type == ArgError {
		return err
	}
	if pm {
		h += 12
	}
	args := list.New()
	args.PushBack(newNumberFormulaArg(float64(h)))
	args.PushBack(newNumberFormulaArg(float64(m)))
	args.PushBack(newNumberFormulaArg(s))
	return fn.TIME(args)
}

// TODAY function returns the current date. The function has no arguments and
// therefore. The syntax of the function is:
//
//	TODAY()
func (fn *formulaFuncs) TODAY(argsList *list.List) formulaArg {
	if argsList.Len() != 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "TODAY accepts no arguments")
	}
	now := time.Now()
	_, offset := now.Zone()
	return newNumberFormulaArg(daysBetween(excelMinTime1900.Unix(), now.Unix()+int64(offset)) + 1)
}

// makeDate return date as a Unix time, the number of seconds elapsed since
// January 1, 1970 UTC.
func makeDate(y int, m time.Month, d int) int64 {
	if y == 1900 && int(m) <= 2 {
		d--
	}
	date := time.Date(y, m, d, 0, 0, 0, 0, time.UTC)
	return date.Unix()
}

// daysBetween return time interval of the given start timestamp and end
// timestamp.
func daysBetween(startDate, endDate int64) float64 {
	return float64(int(0.5 + float64((endDate-startDate)/86400)))
}

// WEEKDAY function returns an integer representing the day of the week for a
// supplied date. The syntax of the function is:
//
//	WEEKDAY(serial_number,[return_type])
func (fn *formulaFuncs) WEEKDAY(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "WEEKDAY requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "WEEKDAY allows at most 2 arguments")
	}
	sn := argsList.Front().Value.(formulaArg)
	num := sn.ToNumber()
	weekday, returnType := 0, 1
	if num.Type != ArgNumber {
		dateString := strings.ToLower(sn.Value())
		if !isDateOnlyFmt(dateString) {
			if _, _, _, _, _, err := strToTime(dateString); err.Type == ArgError {
				return err
			}
		}
		y, m, d, _, err := strToDate(dateString)
		if err.Type == ArgError {
			return err
		}
		weekday = int(time.Date(y, time.Month(m), d, 0, 0, 0, 0, time.Now().Location()).Weekday())
	} else {
		if num.Number < 0 {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
		weekday = int(timeFromExcelTime(num.Number, false).Weekday())
	}
	if argsList.Len() == 2 {
		returnTypeArg := argsList.Back().Value.(formulaArg).ToNumber()
		if returnTypeArg.Type != ArgNumber {
			return returnTypeArg
		}
		returnType = int(returnTypeArg.Number)
	}
	if returnType == 2 {
		returnType = 11
	}
	weekday++
	if returnType == 1 {
		return newNumberFormulaArg(float64(weekday))
	}
	if returnType == 3 {
		return newNumberFormulaArg(float64((weekday + 6 - 1) % 7))
	}
	if returnType >= 11 && returnType <= 17 {
		return newNumberFormulaArg(float64((weekday+6-(returnType-10))%7 + 1))
	}
	return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
}

// weeknum is an implementation of the formula function WEEKNUM.
func (fn *formulaFuncs) weeknum(snTime time.Time, returnType int) formulaArg {
	days := snTime.YearDay()
	weekMod, weekNum := days%7, math.Ceil(float64(days)/7)
	if weekMod == 0 {
		weekMod = 7
	}
	year := snTime.Year()
	firstWeekday := int(time.Date(year, time.January, 1, 0, 0, 0, 0, time.UTC).Weekday())
	var offset int
	switch returnType {
	case 1, 17:
		offset = 0
	case 2, 11, 21:
		offset = 1
	case 12, 13, 14, 15, 16:
		offset = returnType - 10
	default:
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	padding := offset + 7 - firstWeekday
	if padding > 7 {
		padding -= 7
	}
	if weekMod > padding {
		weekNum++
	}
	if returnType == 21 && (firstWeekday == 0 || firstWeekday > 4) {
		if weekNum--; weekNum < 1 {
			if weekNum = 52; int(time.Date(year-1, time.January, 1, 0, 0, 0, 0, time.UTC).Weekday()) < 4 {
				weekNum++
			}
		}
	}
	return newNumberFormulaArg(weekNum)
}

// WEEKNUM function returns an integer representing the week number (from 1 to
// 53) of the year. The syntax of the function is:
//
//	WEEKNUM(serial_number,[return_type])
func (fn *formulaFuncs) WEEKNUM(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "WEEKNUM requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "WEEKNUM allows at most 2 arguments")
	}
	sn := argsList.Front().Value.(formulaArg)
	num, returnType := sn.ToNumber(), 1
	var snTime time.Time
	if num.Type != ArgNumber {
		dateString := strings.ToLower(sn.Value())
		if !isDateOnlyFmt(dateString) {
			if _, _, _, _, _, err := strToTime(dateString); err.Type == ArgError {
				return err
			}
		}
		y, m, d, _, err := strToDate(dateString)
		if err.Type == ArgError {
			return err
		}
		snTime = time.Date(y, time.Month(m), d, 0, 0, 0, 0, time.Now().Location())
	} else {
		if num.Number < 0 {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
		snTime = timeFromExcelTime(num.Number, false)
	}
	if argsList.Len() == 2 {
		returnTypeArg := argsList.Back().Value.(formulaArg).ToNumber()
		if returnTypeArg.Type != ArgNumber {
			return returnTypeArg
		}
		returnType = int(returnTypeArg.Number)
	}
	return fn.weeknum(snTime, returnType)
}

// Text Functions

// prepareToText checking and prepare arguments for the formula functions
// ARRAYTOTEXT and VALUETOTEXT.
