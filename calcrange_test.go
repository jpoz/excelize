// Copyright 2016 - 2025 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excel™ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.18 or later.

package excelize

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestCalcSORTBY(t *testing.T) {
	cellData := [][]interface{}{
		{"Name", "Region", "Sales", "Quarter"},
		{"Alice", "North", 1500, 1},
		{"Bob", "South", 2000, 2},
		{"Alice", "North", 1200, 2},
		{"Charlie", "East", 1800, 1},
		{"Bob", "South", 2200, 1},
		{"David", "West", 1000, 2},
		{"Alice", "North", 1700, 3},
		// Mixed types for testing
		{"Test", "Mixed", "Text", 4},
		{nil, "Empty", 500, 4},
	}
	f := prepareCalcData(cellData)

	// Success cases
	formulaList := map[string]string{
		// Single key sort - ascending by Sales
		// 1000(David), 1200(Alice), 1500(Alice), 1700(Alice), 1800(Charlie), 2000(Bob), 2200(Bob)
		"TEXTJOIN(\",\", TRUE, SORTBY(A2:A8, C2:C8))":
			"David,Alice,Alice,Alice,Charlie,Bob,Bob",

		// Single key sort - descending by Sales
		// 2200(Bob), 2000(Bob), 1800(Charlie), 1700(Alice), 1500(Alice), 1200(Alice), 1000(David)
		"TEXTJOIN(\",\", TRUE, SORTBY(A2:A8, C2:C8, -1))":
			"Bob,Bob,Charlie,Alice,Alice,Alice,David",

		// Two key sort - Region ascending, Sales descending
		"TEXTJOIN(\",\", TRUE, SORTBY(A2:A8, B2:B8, 1, C2:C8, -1))":
			"Charlie,Alice,Alice,Alice,Bob,Bob,David",

		// Three key sort - Quarter, Region, Sales descending
		"TEXTJOIN(\",\", TRUE, SORTBY(A2:A8, D2:D8, 1, B2:B8, 1, C2:C8, -1))":
			"Charlie,Alice,Bob,Alice,Bob,David,Alice",

		// Sort with multiple columns in result
		"TEXTJOIN(\";\", TRUE, SORTBY(A2:C4, C2:C4))":
			"Alice;North;1200;Alice;North;1500;Bob;South;2000",

		// Sort by multi-column key
		"TEXTJOIN(\",\", TRUE, SORTBY(C2:C8, A2:B8))":
			"1500,1200,1700,2000,2200,1800,1000",

		// Mixed types (Numbers < Strings, Blanks last)
		// TEXTJOIN with TRUE ignores empty cells, so no trailing comma
		"TEXTJOIN(\",\", TRUE, SORTBY(A2:A10, C2:C10))":
			"David,Alice,Alice,Alice,Charlie,Bob,Bob,Test",

		// Numeric sort ascending
		"TEXTJOIN(\",\", TRUE, SORTBY(D2:D8, D2:D8))":
			"1,1,1,2,2,2,3",

		// String sort case-insensitive
		"TEXTJOIN(\",\", TRUE, SORTBY(B2:B8, B2:B8))":
			"East,North,North,North,South,South,West",
	}

	for formula, expected := range formulaList {
		assert.NoError(t, f.SetCellFormula("Sheet1", "E1", formula))
		result, err := f.CalcCellValue("Sheet1", "E1")
		assert.NoError(t, err, formula)
		assert.Equal(t, expected, result, formula)
	}

	// Error cases
	calcError := map[string][]string{
		// Too few arguments
		"SORTBY(A2:A7)": {"#VALUE!", "SORTBY requires at least 2 arguments"},

		// Too many arguments (9 arguments: array + 4 key pairs)
		"SORTBY(A2:A7, C2:C7, 1, D2:D7, 1, B2:B7, 1, E2:E7, 1)":
			{"#VALUE!", "SORTBY takes at most 7 arguments, received 9"},

		// Wrong argument count pattern (4 args)
		"SORTBY(A2:A7, C2:C7, 1, D2:D7)":
			{"#VALUE!", "SORTBY requires 2, 3, 5, or 7 arguments, received 4"},

		// Wrong argument count pattern (6 args)
		"SORTBY(A2:A7, C2:C7, 1, D2:D7, 1, B2:B7)":
			{"#VALUE!", "SORTBY requires 2, 3, 5, or 7 arguments, received 6"},

		// Dimension mismatch (different row counts)
		"SORTBY(A2:A7, C2:C5)":
			{"#VALUE!", "by_array dimensions (4 rows) do not match array dimensions (6 rows)"},

		// Invalid sort_order (not 1 or -1)
		"SORTBY(A2:A7, C2:C7, 2)":
			{"#VALUE!", "sort_order must be 1 or -1, received 2"},

		// Invalid sort_order (0)
		"SORTBY(A2:A7, C2:C7, 0)":
			{"#VALUE!", "sort_order must be 1 or -1, received 0"},
	}

	for formula, expected := range calcError {
		assert.NoError(t, f.SetCellFormula("Sheet1", "F1", formula))
		result, err := f.CalcCellValue("Sheet1", "F1")
		assert.EqualError(t, err, expected[1], formula)
		assert.Equal(t, expected[0], result, formula)
	}
}

func TestCompareSortbyValues(t *testing.T) {
	// Test type ordering: Numbers < Strings < Errors < Blanks
	numArg := newNumberFormulaArg(10)
	strArg := newStringFormulaArg("text")
	errArg := newErrorFormulaArg(formulaErrorNAME, "error")
	emptyArg := newEmptyFormulaArg()

	// Type priority tests
	assert.Equal(t, -1, compareSortbyValues(numArg, strArg), "Number < String")
	assert.Equal(t, -1, compareSortbyValues(strArg, errArg), "String < Error")
	assert.Equal(t, -1, compareSortbyValues(errArg, emptyArg), "Error < Blank")
	assert.Equal(t, 1, compareSortbyValues(strArg, numArg), "String > Number")
	assert.Equal(t, 1, compareSortbyValues(emptyArg, errArg), "Blank > Error")

	// Test case-insensitive string comparison
	str1 := newStringFormulaArg("Apple")
	str2 := newStringFormulaArg("apple")
	str3 := newStringFormulaArg("Banana")
	str4 := newStringFormulaArg("APPLE")

	assert.Equal(t, 0, compareSortbyValues(str1, str2), "Apple == apple")
	assert.Equal(t, 0, compareSortbyValues(str1, str4), "Apple == APPLE")
	assert.Equal(t, -1, compareSortbyValues(str1, str3), "Apple < Banana")
	assert.Equal(t, -1, compareSortbyValues(str2, str3), "apple < Banana")
	assert.Equal(t, 1, compareSortbyValues(str3, str1), "Banana > Apple")

	// Test numeric comparison
	num1 := newNumberFormulaArg(5)
	num2 := newNumberFormulaArg(10)
	num3 := newNumberFormulaArg(5)
	num4 := newNumberFormulaArg(-3)

	assert.Equal(t, -1, compareSortbyValues(num1, num2), "5 < 10")
	assert.Equal(t, 1, compareSortbyValues(num2, num1), "10 > 5")
	assert.Equal(t, 0, compareSortbyValues(num1, num3), "5 == 5")
	assert.Equal(t, -1, compareSortbyValues(num4, num1), "-3 < 5")

	// Test empty values
	empty1 := newEmptyFormulaArg()
	empty2 := newEmptyFormulaArg()
	assert.Equal(t, 0, compareSortbyValues(empty1, empty2), "Empty == Empty")

	// Test error comparison
	err1 := newErrorFormulaArg(formulaErrorNAME, "error1")
	err2 := newErrorFormulaArg(formulaErrorVALUE, "error2")
	err3 := newErrorFormulaArg(formulaErrorNAME, "error1")

	assert.Equal(t, 0, compareSortbyValues(err1, err3), "Same errors equal")
	// Error comparison is by error string
	assert.NotEqual(t, 0, compareSortbyValues(err1, err2), "Different errors not equal")
}

func TestSORTBYEdgeCases(t *testing.T) {
	// Test with single row
	cellData := [][]interface{}{
		{"Name", "Score"},
		{"Alice", 100},
	}
	f := prepareCalcData(cellData)

	formula := "TEXTJOIN(\",\", TRUE, SORTBY(A2:A2, B2:B2))"
	assert.NoError(t, f.SetCellFormula("Sheet1", "C1", formula))
	result, err := f.CalcCellValue("Sheet1", "C1")
	assert.NoError(t, err)
	assert.Equal(t, "Alice", result, "Single row should work")

	// Test with equal values (stable sort)
	cellData2 := [][]interface{}{
		{"Name", "Score"},
		{"Alice", 100},
		{"Bob", 100},
		{"Charlie", 100},
	}
	f2 := prepareCalcData(cellData2)

	formula2 := "TEXTJOIN(\",\", TRUE, SORTBY(A2:A4, B2:B4))"
	assert.NoError(t, f2.SetCellFormula("Sheet1", "C1", formula2))
	result2, err2 := f2.CalcCellValue("Sheet1", "C1")
	assert.NoError(t, err2)
	assert.Equal(t, "Alice,Bob,Charlie", result2, "Equal values maintain original order")

	// Test with two sort keys, first all equal
	cellData3 := [][]interface{}{
		{"Name", "Group", "Score"},
		{"Charlie", "A", 90},
		{"Alice", "A", 95},
		{"Bob", "A", 85},
	}
	f3 := prepareCalcData(cellData3)

	formula3 := "TEXTJOIN(\",\", TRUE, SORTBY(A2:A4, B2:B4, 1, C2:C4, 1))"
	assert.NoError(t, f3.SetCellFormula("Sheet1", "D1", formula3))
	result3, err3 := f3.CalcCellValue("Sheet1", "D1")
	assert.NoError(t, err3)
	assert.Equal(t, "Bob,Charlie,Alice", result3, "Second key determines order when first is equal")
}

func TestCalcHSTACK(t *testing.T) {
	cellData := [][]interface{}{
		{"A", "B", "C", "D", "E"},
		{"A2", "B2", "C2", "D2", "E2"},
		{"A3", "B3", "C3", "D3", "E3"},
		{"A4", "B4", "C4", "D4", "E4"},
		{"A5", "B5", "C5", "D5", "E5"},
		{100, 200, 300, 400, 500},
	}
	f := prepareCalcData(cellData)

	// Success cases
	formulaList := map[string]string{
		// Two arrays of same height (3 rows)
		"TEXTJOIN(\",\", TRUE, HSTACK(A1:A3, B1:B3))":
			"A,B,A2,B2,A3,B3",

		// Single array (no-op)
		"TEXTJOIN(\",\", TRUE, HSTACK(A1:B3))":
			"A,B,A2,B2,A3,B3",

		// Numeric values
		"TEXTJOIN(\",\", TRUE, HSTACK(A6:B6, D6:E6))":
			"100,200,400,500",

		// Multiple columns
		"TEXTJOIN(\",\", TRUE, HSTACK(A1:B2, C1:D2))":
			"A,B,C,D,A2,B2,C2,D2",
	}

	for formula, expected := range formulaList {
		assert.NoError(t, f.SetCellFormula("Sheet1", "G1", formula))
		result, err := f.CalcCellValue("Sheet1", "G1")
		assert.NoError(t, err, formula)
		assert.Equal(t, expected, result, formula)
	}

	// Test padding with INDEX (TEXTJOIN ignores #N/A)
	// HSTACK(A1:A5, B1:B2) should pad B's rows 3-5 with #N/A
	assert.NoError(t, f.SetCellFormula("Sheet1", "H1", "INDEX(HSTACK(A1:A5, B1:B2), 3, 2)"))
	result, err := f.CalcCellValue("Sheet1", "H1")
	assert.Error(t, err) // #N/A is an error type
	assert.Equal(t, "#N/A", result, "Row 3, column 2 should be #N/A (padding)")

	assert.NoError(t, f.SetCellFormula("Sheet1", "H2", "INDEX(HSTACK(A1:A5, B1:B2), 4, 2)"))
	result2, err2 := f.CalcCellValue("Sheet1", "H2")
	assert.Error(t, err2) // #N/A is an error type
	assert.Equal(t, "#N/A", result2, "Row 4, column 2 should be #N/A (padding)")

	// Test single value + array
	assert.NoError(t, f.SetCellFormula("Sheet1", "H3", "INDEX(HSTACK(100, A1:A3), 1, 1)"))
	result3, err3 := f.CalcCellValue("Sheet1", "H3")
	assert.NoError(t, err3)
	assert.Equal(t, "100", result3, "Single value in first column")

	assert.NoError(t, f.SetCellFormula("Sheet1", "H4", "INDEX(HSTACK(100, A1:A3), 1, 2)"))
	result4, err4 := f.CalcCellValue("Sheet1", "H4")
	assert.NoError(t, err4)
	assert.Equal(t, "A", result4, "Array value in second column")

	assert.NoError(t, f.SetCellFormula("Sheet1", "H5", "INDEX(HSTACK(100, A1:A3), 2, 1)"))
	result5, err5 := f.CalcCellValue("Sheet1", "H5")
	assert.Error(t, err5) // #N/A is an error type
	assert.Equal(t, "#N/A", result5, "Single value padded for row 2")

	// Error cases
	calcError := map[string][]string{
		// No arguments
		"HSTACK()": {"#VALUE!", "HSTACK requires at least 1 argument"},
	}

	for formula, expected := range calcError {
		assert.NoError(t, f.SetCellFormula("Sheet1", "I1", formula))
		result6, err6 := f.CalcCellValue("Sheet1", "I1")
		assert.EqualError(t, err6, expected[1], formula)
		assert.Equal(t, expected[0], result6, formula)
	}
}

func TestHSTACKEdgeCases(t *testing.T) {
	// Test with all single values (1×1 arrays)
	cellData := [][]interface{}{
		{10, 20, 30, 40},
	}
	f := prepareCalcData(cellData)

	formula := "TEXTJOIN(\",\", TRUE, HSTACK(A1, B1, C1, D1))"
	assert.NoError(t, f.SetCellFormula("Sheet1", "E1", formula))
	result, err := f.CalcCellValue("Sheet1", "E1")
	assert.NoError(t, err)
	assert.Equal(t, "10,20,30,40", result, "Single values should concatenate horizontally")

	// Test maximum padding scenario - check with INDEX since TEXTJOIN skips #N/A
	cellData2 := [][]interface{}{
		{"R1C1", "Short1"},
		{"R2C1", "Short2"},
		{"R3C1", nil},
		{"R4C1", nil},
		{"R5C1", nil},
	}
	f2 := prepareCalcData(cellData2)

	// Check row 3, column 2 should be #N/A (padding)
	assert.NoError(t, f2.SetCellFormula("Sheet1", "C1", "INDEX(HSTACK(A1:A5, B1:B2), 3, 2)"))
	result2, err2 := f2.CalcCellValue("Sheet1", "C1")
	assert.Error(t, err2) // #N/A is an error type
	assert.Equal(t, "#N/A", result2, "Should pad short array with #N/A")

	// Check row 5, column 2 should also be #N/A (padding)
	assert.NoError(t, f2.SetCellFormula("Sheet1", "C2", "INDEX(HSTACK(A1:A5, B1:B2), 5, 2)"))
	result3, err3 := f2.CalcCellValue("Sheet1", "C2")
	assert.Error(t, err3) // #N/A is an error type
	assert.Equal(t, "#N/A", result3, "Should pad short array with #N/A")

	// Test that empty cells are preserved (not converted to #N/A)
	cellData3 := [][]interface{}{
		{"A", nil, "C"},
		{"D", nil, "F"},
	}
	f3 := prepareCalcData(cellData3)

	// Check that the middle column has empty cells, not #N/A
	assert.NoError(t, f3.SetCellFormula("Sheet1", "D1", "INDEX(HSTACK(A1:C2, D1:D2), 1, 2)"))
	result4, err4 := f3.CalcCellValue("Sheet1", "D1")
	assert.NoError(t, err4)
	assert.Equal(t, "", result4, "Empty cells should remain empty, not become #N/A")

	// Test combining 3+ arrays
	cellData4 := [][]interface{}{
		{"A", "B", "C"},
		{"A2", "B2", "C2"},
	}
	f4 := prepareCalcData(cellData4)

	formula4 := "TEXTJOIN(\",\", TRUE, HSTACK(A1:A2, B1:B2, C1:C2))"
	assert.NoError(t, f4.SetCellFormula("Sheet1", "D1", formula4))
	result5, err5 := f4.CalcCellValue("Sheet1", "D1")
	assert.NoError(t, err5)
	assert.Equal(t, "A,B,C,A2,B2,C2", result5, "Should handle 3 arrays")
}

func TestCalcTAKE(t *testing.T) {
	cellData := [][]interface{}{
		{"A", "B", "C", "D"},
		{"A2", "B2", "C2", "D2"},
		{"A3", "B3", "C3", "D3"},
		{"A4", "B4", "C4", "D4"},
		{"A5", "B5", "C5", "D5"},
		{100, 200, 300, 400},
		{110, 210, 310, 410},
		{120, 220, 320, 420},
	}
	f := prepareCalcData(cellData)

	// Success cases - Category 1: Basic Extraction
	formulaList := map[string]string{
		// Positive rows, all columns
		"TEXTJOIN(\",\", TRUE, TAKE(A1:D5, 2))":
			"A,B,C,D,A2,B2,C2,D2",

		// Negative rows, all columns
		"TEXTJOIN(\",\", TRUE, TAKE(A1:D5, -2))":
			"A4,B4,C4,D4,A5,B5,C5,D5",

		// Positive rows, positive columns
		"TEXTJOIN(\",\", TRUE, TAKE(A1:D5, 2, 2))":
			"A,B,A2,B2",

		// Positive rows, negative columns
		"TEXTJOIN(\",\", TRUE, TAKE(A1:D5, 2, -2))":
			"C,D,C2,D2",

		// Negative rows, positive columns
		"TEXTJOIN(\",\", TRUE, TAKE(A1:D5, -2, 2))":
			"A4,B4,A5,B5",

		// Negative rows, negative columns
		"TEXTJOIN(\",\", TRUE, TAKE(A1:D5, -2, -2))":
			"C4,D4,C5,D5",

		// Category 2: Overflow Scenarios
		// Rows exceeds array size
		"TEXTJOIN(\",\", TRUE, TAKE(A1:D3, 10))":
			"A,B,C,D,A2,B2,C2,D2,A3,B3,C3,D3",

		// Negative rows exceeds size
		"TEXTJOIN(\",\", TRUE, TAKE(A1:D3, -10))":
			"A,B,C,D,A2,B2,C2,D2,A3,B3,C3,D3",

		// Columns exceeds array size
		"TEXTJOIN(\",\", TRUE, TAKE(A1:D3, 2, 10))":
			"A,B,C,D,A2,B2,C2,D2",

		// Negative columns exceeds size
		"TEXTJOIN(\",\", TRUE, TAKE(A1:D3, 2, -10))":
			"A,B,C,D,A2,B2,C2,D2",

		// Both exceed
		"TEXTJOIN(\",\", TRUE, TAKE(A1:D3, 10, 10))":
			"A,B,C,D,A2,B2,C2,D2,A3,B3,C3,D3",

		// Single cell array overflow
		"TEXTJOIN(\",\", TRUE, TAKE(A1, 5, 5))":
			"A",

		// Category 4: Edge Cases
		// Single row extraction
		"TEXTJOIN(\",\", TRUE, TAKE(A1:D5, 1))":
			"A,B,C,D",

		// Single column extraction
		"TEXTJOIN(\",\", TRUE, TAKE(A1:D5, 5, 1))":
			"A,A2,A3,A4,A5",

		// Single cell result
		"TEXTJOIN(\",\", TRUE, TAKE(A1:D5, 1, 1))":
			"A",

		// Full array (no-op)
		"TEXTJOIN(\",\", TRUE, TAKE(A1:D5, 5, 4))":
			"A,B,C,D,A2,B2,C2,D2,A3,B3,C3,D3,A4,B4,C4,D4,A5,B5,C5,D5",

		// Category 5: Single Value Input
		// Single cell as array
		"TEXTJOIN(\",\", TRUE, TAKE(A1, 1))":
			"A",

		// Category 6: Mixed Data Types - numbers
		"TEXTJOIN(\",\", TRUE, TAKE(A6:D8, 2, 3))":
			"100,200,300,110,210,310",

		// Extract from end with numbers
		"TEXTJOIN(\",\", TRUE, TAKE(A6:D8, -2, -2))":
			"310,410,320,420",

		// Mix of strings and extraction patterns
		"TEXTJOIN(\",\", TRUE, TAKE(A1:D5, 3, 2))":
			"A,B,A2,B2,A3,B3",

		// Take one row from middle-ish (from start)
		"TEXTJOIN(\",\", TRUE, TAKE(A1:D5, 3))":
			"A,B,C,D,A2,B2,C2,D2,A3,B3,C3,D3",

		// Take one column from middle-ish (from end)
		"TEXTJOIN(\",\", TRUE, TAKE(A1:D5, 5, -3))":
			"B,C,D,B2,C2,D2,B3,C3,D3,B4,C4,D4,B5,C5,D5",

		// Verify numbers work correctly
		"TEXTJOIN(\",\", TRUE, TAKE(A6:D6, 1, 3))":
			"100,200,300",

		// Take negative from numbers
		"TEXTJOIN(\",\", TRUE, TAKE(A6:D8, -1))":
			"120,220,320,420",
	}

	for formula, expected := range formulaList {
		assert.NoError(t, f.SetCellFormula("Sheet1", "E1", formula))
		result, err := f.CalcCellValue("Sheet1", "E1")
		assert.NoError(t, err, formula)
		assert.Equal(t, expected, result, formula)
	}

	// Use INDEX to test specific cell extraction
	assert.NoError(t, f.SetCellFormula("Sheet1", "F1", "INDEX(TAKE(A1:D5, 2, 2), 1, 2)"))
	result1, err1 := f.CalcCellValue("Sheet1", "F1")
	assert.NoError(t, err1)
	assert.Equal(t, "B", result1, "INDEX should extract specific cell from TAKE result")

	// Test that negative indexing works correctly with INDEX
	assert.NoError(t, f.SetCellFormula("Sheet1", "F2", "INDEX(TAKE(A1:D5, -2, -2), 1, 1)"))
	result2, err2 := f.CalcCellValue("Sheet1", "F2")
	assert.NoError(t, err2)
	assert.Equal(t, "C4", result2, "First cell of TAKE with negative indices")

	// Error cases - Category 7: Invalid Arguments
	calcError := map[string][]string{
		// No arguments
		"TAKE()": {"#VALUE!", "TAKE requires 2 or 3 arguments, received 0"},

		// Only one argument (missing rows)
		"TAKE(A1:D5)": {"#VALUE!", "TAKE requires 2 or 3 arguments, received 1"},

		// Too many arguments
		"TAKE(A1:D5, 2, 2, 2)": {"#VALUE!", "TAKE requires 2 or 3 arguments, received 4"},

		// Non-numeric rows parameter
		"TAKE(A1:D5, \"abc\")": {"#VALUE!", "strconv.ParseFloat: parsing \"abc\": invalid syntax"},

		// Category 8: Zero Count
		// Zero rows
		"TAKE(A1:D5, 0)": {"#CALC!", "TAKE rows parameter cannot be zero"},

		// Zero columns
		"TAKE(A1:D5, 2, 0)": {"#CALC!", "TAKE columns parameter cannot be zero"},
	}

	for formula, expected := range calcError {
		assert.NoError(t, f.SetCellFormula("Sheet1", "G1", formula))
		result3, err3 := f.CalcCellValue("Sheet1", "G1")
		assert.EqualError(t, err3, expected[1], formula)
		assert.Equal(t, expected[0], result3, formula)
	}
}

func TestTAKEEdgeCases(t *testing.T) {
	// Test overflow scenarios with various dimensions
	cellData := [][]interface{}{
		{"R1C1", "R1C2", "R1C3"},
		{"R2C1", "R2C2", "R2C3"},
		{"R3C1", "R3C2", "R3C3"},
	}
	f := prepareCalcData(cellData)

	// Overflow in both dimensions
	formula1 := "TEXTJOIN(\",\", TRUE, TAKE(A1:C3, 100, 100))"
	assert.NoError(t, f.SetCellFormula("Sheet1", "D1", formula1))
	result1, err1 := f.CalcCellValue("Sheet1", "D1")
	assert.NoError(t, err1)
	assert.Equal(t, "R1C1,R1C2,R1C3,R2C1,R2C2,R2C3,R3C1,R3C2,R3C3", result1, "Should return entire array when overflow")

	// Negative overflow in both dimensions
	formula2 := "TEXTJOIN(\",\", TRUE, TAKE(A1:C3, -100, -100))"
	assert.NoError(t, f.SetCellFormula("Sheet1", "D2", formula2))
	result2, err2 := f.CalcCellValue("Sheet1", "D2")
	assert.NoError(t, err2)
	assert.Equal(t, "R1C1,R1C2,R1C3,R2C1,R2C2,R2C3,R3C1,R3C2,R3C3", result2, "Negative overflow should return entire array")

	// Single cell array
	cellData2 := [][]interface{}{
		{"Single"},
	}
	f2 := prepareCalcData(cellData2)

	formula3 := "TEXTJOIN(\",\", TRUE, TAKE(A1, 1))"
	assert.NoError(t, f2.SetCellFormula("Sheet1", "B1", formula3))
	result3, err3 := f2.CalcCellValue("Sheet1", "B1")
	assert.NoError(t, err3)
	assert.Equal(t, "Single", result3, "Single cell should work")

	formula4 := "TEXTJOIN(\",\", TRUE, TAKE(A1, 1, 1))"
	assert.NoError(t, f2.SetCellFormula("Sheet1", "B2", formula4))
	result4, err4 := f2.CalcCellValue("Sheet1", "B2")
	assert.NoError(t, err4)
	assert.Equal(t, "Single", result4, "Single cell with explicit columns")

	// Full array extraction (exactly matching dimensions)
	formula5 := "TEXTJOIN(\",\", TRUE, TAKE(A1:C3, 3, 3))"
	assert.NoError(t, f.SetCellFormula("Sheet1", "D3", formula5))
	result5, err5 := f.CalcCellValue("Sheet1", "D3")
	assert.NoError(t, err5)
	assert.Equal(t, "R1C1,R1C2,R1C3,R2C1,R2C2,R2C3,R3C1,R3C2,R3C3", result5, "Exact dimensions should work")

	// Test that empty cells are preserved
	cellData3 := [][]interface{}{
		{"A", nil, "C"},
		{"D", nil, "F"},
		{"G", nil, "I"},
	}
	f3 := prepareCalcData(cellData3)

	// Check that middle column preserves empty cells
	assert.NoError(t, f3.SetCellFormula("Sheet1", "D1", "INDEX(TAKE(A1:C3, 2, 3), 1, 2)"))
	result6, err6 := f3.CalcCellValue("Sheet1", "D1")
	assert.NoError(t, err6)
	assert.Equal(t, "", result6, "Empty cells should remain empty")

	assert.NoError(t, f3.SetCellFormula("Sheet1", "D2", "INDEX(TAKE(A1:C3, 2, 3), 2, 2)"))
	result7, err7 := f3.CalcCellValue("Sheet1", "D2")
	assert.NoError(t, err7)
	assert.Equal(t, "", result7, "Empty cells in row 2 should remain empty")

	// Test with numeric array
	cellData4 := [][]interface{}{
		{1, 2, 3, 4, 5},
		{10, 20, 30, 40, 50},
		{100, 200, 300, 400, 500},
	}
	f4 := prepareCalcData(cellData4)

	formula8 := "TEXTJOIN(\",\", TRUE, TAKE(A1:E3, 2, 3))"
	assert.NoError(t, f4.SetCellFormula("Sheet1", "F1", formula8))
	result8, err8 := f4.CalcCellValue("Sheet1", "F1")
	assert.NoError(t, err8)
	assert.Equal(t, "1,2,3,10,20,30", result8, "Numeric arrays should work")

	formula9 := "TEXTJOIN(\",\", TRUE, TAKE(A1:E3, -1, -2))"
	assert.NoError(t, f4.SetCellFormula("Sheet1", "F2", formula9))
	result9, err9 := f4.CalcCellValue("Sheet1", "F2")
	assert.NoError(t, err9)
	assert.Equal(t, "400,500", result9, "Negative indices with numbers")

	// Test exact row count
	formula10 := "TEXTJOIN(\",\", TRUE, TAKE(A1:E3, 3))"
	assert.NoError(t, f4.SetCellFormula("Sheet1", "F3", formula10))
	result10, err10 := f4.CalcCellValue("Sheet1", "F3")
	assert.NoError(t, err10)
	assert.Equal(t, "1,2,3,4,5,10,20,30,40,50,100,200,300,400,500", result10, "Take all rows")

	// Test exact column count
	formula11 := "TEXTJOIN(\",\", TRUE, TAKE(A1:E3, 3, 5))"
	assert.NoError(t, f4.SetCellFormula("Sheet1", "F4", formula11))
	result11, err11 := f4.CalcCellValue("Sheet1", "F4")
	assert.NoError(t, err11)
	assert.Equal(t, "1,2,3,4,5,10,20,30,40,50,100,200,300,400,500", result11, "Take all columns explicitly")
}

func TestCalcLET(t *testing.T) {
	f := NewFile()
	defer func() {
		assert.NoError(t, f.Close())
	}()

	// Set up test data
	assert.NoError(t, f.SetCellValue("Sheet1", "A1", 10))
	assert.NoError(t, f.SetCellValue("Sheet1", "A2", 20))
	assert.NoError(t, f.SetCellValue("Sheet1", "B1", 5))

	// Success cases
	tests := map[string]string{
		// Basic usage
		`=LET("x", 5, x)`:                                       "5",
		`=LET("x", 5, x+1)`:                                     "6",
		`=LET("x", 5, x*2)`:                                     "10",
		`=LET("x", 5.5, x)`:                                     "5.5",
		`=LET("x", -5, x)`:                                      "-5",

		// Multiple variables
		`=LET("x", 5, "y", 10, x+y)`:                           "15",
		`=LET("x", 5, "y", x*2, y+3)`:                          "13",
		`=LET("x", 5, "y", x*2, "z", y+3, z*2)`:                "26",
		`=LET("a", 2, "b", 3, "c", a*b, c+a+b)`:                "11",

		// With cell references
		`=LET("x", A1, x*2)`:                                    "20",
		`=LET("x", A1, "y", B1, x+y)`:                          "15",
		`=LET("x", A1, "y", A2, x+y)`:                          "30",

		// Complex expressions
		`=LET("price", 100, "tax", price*0.2, price+tax)`:      "120",
		`=LET("x", 3, "y", 4, "z", x*x+y*y, z)`:                "25",

		// Nested formulas
		`=LET("x", 5, SUM(x, x, x))`:                           "15",
		`=LET("x", 5, IF(x>3, "yes", "no"))`:                   "yes",
		`=LET("x", 10, IF(x<5, "small", "large"))`:             "large",
		`=LET("x", 5, "y", 10, SUM(x, y))`:                     "15",

		// Variable shadowing (inner scope overrides)
		`=LET("x", 5, LET("x", 10, x))`:                        "10",
		`=LET("x", 5, "y", LET("x", 10, x), y)`:                "10",

		// Using variables multiple times
		`=LET("x", 5, x+x+x)`:                                  "15",
		`=LET("x", 3, x*x)`:                                    "9",
	}

	for formula, expected := range tests {
		assert.NoError(t, f.SetCellFormula("Sheet1", "C1", formula))
		result, err := f.CalcCellValue("Sheet1", "C1")
		assert.NoError(t, err, formula)
		assert.Equal(t, expected, result, formula)
	}

	// Error cases
	errorTests := map[string]string{
		// Too few arguments
		`=LET("x", 5)`:              formulaErrorVALUE,
		`=LET("x")`:                 formulaErrorVALUE,
		`=LET()`:                    formulaErrorVALUE,

		// Even number of arguments
		`=LET("x", 5, "y", 10)`:    formulaErrorVALUE,
		`=LET("x", 5, "y", 10, "z", 15)`: formulaErrorVALUE,

		// Invalid variable names - starts with number
		`=LET("123", 5, 123)`:      formulaErrorNAME,
		`=LET("1x", 5, 1x)`:        formulaErrorNAME,

		// Invalid variable names - cell reference
		`=LET("A1", 5, A1)`:        formulaErrorNAME,
		`=LET("B2", 10, B2)`:       formulaErrorNAME,

		// Invalid variable names - reserved word
		`=LET("TRUE", 5, TRUE)`:    formulaErrorNAME,
		`=LET("FALSE", 5, FALSE)`:  formulaErrorNAME,

		// Non-string variable name
		`=LET(A1, 5, A1)`:          formulaErrorVALUE,
		`=LET(5, 10, x)`:           formulaErrorVALUE,

		// Undefined variable
		`=LET("x", 5, y)`:          formulaErrorNAME,
		`=LET("x", 5, "y", 10, z)`: formulaErrorNAME,

		// Empty variable name
		`=LET("", 5, x)`:           formulaErrorNAME,
	}

	for formula, expectedError := range errorTests {
		assert.NoError(t, f.SetCellFormula("Sheet1", "C1", formula))
		result, err := f.CalcCellValue("Sheet1", "C1")
		assert.NoError(t, err, formula)
		assert.Contains(t, result, expectedError, formula)
	}
}
