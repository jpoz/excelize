// Copyright 2016 - 2025 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.24.0 or later.

package excelize

import (
	"bytes"
	"container/list"
	"fmt"
	"math"
	"math/big"
	"strings"
	"time"
	"unicode"
	"unicode/utf8"

	"golang.org/x/text/language"
	"golang.org/x/text/message"
)

func prepareToText(name string, argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires at least 1 argument", name))
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s allows at most 2 arguments", name))
	}
	format := newNumberFormulaArg(0)
	if argsList.Len() == 2 {
		if format = argsList.Back().Value.(formulaArg).ToNumber(); format.Type != ArgNumber {
			return format
		}
	}
	if format.Number != 0 && format.Number != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	return format
}

// ARRAYTOTEXT function returns an array of text values from any specified
// range. It passes text values unchanged, and converts non-text values to
// text. The syntax of the function is:
//
//	ARRAYTOTEXT(array,[format])
func (fn *formulaFuncs) ARRAYTOTEXT(argsList *list.List) formulaArg {
	var mtx [][]string
	format := prepareToText("ARRAYTOTEXT", argsList)
	if format.Type != ArgNumber {
		return format
	}
	for _, rows := range argsList.Front().Value.(formulaArg).Matrix {
		var row []string
		for _, cell := range rows {
			if num := cell.ToNumber(); num.Type != ArgNumber && format.Number == 1 {
				row = append(row, fmt.Sprintf("\"%s\"", cell.Value()))
				continue
			}
			row = append(row, cell.Value())
		}
		mtx = append(mtx, row)
	}
	var text []string
	for _, row := range mtx {
		if format.Number == 1 {
			text = append(text, strings.Join(row, ","))
			continue
		}
		text = append(text, strings.Join(row, ", "))
	}
	if format.Number == 1 {
		return newStringFormulaArg(fmt.Sprintf("{%s}", strings.Join(text, ";")))
	}
	return newStringFormulaArg(strings.Join(text, ", "))
}

// bahttextAppendDigit appends a digit to the passed string.
func bahttextAppendDigit(text string, digit int) string {
	if 0 <= digit && digit <= 9 {
		return text + []string{th0, th1, th2, th3, th4, th5, th6, th7, th8, th9}[digit]
	}
	return text
}

// bahttextAppendPow10 appends a value raised to a power of 10: digit*10^pow10.
func bahttextAppendPow10(text string, digit, pow10 int) string {
	text = bahttextAppendDigit(text, digit)
	switch pow10 {
	case 2:
		text += th1e2
	case 3:
		text += th1e3
	case 4:
		text += th1e4
	case 5:
		text += th1e5
	}
	return text
}

// bahttextAppendBlock appends a block of 6 digits to the passed string.
func bahttextAppendBlock(text string, val int) string {
	if val >= 100000 {
		text = bahttextAppendPow10(text, val/100000, 5)
		val %= 100000
	}
	if val >= 10000 {
		text = bahttextAppendPow10(text, val/10000, 4)
		val %= 10000
	}
	if val >= 1000 {
		text = bahttextAppendPow10(text, val/1000, 3)
		val %= 1000
	}
	if val >= 100 {
		text = bahttextAppendPow10(text, val/100, 2)
		val %= 100
	}
	if val > 0 {
		n10 := val / 10
		n1 := val % 10
		if n10 >= 1 {
			if n10 >= 3 {
				text = bahttextAppendDigit(text, n10)
			} else if n10 == 2 {
				text += th20
			}
			text += th10
		}
		if n10 > 0 && n1 == 1 {
			text += th11
		} else if n1 > 0 {
			text = bahttextAppendDigit(text, n1)
		}
	}
	return text
}

// BAHTTEXT function converts a number into Thai text, with the suffix "Baht".
// The syntax of the function is:
//
//	BAHTTEXT(number)
func (fn *formulaFuncs) BAHTTEXT(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "BAHTTEXT requires 1 numeric argument")
	}
	token := argsList.Front().Value.(formulaArg)
	number := token.ToNumber()
	if number.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, number.Error)
	}
	minus := number.Number < 0
	num := math.Floor(math.Abs(number.Number)*100 + 0.5)
	// split baht and satang
	splitBlock := func(val, size float64) (float64, int) {
		integer, frac := math.Modf((val + 0.1) / size)
		frac = frac*size + 0.1
		return integer, int(frac)
	}
	baht, satang := splitBlock(num, 100)
	var text string
	if baht == 0 {
		if satang == 0 {
			text += th0
		}
	} else {
		for baht > 0 {
			var block string
			var nBlock int
			baht, nBlock = splitBlock(baht, 1.0e6)
			if nBlock > 0 {
				block = bahttextAppendBlock(block, nBlock)
			}
			if baht > 0 {
				block = th1e6 + block
			}
			text = block + text
		}
	}
	if len(text) > 0 {
		text += thBaht
	}
	if satang == 0 {
		text += thDot0
	} else {
		text = bahttextAppendBlock(text, satang)
		text += thSatang
	}
	if minus {
		text = thMinus + text
	}
	return newStringFormulaArg(text)
}

// CHAR function returns the character relating to a supplied character set
// number (from 1 to 255). The syntax of the function is:
//
//	CHAR(number)
func (fn *formulaFuncs) CHAR(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "CHAR requires 1 argument")
	}
	arg := argsList.Front().Value.(formulaArg).ToNumber()
	if arg.Type != ArgNumber {
		return arg
	}
	num := int(arg.Number)
	if num < 0 || num > MaxFieldLength {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	return newStringFormulaArg(fmt.Sprintf("%c", num))
}

// CLEAN removes all non-printable characters from a supplied text string. The
// syntax of the function is:
//
//	CLEAN(text)
func (fn *formulaFuncs) CLEAN(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "CLEAN requires 1 argument")
	}
	b := bytes.Buffer{}
	for _, c := range argsList.Front().Value.(formulaArg).Value() {
		if c > 31 {
			b.WriteRune(c)
		}
	}
	return newStringFormulaArg(b.String())
}

// CODE function converts the first character of a supplied text string into
// the associated numeric character set code used by your computer. The
// syntax of the function is:
//
//	CODE(text)
func (fn *formulaFuncs) CODE(argsList *list.List) formulaArg {
	return fn.code("CODE", argsList)
}

// code is an implementation of the formula functions CODE and UNICODE.
func (fn *formulaFuncs) code(name string, argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires 1 argument", name))
	}
	text := argsList.Front().Value.(formulaArg).Value()
	if len(text) == 0 {
		if name == "CODE" {
			return newNumberFormulaArg(0)
		}
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	return newNumberFormulaArg(float64(text[0]))
}

// CONCAT function joins together a series of supplied text strings into one
// combined text string.
//
//	CONCAT(text1,[text2],...)
func (fn *formulaFuncs) CONCAT(argsList *list.List) formulaArg {
	return fn.concat(argsList)
}

// CONCATENATE function joins together a series of supplied text strings into
// one combined text string.
//
//	CONCATENATE(text1,[text2],...)
func (fn *formulaFuncs) CONCATENATE(argsList *list.List) formulaArg {
	return fn.concat(argsList)
}

// concat is an implementation of the formula functions CONCAT and
// CONCATENATE.
func (fn *formulaFuncs) concat(argsList *list.List) formulaArg {
	var buf bytes.Buffer
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		for _, cell := range arg.Value.(formulaArg).ToList() {
			if cell.Type == ArgError {
				return cell
			}
			buf.WriteString(cell.Value())
		}
	}
	return newStringFormulaArg(buf.String())
}

// DBCS converts half-width (single-byte) letters within a character string to
// full-width (double-byte) characters. The syntax of the function is:
//
//	DBCS(text)
func (fn *formulaFuncs) DBCS(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "DBCS requires 1 argument")
	}
	arg := argsList.Front().Value.(formulaArg)
	if arg.Type == ArgError {
		return arg
	}
	if fn.f.options.CultureInfo == CultureNameJaJP ||
		fn.f.options.CultureInfo == CultureNameZhCN ||
		fn.f.options.CultureInfo == CultureNameZhTW {
		var chars []string
		for _, r := range arg.Value() {
			code := r
			if code == 32 {
				code = 12288
			} else {
				code += 65248
			}
			if (code < 32 || code > 126) && r != 165 && code < 65381 {
				chars = append(chars, string(code))
			} else {
				chars = append(chars, string(r))
			}
		}
		return newStringFormulaArg(strings.Join(chars, ""))
	}
	return arg
}

// EXACT function tests if two supplied text strings or values are exactly
// equal and if so, returns TRUE; Otherwise, the function returns FALSE. The
// function is case-sensitive. The syntax of the function is:
//
//	EXACT(text1,text2)
func (fn *formulaFuncs) EXACT(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "EXACT requires 2 arguments")
	}
	text1 := argsList.Front().Value.(formulaArg).Value()
	text2 := argsList.Back().Value.(formulaArg).Value()
	return newBoolFormulaArg(text1 == text2)
}

// FIXED function rounds a supplied number to a specified number of decimal
// places and then converts this into text. The syntax of the function is:
//
//	FIXED(number,[decimals],[no_commas])
func (fn *formulaFuncs) FIXED(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "FIXED requires at least 1 argument")
	}
	if argsList.Len() > 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "FIXED allows at most 3 arguments")
	}
	numArg := argsList.Front().Value.(formulaArg).ToNumber()
	if numArg.Type != ArgNumber {
		return numArg
	}
	precision, decimals, noCommas := 0, 0, false
	s := strings.Split(argsList.Front().Value.(formulaArg).Value(), ".")
	if argsList.Len() == 1 && len(s) == 2 {
		precision = len(s[1])
		decimals = len(s[1])
	}
	if argsList.Len() >= 2 {
		decimalsArg := argsList.Front().Next().Value.(formulaArg).ToNumber()
		if decimalsArg.Type != ArgNumber {
			return decimalsArg
		}
		decimals = int(decimalsArg.Number)
	}
	if argsList.Len() == 3 {
		noCommasArg := argsList.Back().Value.(formulaArg).ToBool()
		if noCommasArg.Type == ArgError {
			return noCommasArg
		}
		noCommas = noCommasArg.Boolean
	}
	n := math.Pow(10, float64(decimals))
	r := numArg.Number * n
	fixed := float64(int(r+math.Copysign(0.5, r))) / n
	if decimals > 0 {
		precision = decimals
	}
	if noCommas {
		return newStringFormulaArg(fmt.Sprintf(fmt.Sprintf("%%.%df", precision), fixed))
	}
	p := message.NewPrinter(language.English)
	return newStringFormulaArg(p.Sprintf(fmt.Sprintf("%%.%df", precision), fixed))
}

// FIND function returns the position of a specified character or sub-string
// within a supplied text string. The function is case-sensitive. The syntax
// of the function is:
//
//	FIND(find_text,within_text,[start_num])
func (fn *formulaFuncs) FIND(argsList *list.List) formulaArg {
	return fn.find("FIND", argsList)
}

// FINDB counts each double-byte character as 2 when you have enabled the
// editing of a language that supports DBCS and then set it as the default
// language. Otherwise, FINDB counts each character as 1. The syntax of the
// function is:
//
//	FINDB(find_text,within_text,[start_num])
func (fn *formulaFuncs) FINDB(argsList *list.List) formulaArg {
	return fn.find("FINDB", argsList)
}

// prepareFindArgs checking and prepare arguments for the formula functions
// FIND, FINDB, SEARCH and SEARCHB.
func (fn *formulaFuncs) prepareFindArgs(name string, argsList *list.List) formulaArg {
	if argsList.Len() < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires at least 2 arguments", name))
	}
	if argsList.Len() > 3 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s allows at most 3 arguments", name))
	}
	startNum := 1
	if argsList.Len() == 3 {
		numArg := argsList.Back().Value.(formulaArg).ToNumber()
		if numArg.Type != ArgNumber {
			return numArg
		}
		if numArg.Number < 0 {
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
		startNum = int(numArg.Number)
	}
	return newListFormulaArg([]formulaArg{newNumberFormulaArg(float64(startNum))})
}

// find is an implementation of the formula functions FIND, FINDB, SEARCH and
// SEARCHB.
func (fn *formulaFuncs) find(name string, argsList *list.List) formulaArg {
	args := fn.prepareFindArgs(name, argsList)
	if args.Type != ArgList {
		return args
	}
	findTextArg := argsList.Front().Value.(formulaArg)
	withinText := argsList.Front().Next().Value.(formulaArg).Value()
	startNum := int(args.List[0].Number)
	dbcs, search := name == "FINDB" || name == "SEARCHB", name == "SEARCH" || name == "SEARCHB"
	find := func(findText string) formulaArg {
		if findText == "" {
			return newNumberFormulaArg(float64(startNum))
		}
		if search {
			findText, withinText = strings.ToUpper(findText), strings.ToUpper(withinText)
		}
		offset, ok := matchPattern(findText, withinText, dbcs, startNum)
		if !ok {
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
		result := offset
		if dbcs {
			var pre int
			for idx := range withinText {
				if pre > offset {
					break
				}
				if idx-pre > 1 {
					result++
				}
				pre = idx
			}
		}
		return newNumberFormulaArg(float64(result))
	}
	if findTextArg.Type == ArgMatrix {
		var mtx [][]formulaArg
		for _, row := range findTextArg.Matrix {
			var array []formulaArg
			for _, findText := range row {
				array = append(array, find(findText.Value()))
			}
			mtx = append(mtx, array)
		}
		return newMatrixFormulaArg(mtx)
	}
	return find(findTextArg.Value())
}

// LEFT function returns a specified number of characters from the start of a
// supplied text string. The syntax of the function is:
//
//	LEFT(text,[num_chars])
func (fn *formulaFuncs) LEFT(argsList *list.List) formulaArg {
	return fn.leftRight("LEFT", argsList)
}

// LEFTB returns the first character or characters in a text string, based on
// the number of bytes you specify. The syntax of the function is:
//
//	LEFTB(text,[num_bytes])
func (fn *formulaFuncs) LEFTB(argsList *list.List) formulaArg {
	return fn.leftRight("LEFTB", argsList)
}

// leftRight is an implementation of the formula functions LEFT, LEFTB, RIGHT,
// RIGHTB.
func (fn *formulaFuncs) leftRight(name string, argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires at least 1 argument", name))
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s allows at most 2 arguments", name))
	}
	text, numChars := argsList.Front().Value.(formulaArg).Value(), 1
	if argsList.Len() == 2 {
		numArg := argsList.Back().Value.(formulaArg).ToNumber()
		if numArg.Type != ArgNumber {
			return numArg
		}
		if numArg.Number < 0 {
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
		numChars = int(numArg.Number)
	}
	if name == "LEFTB" || name == "RIGHTB" {
		if len(text) > numChars {
			if name == "LEFTB" {
				return newStringFormulaArg(text[:numChars])
			}
			// RIGHTB
			return newStringFormulaArg(text[len(text)-numChars:])
		}
		return newStringFormulaArg(text)
	}
	// LEFT/RIGHT
	if utf8.RuneCountInString(text) > numChars {
		if name == "LEFT" {
			return newStringFormulaArg(string([]rune(text)[:numChars]))
		}
		// RIGHT
		return newStringFormulaArg(string([]rune(text)[utf8.RuneCountInString(text)-numChars:]))
	}
	return newStringFormulaArg(text)
}

// LEN returns the length of a supplied text string. The syntax of the
// function is:
//
//	LEN(text)
func (fn *formulaFuncs) LEN(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "LEN requires 1 string argument")
	}
	return newNumberFormulaArg(float64(utf8.RuneCountInString(argsList.Front().Value.(formulaArg).Value())))
}

// LENB returns the number of bytes used to represent the characters in a text
// string. LENB counts 2 bytes per character only when a DBCS language is set
// as the default language. Otherwise LENB behaves the same as LEN, counting
// 1 byte per character. The syntax of the function is:
//
//	LENB(text)
func (fn *formulaFuncs) LENB(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "LENB requires 1 string argument")
	}
	result := 0
	for _, r := range argsList.Front().Value.(formulaArg).Value() {
		b := utf8.RuneLen(r)
		if b == 1 {
			result++
		} else if b > 1 {
			result += 2
		}
	}
	return newNumberFormulaArg(float64(result))
}

// LOWER converts all characters in a supplied text string to lower case. The
// syntax of the function is:
//
//	LOWER(text)
func (fn *formulaFuncs) LOWER(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "LOWER requires 1 argument")
	}
	return newStringFormulaArg(strings.ToLower(argsList.Front().Value.(formulaArg).Value()))
}

// MID function returns a specified number of characters from the middle of a
// supplied text string. The syntax of the function is:
//
//	MID(text,start_num,num_chars)
func (fn *formulaFuncs) MID(argsList *list.List) formulaArg {
	return fn.mid("MID", argsList)
}

// MIDB returns a specific number of characters from a text string, starting
// at the position you specify, based on the number of bytes you specify. The
// syntax of the function is:
//
//	MID(text,start_num,num_chars)
func (fn *formulaFuncs) MIDB(argsList *list.List) formulaArg {
	return fn.mid("MIDB", argsList)
}

// mid is an implementation of the formula functions MID and MIDB.
func (fn *formulaFuncs) mid(name string, argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires 3 arguments", name))
	}
	text := argsList.Front().Value.(formulaArg).Value()
	startNumArg, numCharsArg := argsList.Front().Next().Value.(formulaArg).ToNumber(), argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if startNumArg.Type != ArgNumber {
		return startNumArg
	}
	if numCharsArg.Type != ArgNumber {
		return numCharsArg
	}
	startNum := int(startNumArg.Number)
	if startNum < 1 || numCharsArg.Number < 0 {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	if name == "MIDB" {
		var result string
		var cnt, offset int
		for _, char := range text {
			offset++
			var dbcs bool
			if utf8.RuneLen(char) > 1 {
				dbcs = true
				offset++
			}
			if cnt == int(numCharsArg.Number) {
				break
			}
			if offset+1 > startNum {
				if dbcs {
					if cnt+2 > int(numCharsArg.Number) {
						result += string(char)[:1]
						break
					}
					result += string(char)
					cnt += 2
				} else {
					result += string(char)
					cnt++
				}
			}
		}
		return newStringFormulaArg(result)
	}
	// MID
	textLen := utf8.RuneCountInString(text)
	if startNum > textLen {
		return newStringFormulaArg("")
	}
	startNum--
	endNum := startNum + int(numCharsArg.Number)
	if endNum > textLen+1 {
		return newStringFormulaArg(string([]rune(text)[startNum:]))
	}
	return newStringFormulaArg(string([]rune(text)[startNum:endNum]))
}

// PROPER converts all characters in a supplied text string to proper case
// (i.e. all letters that do not immediately follow another letter are set to
// upper case and all other characters are lower case). The syntax of the
// function is:
//
//	PROPER(text)
func (fn *formulaFuncs) PROPER(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "PROPER requires 1 argument")
	}
	buf := bytes.Buffer{}
	isLetter := false
	for _, char := range argsList.Front().Value.(formulaArg).Value() {
		if !isLetter && unicode.IsLetter(char) {
			buf.WriteRune(unicode.ToUpper(char))
		} else {
			buf.WriteRune(unicode.ToLower(char))
		}
		isLetter = unicode.IsLetter(char)
	}
	return newStringFormulaArg(buf.String())
}

// REPLACE function replaces all or part of a text string with another string.
// The syntax of the function is:
//
//	REPLACE(old_text,start_num,num_chars,new_text)
func (fn *formulaFuncs) REPLACE(argsList *list.List) formulaArg {
	return fn.replace("REPLACE", argsList)
}

// REPLACEB replaces part of a text string, based on the number of bytes you
// specify, with a different text string.
//
//	REPLACEB(old_text,start_num,num_chars,new_text)
func (fn *formulaFuncs) REPLACEB(argsList *list.List) formulaArg {
	return fn.replace("REPLACEB", argsList)
}

// replace is an implementation of the formula functions REPLACE and REPLACEB.
// TODO: support DBCS include Japanese, Chinese (Simplified), Chinese
// (Traditional), and Korean.
func (fn *formulaFuncs) replace(name string, argsList *list.List) formulaArg {
	if argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires 4 arguments", name))
	}
	sourceText, targetText := argsList.Front().Value.(formulaArg).Value(), argsList.Back().Value.(formulaArg).Value()
	startNumArg, numCharsArg := argsList.Front().Next().Value.(formulaArg).ToNumber(), argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
	if startNumArg.Type != ArgNumber {
		return startNumArg
	}
	if numCharsArg.Type != ArgNumber {
		return numCharsArg
	}
	sourceTextLen, startIdx := len(sourceText), int(startNumArg.Number)
	if startIdx > sourceTextLen {
		startIdx = sourceTextLen + 1
	}
	endIdx := startIdx + int(numCharsArg.Number)
	if endIdx > sourceTextLen {
		endIdx = sourceTextLen + 1
	}
	if startIdx < 1 || endIdx < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	result := sourceText[:startIdx-1] + targetText + sourceText[endIdx-1:]
	return newStringFormulaArg(result)
}

// REPT function returns a supplied text string, repeated a specified number
// of times. The syntax of the function is:
//
//	REPT(text,number_times)
func (fn *formulaFuncs) REPT(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "REPT requires 2 arguments")
	}
	text := argsList.Front().Value.(formulaArg)
	if text.Type != ArgString {
		return newErrorFormulaArg(formulaErrorVALUE, "REPT requires first argument to be a string")
	}
	times := argsList.Back().Value.(formulaArg).ToNumber()
	if times.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, "REPT requires second argument to be a number")
	}
	if times.Number < 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "REPT requires second argument to be >= 0")
	}
	if times.Number == 0 {
		return newStringFormulaArg("")
	}
	buf := bytes.Buffer{}
	for i := 0; i < int(times.Number); i++ {
		buf.WriteString(text.Value())
	}
	return newStringFormulaArg(buf.String())
}

// RIGHT function returns a specified number of characters from the end of a
// supplied text string. The syntax of the function is:
//
//	RIGHT(text,[num_chars])
func (fn *formulaFuncs) RIGHT(argsList *list.List) formulaArg {
	return fn.leftRight("RIGHT", argsList)
}

// RIGHTB returns the last character or characters in a text string, based on
// the number of bytes you specify. The syntax of the function is:
//
//	RIGHTB(text,[num_bytes])
func (fn *formulaFuncs) RIGHTB(argsList *list.List) formulaArg {
	return fn.leftRight("RIGHTB", argsList)
}

// SEARCH function returns the position of a specified character or sub-string
// within a supplied text string. The syntax of the function is:
//
//	SEARCH(search_text,within_text,[start_num])
func (fn *formulaFuncs) SEARCH(argsList *list.List) formulaArg {
	return fn.find("SEARCH", argsList)
}

// SEARCHB functions locate one text string within a second text string, and
// return the number of the starting position of the first text string from the
// first character of the second text string. The syntax of the function is:
//
//	SEARCHB(search_text,within_text,[start_num])
func (fn *formulaFuncs) SEARCHB(argsList *list.List) formulaArg {
	return fn.find("SEARCHB", argsList)
}

// SUBSTITUTE function replaces one or more instances of a given text string,
// within an original text string. The syntax of the function is:
//
//	SUBSTITUTE(text,old_text,new_text,[instance_num])
func (fn *formulaFuncs) SUBSTITUTE(argsList *list.List) formulaArg {
	if argsList.Len() != 3 && argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "SUBSTITUTE requires 3 or 4 arguments")
	}
	text, sourceText := argsList.Front().Value.(formulaArg), argsList.Front().Next().Value.(formulaArg)
	targetText, instanceNum := argsList.Front().Next().Next().Value.(formulaArg), 0
	if argsList.Len() == 3 {
		return newStringFormulaArg(strings.ReplaceAll(text.Value(), sourceText.Value(), targetText.Value()))
	}
	instanceNumArg := argsList.Back().Value.(formulaArg).ToNumber()
	if instanceNumArg.Type != ArgNumber {
		return instanceNumArg
	}
	instanceNum = int(instanceNumArg.Number)
	if instanceNum < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "instance_num should be > 0")
	}
	str, sourceTextLen, count, chars, pos := text.Value(), len(sourceText.Value()), instanceNum, 0, -1
	for {
		count--
		index := strings.Index(str, sourceText.Value())
		if index == -1 {
			pos = -1
			break
		} else {
			pos = index + chars
			if count == 0 {
				break
			}
			idx := sourceTextLen + index
			chars += idx
			str = str[idx:]
		}
	}
	if pos == -1 {
		return newStringFormulaArg(text.Value())
	}
	pre, post := text.Value()[:pos], text.Value()[pos+sourceTextLen:]
	return newStringFormulaArg(pre + targetText.Value() + post)
}

// TEXT function converts a supplied numeric value into text, in a
// user-specified format. The syntax of the function is:
//
//	TEXT(value,format_text)
func (fn *formulaFuncs) TEXT(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "TEXT requires 2 arguments")
	}
	value, fmtText := argsList.Front().Value.(formulaArg), argsList.Back().Value.(formulaArg)
	if value.Type == ArgError {
		return value
	}
	if fmtText.Type == ArgError {
		return fmtText
	}
	cellType := CellTypeNumber
	if num := value.ToNumber(); num.Type != ArgNumber {
		cellType = CellTypeSharedString
	}
	return newStringFormulaArg(format(value.Value(), fmtText.Value(), false, cellType, nil))
}

// prepareTextAfterBefore checking and prepare arguments for the formula
// functions TEXTAFTER and TEXTBEFORE.
func (fn *formulaFuncs) prepareTextAfterBefore(name string, argsList *list.List) formulaArg {
	argsLen := argsList.Len()
	if argsLen < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires at least 2 arguments", name))
	}
	if argsLen > 6 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s accepts at most 6 arguments", name))
	}
	text, delimiter := argsList.Front().Value.(formulaArg), argsList.Front().Next().Value.(formulaArg)
	instanceNum, matchMode, matchEnd, ifNotFound := newNumberFormulaArg(1), newBoolFormulaArg(false), newBoolFormulaArg(false), newEmptyFormulaArg()
	if argsLen > 2 {
		instanceNum = argsList.Front().Next().Next().Value.(formulaArg).ToNumber()
		if instanceNum.Type != ArgNumber {
			return instanceNum
		}
	}
	if argsLen > 3 {
		matchMode = argsList.Front().Next().Next().Next().Value.(formulaArg).ToBool()
		if matchMode.Type != ArgNumber {
			return matchMode
		}
		if matchMode.Number == 1 {
			text, delimiter = newStringFormulaArg(strings.ToLower(text.Value())), newStringFormulaArg(strings.ToLower(delimiter.Value()))
		}
	}
	if argsLen > 4 {
		matchEnd = argsList.Front().Next().Next().Next().Next().Value.(formulaArg).ToBool()
		if matchEnd.Type != ArgNumber {
			return matchEnd
		}
	}
	if argsLen > 5 {
		ifNotFound = argsList.Back().Value.(formulaArg)
	}
	if text.Value() == "" {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	lenArgsList := list.New().Init()
	lenArgsList.PushBack(text)
	textLen := fn.LEN(lenArgsList)
	if instanceNum.Number == 0 || instanceNum.Number > textLen.Number {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	reverseSearch, startPos := instanceNum.Number < 0, 0.0
	if reverseSearch {
		startPos = textLen.Number
	}
	return newListFormulaArg([]formulaArg{
		text, delimiter, instanceNum, matchMode, matchEnd, ifNotFound,
		textLen, newBoolFormulaArg(reverseSearch), newNumberFormulaArg(startPos),
	})
}

// textAfterBeforeSearch is an implementation of the formula functions TEXTAFTER
// and TEXTBEFORE.
func textAfterBeforeSearch(text string, delimiter []string, startPos int, reverseSearch bool) (int, string) {
	idx := -1
	var modifiedDelimiter string
	for i := 0; i < len(delimiter); i++ {
		nextDelimiter := delimiter[i]
		nextIdx := strings.Index(text[startPos:], nextDelimiter)
		if nextIdx != -1 {
			nextIdx += startPos
		}
		if reverseSearch {
			nextIdx = strings.LastIndex(text[:startPos], nextDelimiter)
		}
		if idx == -1 || (((nextIdx < idx && !reverseSearch) || (nextIdx > idx && reverseSearch)) && idx != -1) {
			idx = nextIdx
			modifiedDelimiter = nextDelimiter
		}
	}
	return idx, modifiedDelimiter
}

// textAfterBeforeResult is an implementation of the formula functions TEXTAFTER
// and TEXTBEFORE.
func textAfterBeforeResult(name, modifiedDelimiter string, text []rune, foundIdx, repeatZero, textLen int, matchEndActive, matchEnd, reverseSearch bool) formulaArg {
	if name == "TEXTAFTER" {
		endPos := len(modifiedDelimiter)
		if (repeatZero > 1 || matchEndActive) && matchEnd && reverseSearch {
			endPos = 0
		}
		if foundIdx+endPos >= textLen {
			return newEmptyFormulaArg()
		}
		return newStringFormulaArg(string(text[foundIdx+endPos : textLen]))
	}
	return newStringFormulaArg(string(text[:foundIdx]))
}

// textAfterBefore is an implementation of the formula functions TEXTAFTER and
// TEXTBEFORE.
func (fn *formulaFuncs) textAfterBefore(name string, argsList *list.List) formulaArg {
	args := fn.prepareTextAfterBefore(name, argsList)
	if args.Type != ArgList {
		return args
	}
	var (
		text                 = []rune(argsList.Front().Value.(formulaArg).Value())
		modifiedText         = args.List[0].Value()
		delimiter            = []string{args.List[1].Value()}
		instanceNum          = args.List[2].Number
		matchEnd             = args.List[4].Number == 1
		ifNotFound           = args.List[5]
		textLen              = args.List[6]
		reverseSearch        = args.List[7].Number == 1
		foundIdx             = -1
		repeatZero, startPos int
		matchEndActive       bool
		modifiedDelimiter    string
	)
	if reverseSearch {
		startPos = int(args.List[8].Number)
	}
	for i := 0; i < int(math.Abs(instanceNum)); i++ {
		foundIdx, modifiedDelimiter = textAfterBeforeSearch(modifiedText, delimiter, startPos, reverseSearch)
		if foundIdx == 0 {
			repeatZero++
		}
		if foundIdx == -1 {
			if matchEnd && i == int(math.Abs(instanceNum))-1 {
				if foundIdx = int(textLen.Number); reverseSearch {
					foundIdx = 0
				}
				matchEndActive = true
			}
			break
		}
		if startPos = foundIdx + len(modifiedDelimiter); reverseSearch {
			startPos = foundIdx - len(modifiedDelimiter)
		}
	}
	if foundIdx == -1 {
		return ifNotFound
	}
	return textAfterBeforeResult(name, modifiedDelimiter, text, foundIdx, repeatZero, int(textLen.Number), matchEndActive, matchEnd, reverseSearch)
}

// TEXTAFTER function returns the text that occurs after a given substring or
// delimiter. The syntax of the function is:
//
//	TEXTAFTER(text,delimiter,[instance_num],[match_mode],[match_end],[if_not_found])
func (fn *formulaFuncs) TEXTAFTER(argsList *list.List) formulaArg {
	return fn.textAfterBefore("TEXTAFTER", argsList)
}

// TEXTBEFORE function returns text that occurs before a given character or
// string. The syntax of the function is:
//
//	TEXTBEFORE(text,delimiter,[instance_num],[match_mode],[match_end],[if_not_found])
func (fn *formulaFuncs) TEXTBEFORE(argsList *list.List) formulaArg {
	return fn.textAfterBefore("TEXTBEFORE", argsList)
}

// TEXTJOIN function joins together a series of supplied text strings into one
// combined text string. The user can specify a delimiter to add between the
// individual text items, if required. The syntax of the function is:
//
//	TEXTJOIN([delimiter],[ignore_empty],text1,[text2],...)
func (fn *formulaFuncs) TEXTJOIN(argsList *list.List) formulaArg {
	if argsList.Len() < 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "TEXTJOIN requires at least 3 arguments")
	}
	if argsList.Len() > 252 {
		return newErrorFormulaArg(formulaErrorVALUE, "TEXTJOIN accepts at most 252 arguments")
	}
	delimiter := argsList.Front().Value.(formulaArg)
	ignoreEmpty := argsList.Front().Next().Value.(formulaArg)
	if ignoreEmpty.Type != ArgNumber || !ignoreEmpty.Boolean {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	args, ok := textJoin(argsList.Front().Next().Next(), []string{}, ignoreEmpty.Number != 0)
	if ok.Type != ArgNumber {
		return ok
	}
	result := strings.Join(args, delimiter.Value())
	if countUTF16String(result) > TotalCellChars {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("TEXTJOIN function exceeds %d characters", TotalCellChars))
	}
	return newStringFormulaArg(result)
}

// textJoin is an implementation of the formula function TEXTJOIN.
func textJoin(arg *list.Element, arr []string, ignoreEmpty bool) ([]string, formulaArg) {
	for arg.Next(); arg != nil; arg = arg.Next() {
		switch arg.Value.(formulaArg).Type {
		case ArgError:
			return arr, arg.Value.(formulaArg)
		case ArgString, ArgEmpty:
			val := arg.Value.(formulaArg).Value()
			if val != "" || !ignoreEmpty {
				arr = append(arr, val)
			}
		case ArgNumber:
			arr = append(arr, arg.Value.(formulaArg).Value())
		case ArgMatrix:
			for _, row := range arg.Value.(formulaArg).Matrix {
				argList := list.New().Init()
				for _, ele := range row {
					argList.PushBack(ele)
				}
				if argList.Len() > 0 {
					args, _ := textJoin(argList.Front(), []string{}, ignoreEmpty)
					arr = append(arr, args...)
				}
			}
		}
	}
	return arr, newBoolFormulaArg(true)
}

// TRIM removes extra spaces (i.e. all spaces except for single spaces between
// words or characters) from a supplied text string. The syntax of the
// function is:
//
//	TRIM(text)
func (fn *formulaFuncs) TRIM(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "TRIM requires 1 argument")
	}
	return newStringFormulaArg(strings.TrimSpace(argsList.Front().Value.(formulaArg).Value()))
}

// UNICHAR returns the Unicode character that is referenced by the given
// numeric value. The syntax of the function is:
//
//	UNICHAR(number)
func (fn *formulaFuncs) UNICHAR(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "UNICHAR requires 1 argument")
	}
	numArg := argsList.Front().Value.(formulaArg).ToNumber()
	if numArg.Type != ArgNumber {
		return numArg
	}
	if numArg.Number <= 0 || numArg.Number > 55295 {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	return newStringFormulaArg(string(rune(numArg.Number)))
}

// UNICODE function returns the code point for the first character of a
// supplied text string. The syntax of the function is:
//
//	UNICODE(text)
func (fn *formulaFuncs) UNICODE(argsList *list.List) formulaArg {
	return fn.code("UNICODE", argsList)
}

// UNIQUE function returns a list of unique values in a list or range. The
// syntax of the function is:
//
//	UNIQUE(array,[by_col],[exactly_once])
func (fn *formulaFuncs) UNIQUE(argsList *list.List) formulaArg {
	args, errArg := getFormulaUniqueArgs(argsList)
	if errArg != nil {
		return *errArg
	}
	if args.byColumn {
		args.cellRange, args.cols, args.rows = transposeFormulaArgsList(args.cellRange, args.cols, args.rows)
	}
	counts := map[string]int{}
	for i := 0; i < len(args.cellRange); i += args.cols {
		key := concatValues(args.cellRange[i : i+args.cols])

		if _, ok := counts[key]; !ok {
			counts[key] = 0
		}
		counts[key]++
	}
	uniqueAxes := [][]formulaArg{}
	for i := 0; i < len(args.cellRange); i += args.cols {
		key := concatValues(args.cellRange[i : i+args.cols])

		if (args.exactlyOnce && counts[key] == 1) || (!args.exactlyOnce && counts[key] >= 1) {
			uniqueAxes = append(uniqueAxes, args.cellRange[i:i+args.cols])
		}
		delete(counts, key)
	}
	if args.byColumn {
		uniqueAxes = transposeFormulaArgsMatrix(uniqueAxes)
	}
	return newMatrixFormulaArg(uniqueAxes)
}

// transposeFormulaArgsMatrix transposes a 2D slice of formulaArg.
func transposeFormulaArgsMatrix(args [][]formulaArg) [][]formulaArg {
	if len(args) == 0 {
		return args
	}
	transposedArgs := make([][]formulaArg, len(args[0]))
	for i := 0; i < len(args[0]); i++ {
		transposedArgs[i] = make([]formulaArg, len(args))
	}
	for i := 0; i < len(args); i++ {
		for j := 0; j < len(args[i]); j++ {
			transposedArgs[j][i] = args[i][j]
		}
	}
	return transposedArgs
}

// transposeFormulaArgsList transposes a flat slice of formulaArg given the
// number of columns and rows.
func transposeFormulaArgsList(args []formulaArg, cols, rows int) ([]formulaArg, int, int) {
	transposedArgs := make([]formulaArg, len(args))
	for i := 0; i < rows; i++ {
		for j := 0; j < cols; j++ {
			transposedArgs[j*rows+i] = args[i*cols+j]
		}
	}
	return transposedArgs, rows, cols
}

// concatValues concatenates the values of a slice of formulaArg into a single
// string.
func concatValues(args []formulaArg) string {
	val := ""
	for _, arg := range args {
		// Call to Value is cheap.
		val += arg.Value()
	}
	return val
}

// uniqueArgs holds the parsed arguments for the UNIQUE function.
type uniqueArgs struct {
	cellRange   []formulaArg
	cols        int
	rows        int
	byColumn    bool
	exactlyOnce bool
}

// getFormulaUniqueArgs parses and validates the arguments for the UNIQUE
// function.
func getFormulaUniqueArgs(argsList *list.List) (uniqueArgs, *formulaArg) {
	res := uniqueArgs{}
	argsLen := argsList.Len()
	if argsLen == 0 {
		errArg := newErrorFormulaArg(formulaErrorVALUE, "UNIQUE requires at least 1 argument")
		return res, &errArg
	}
	if argsLen > 3 {
		msg := fmt.Sprintf("UNIQUE takes at most 3 arguments, received %d arguments", argsLen)
		errArg := newErrorFormulaArg(formulaErrorVALUE, msg)

		return res, &errArg
	}
	firstArg := argsList.Front()
	res.cellRange = firstArg.Value.(formulaArg).ToList()
	if len(res.cellRange) == 0 {
		errArg := newErrorFormulaArg(formulaErrorVALUE, "missing first argument to UNIQUE")
		return res, &errArg
	}
	if res.cellRange[0].Type == ArgError {
		return res, &res.cellRange[0]
	}
	rmin, rmax := calcColsRowsMinMax(false, argsList)
	cmin, cmax := calcColsRowsMinMax(true, argsList)
	res.cols, res.rows = cmax-cmin+1, rmax-rmin+1
	secondArg := firstArg.Next()
	if secondArg == nil {
		return res, nil
	}
	argByColumn := secondArg.Value.(formulaArg).ToBool()
	if argByColumn.Type == ArgError {
		return res, &argByColumn
	}
	res.byColumn = (argByColumn.Value() == "TRUE")
	thirdArg := secondArg.Next()
	if thirdArg == nil {
		return res, nil
	}
	argExactlyOnce := thirdArg.Value.(formulaArg).ToBool()
	if argExactlyOnce.Type == ArgError {
		return res, &argExactlyOnce
	}
	res.exactlyOnce = (argExactlyOnce.Value() == "TRUE")
	return res, nil
}

// UPPER converts all characters in a supplied text string to upper case. The
// syntax of the function is:
//
//	UPPER(text)
func (fn *formulaFuncs) UPPER(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "UPPER requires 1 argument")
	}
	return newStringFormulaArg(strings.ToUpper(argsList.Front().Value.(formulaArg).Value()))
}

// VALUE function converts a text string into a numeric value. The syntax of
// the function is:
//
//	VALUE(text)
func (fn *formulaFuncs) VALUE(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "VALUE requires 1 argument")
	}
	text := strings.ReplaceAll(argsList.Front().Value.(formulaArg).Value(), ",", "")
	percent := 1.0
	if strings.HasSuffix(text, "%") {
		percent, text = 0.01, strings.TrimSuffix(text, "%")
	}
	decimal := big.Float{}
	if _, ok := decimal.SetString(text); ok {
		value, _ := decimal.Float64()
		return newNumberFormulaArg(value * percent)
	}
	dateValue, timeValue, errTime := 0.0, 0.0, false
	if !isDateOnlyFmt(text) {
		h, m, s, _, _, err := strToTime(text)
		errTime = err.Type == ArgError
		if !errTime {
			timeValue = (float64(h)*3600 + float64(m)*60 + s) / 86400
		}
	}
	y, m, d, _, err := strToDate(text)
	errDate := err.Type == ArgError
	if !errDate {
		dateValue = daysBetween(excelMinTime1900.Unix(), makeDate(y, time.Month(m), d)) + 1
	}
	if errTime && errDate {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	return newNumberFormulaArg(dateValue + timeValue)
}

// VALUETOTEXT function returns text from any specified value. It passes text
// values unchanged, and converts non-text values to text.
//
//	VALUETOTEXT(value,[format])
func (fn *formulaFuncs) VALUETOTEXT(argsList *list.List) formulaArg {
	format := prepareToText("VALUETOTEXT", argsList)
	if format.Type != ArgNumber {
		return format
	}
	cell := argsList.Front().Value.(formulaArg)
	if num := cell.ToNumber(); num.Type != ArgNumber && format.Number == 1 {
		return newStringFormulaArg(fmt.Sprintf("\"%s\"", cell.Value()))
	}
	return newStringFormulaArg(cell.Value())
}

// Conditional Functions

// IF function tests a supplied condition and returns one result if the
// condition evaluates to TRUE, and another result if the condition evaluates
// to FALSE. The syntax of the function is:
//
//	IF(logical_test,value_if_true,value_if_false)
