// Copyright 2016 - 2025 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excel™ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.24.0 or later.

package excelize

import (
	"bytes"
	"container/list"
	"fmt"
	"math"
	"math/rand"
	"strconv"
	"strings"
	"time"
)

// ABS function returns the absolute value of any supplied number. The syntax
// of the function is:
//
//	ABS(number)
func (fn *formulaFuncs) ABS(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ABS requires 1 numeric argument")
	}
	arg := argsList.Front().Value.(formulaArg).ToNumber()
	if arg.Type == ArgError {
		return arg
	}
	return newNumberFormulaArg(math.Abs(arg.Number))
}

// ACOS function calculates the arccosine (i.e. the inverse cosine) of a given
// number, and returns an angle, in radians, between 0 and π. The syntax of
// the function is:
//
//	ACOS(number)
func (fn *formulaFuncs) ACOS(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ACOS requires 1 numeric argument")
	}
	arg := argsList.Front().Value.(formulaArg).ToNumber()
	if arg.Type == ArgError {
		return arg
	}
	return newNumberFormulaArg(math.Acos(arg.Number))
}

// ACOSH function calculates the inverse hyperbolic cosine of a supplied number.
// of the function is:
//
//	ACOSH(number)
func (fn *formulaFuncs) ACOSH(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ACOSH requires 1 numeric argument")
	}
	arg := argsList.Front().Value.(formulaArg).ToNumber()
	if arg.Type == ArgError {
		return arg
	}
	return newNumberFormulaArg(math.Acosh(arg.Number))
}

// ACOT function calculates the arccotangent (i.e. the inverse cotangent) of a
// given number, and returns an angle, in radians, between 0 and π. The syntax
// of the function is:
//
//	ACOT(number)
func (fn *formulaFuncs) ACOT(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ACOT requires 1 numeric argument")
	}
	arg := argsList.Front().Value.(formulaArg).ToNumber()
	if arg.Type == ArgError {
		return arg
	}
	return newNumberFormulaArg(math.Pi/2 - math.Atan(arg.Number))
}

// ACOTH function calculates the hyperbolic arccotangent (coth) of a supplied
// value. The syntax of the function is:
//
//	ACOTH(number)
func (fn *formulaFuncs) ACOTH(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ACOTH requires 1 numeric argument")
	}
	arg := argsList.Front().Value.(formulaArg).ToNumber()
	if arg.Type == ArgError {
		return arg
	}
	return newNumberFormulaArg(math.Atanh(1 / arg.Number))
}

// AGGREGATE function returns the result of a specified operation or function,
// applied to a list or database of values. The syntax of the function is:
//
//	AGGREGATE(function_num,options,ref1,[ref2],...)
func (fn *formulaFuncs) AGGREGATE(argsList *list.List) formulaArg {
	if argsList.Len() < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "AGGREGATE requires at least 3 arguments")
	}
	var fnNum, opts formulaArg
	if fnNum = argsList.Front().Value.(formulaArg).ToNumber(); fnNum.Type != ArgNumber {
		return fnNum
	}
	subFn, ok := map[int]func(argsList *list.List) formulaArg{
		1:  fn.AVERAGE,
		2:  fn.COUNT,
		3:  fn.COUNTA,
		4:  fn.MAX,
		5:  fn.MIN,
		6:  fn.PRODUCT,
		7:  fn.STDEVdotS,
		8:  fn.STDEVdotP,
		9:  fn.SUM,
		10: fn.VARdotS,
		11: fn.VARdotP,
		12: fn.MEDIAN,
		13: fn.MODEdotSNGL,
		14: fn.LARGE,
		15: fn.SMALL,
		16: fn.PERCENTILEdotINC,
		17: fn.QUARTILEdotINC,
		18: fn.PERCENTILEdotEXC,
		19: fn.QUARTILEdotEXC,
	}[int(fnNum.Number)]
	if !ok {
		return newErrorFormulaArg(formulaErrorVALUE, "AGGREGATE has invalid function_num")
	}
	if opts = argsList.Front().Next().Value.(formulaArg).ToNumber(); opts.Type != ArgNumber {
		return opts
	}
	// TODO: apply option argument values to be ignored during the calculation
	if int(opts.Number) < 0 || int(opts.Number) > 7 {
		return newErrorFormulaArg(formulaErrorVALUE, "AGGREGATE has invalid options")
	}
	subArgList := list.New().Init()
	for arg := argsList.Front().Next().Next(); arg != nil; arg = arg.Next() {
		subArgList.PushBack(arg.Value.(formulaArg))
	}
	return subFn(subArgList)
}

// ARABIC function converts a Roman numeral into an Arabic numeral. The syntax
// of the function is:
//
//	ARABIC(text)
func (fn *formulaFuncs) ARABIC(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ARABIC requires 1 numeric argument")
	}
	text := argsList.Front().Value.(formulaArg).Value()
	if len(text) > MaxFieldLength {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	text = strings.ToUpper(text)
	number, actualStart, index, isNegative := 0, 0, len(text)-1, false
	startIndex, subtractNumber, currentPartValue, currentCharValue, prevCharValue := 0, 0, 0, 0, -1
	for index >= 0 && text[index] == ' ' {
		index--
	}
	for actualStart <= index && text[actualStart] == ' ' {
		actualStart++
	}
	if actualStart <= index && text[actualStart] == '-' {
		isNegative = true
		actualStart++
	}
	charMap := map[rune]int{'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
	for index >= actualStart {
		startIndex = index
		startChar := text[startIndex]
		index--
		for index >= actualStart && (text[index]|' ') == startChar {
			index--
		}
		currentCharValue = charMap[rune(startChar)]
		currentPartValue = (startIndex - index) * currentCharValue
		if currentCharValue >= prevCharValue {
			number += currentPartValue - subtractNumber
			prevCharValue = currentCharValue
			subtractNumber = 0
			continue
		}
		subtractNumber += currentPartValue
	}
	if subtractNumber != 0 {
		number -= subtractNumber
	}
	if isNegative {
		number = -number
	}
	return newNumberFormulaArg(float64(number))
}

// ASIN function calculates the arcsine (i.e. the inverse sine) of a given
// number, and returns an angle, in radians, between -π/2 and π/2. The syntax
// of the function is:
//
//	ASIN(number)
func (fn *formulaFuncs) ASIN(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ASIN requires 1 numeric argument")
	}
	arg := argsList.Front().Value.(formulaArg).ToNumber()
	if arg.Type == ArgError {
		return arg
	}
	return newNumberFormulaArg(math.Asin(arg.Number))
}

// ASINH function calculates the inverse hyperbolic sine of a supplied number.
// The syntax of the function is:
//
//	ASINH(number)
func (fn *formulaFuncs) ASINH(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ASINH requires 1 numeric argument")
	}
	arg := argsList.Front().Value.(formulaArg).ToNumber()
	if arg.Type == ArgError {
		return arg
	}
	return newNumberFormulaArg(math.Asinh(arg.Number))
}

// ATAN function calculates the arctangent (i.e. the inverse tangent) of a
// given number, and returns an angle, in radians, between -π/2 and +π/2. The
// syntax of the function is:
//
//	ATAN(number)
func (fn *formulaFuncs) ATAN(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ATAN requires 1 numeric argument")
	}
	arg := argsList.Front().Value.(formulaArg).ToNumber()
	if arg.Type == ArgError {
		return arg
	}
	return newNumberFormulaArg(math.Atan(arg.Number))
}

// ATANH function calculates the inverse hyperbolic tangent of a supplied
// number. The syntax of the function is:
//
//	ATANH(number)
func (fn *formulaFuncs) ATANH(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ATANH requires 1 numeric argument")
	}
	arg := argsList.Front().Value.(formulaArg).ToNumber()
	if arg.Type == ArgError {
		return arg
	}
	return newNumberFormulaArg(math.Atanh(arg.Number))
}

// ATAN2 function calculates the arctangent (i.e. the inverse tangent) of a
// given set of x and y coordinates, and returns an angle, in radians, between
// -π/2 and +π/2. The syntax of the function is:
//
//	ATAN2(x_num,y_num)
func (fn *formulaFuncs) ATAN2(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "ATAN2 requires 2 numeric arguments")
	}
	x := argsList.Back().Value.(formulaArg).ToNumber()
	if x.Type == ArgError {
		return x
	}
	y := argsList.Front().Value.(formulaArg).ToNumber()
	if y.Type == ArgError {
		return y
	}
	return newNumberFormulaArg(math.Atan2(x.Number, y.Number))
}

// BASE function converts a number into a supplied base (radix), and returns a
// text representation of the calculated value. The syntax of the function is:
//
//	BASE(number,radix,[min_length])
func (fn *formulaFuncs) BASE(argsList *list.List) formulaArg {
	if argsList.Len() < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "BASE requires at least 2 arguments")
	}
	if argsList.Len() > 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "BASE allows at most 3 arguments")
	}
	var minLength int
	var err error
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	radix := argsList.Front().Next().Value.(formulaArg).ToNumber()
	if radix.Type == ArgError {
		return radix
	}
	if int(radix.Number) < 2 || int(radix.Number) > 36 {
		return newErrorFormulaArg(formulaErrorVALUE, "radix must be an integer >= 2 and <= 36")
	}
	if argsList.Len() > 2 {
		if minLength, err = strconv.Atoi(argsList.Back().Value.(formulaArg).Value()); err != nil {
			return newErrorFormulaArg(formulaErrorVALUE, err.Error())
		}
	}
	result := strconv.FormatInt(int64(number.Number), int(radix.Number))
	if len(result) < minLength {
		result = strings.Repeat("0", minLength-len(result)) + result
	}
	return newStringFormulaArg(strings.ToUpper(result))
}

// CEILING function rounds a supplied number away from zero, to the nearest
// multiple of a given number. The syntax of the function is:
//
//	CEILING(number,significance)
func (fn *formulaFuncs) CEILING(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "CEILING requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "CEILING allows at most 2 arguments")
	}
	number, significance, res := 0.0, 1.0, 0.0
	n := argsList.Front().Value.(formulaArg).ToNumber()
	if n.Type == ArgError {
		return n
	}
	number = n.Number
	if number < 0 {
		significance = -1
	}
	if argsList.Len() > 1 {
		s := argsList.Back().Value.(formulaArg).ToNumber()
		if s.Type == ArgError {
			return s
		}
		significance = s.Number
	}
	if significance < 0 && number > 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "negative sig to CEILING invalid")
	}
	if argsList.Len() == 1 {
		return newNumberFormulaArg(math.Ceil(number))
	}
	number, res = math.Modf(number / significance)
	if res > 0 {
		number++
	}
	return newNumberFormulaArg(number * significance)
}

// CEILINGdotMATH function rounds a supplied number up to a supplied multiple
// of significance. The syntax of the function is:
//
//	CEILING.MATH(number,[significance],[mode])
func (fn *formulaFuncs) CEILINGdotMATH(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "CEILING.MATH requires at least 1 argument")
	}
	if argsList.Len() > 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "CEILING.MATH allows at most 3 arguments")
	}
	number, significance, mode := 0.0, 1.0, 1.0
	n := argsList.Front().Value.(formulaArg).ToNumber()
	if n.Type == ArgError {
		return n
	}
	number = n.Number
	if number < 0 {
		significance = -1
	}
	if argsList.Len() > 1 {
		s := argsList.Front().Next().Value.(formulaArg).ToNumber()
		if s.Type == ArgError {
			return s
		}
		significance = s.Number
	}
	if argsList.Len() == 1 {
		return newNumberFormulaArg(math.Ceil(number))
	}
	if argsList.Len() > 2 {
		m := argsList.Back().Value.(formulaArg).ToNumber()
		if m.Type == ArgError {
			return m
		}
		mode = m.Number
	}
	val, res := math.Modf(number / significance)
	if res != 0 {
		if number > 0 {
			val++
		} else if mode < 0 {
			val--
		}
	}
	return newNumberFormulaArg(val * significance)
}

// CEILINGdotPRECISE function rounds a supplied number up (regardless of the
// number's sign), to the nearest multiple of a given number. The syntax of
// the function is:
//
//	CEILING.PRECISE(number,[significance])
func (fn *formulaFuncs) CEILINGdotPRECISE(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "CEILING.PRECISE requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "CEILING.PRECISE allows at most 2 arguments")
	}
	number, significance := 0.0, 1.0
	n := argsList.Front().Value.(formulaArg).ToNumber()
	if n.Type == ArgError {
		return n
	}
	number = n.Number
	if number < 0 {
		significance = -1
	}
	if argsList.Len() == 1 {
		return newNumberFormulaArg(math.Ceil(number))
	}
	if argsList.Len() > 1 {
		s := argsList.Back().Value.(formulaArg).ToNumber()
		if s.Type == ArgError {
			return s
		}
		significance = s.Number
		significance = math.Abs(significance)
		if significance == 0 {
			return newNumberFormulaArg(significance)
		}
	}
	val, res := math.Modf(number / significance)
	if res != 0 {
		if number > 0 {
			val++
		}
	}
	return newNumberFormulaArg(val * significance)
}

// COMBIN function calculates the number of combinations (in any order) of a
// given number objects from a set. The syntax of the function is:
//
//	COMBIN(number,number_chosen)
func (fn *formulaFuncs) COMBIN(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "COMBIN requires 2 argument")
	}
	number, chosen, val := 0.0, 0.0, 1.0
	n := argsList.Front().Value.(formulaArg).ToNumber()
	if n.Type == ArgError {
		return n
	}
	number = n.Number
	c := argsList.Back().Value.(formulaArg).ToNumber()
	if c.Type == ArgError {
		return c
	}
	chosen = c.Number
	number, chosen = math.Trunc(number), math.Trunc(chosen)
	if chosen > number {
		return newErrorFormulaArg(formulaErrorVALUE, "COMBIN requires number >= number_chosen")
	}
	if chosen == number || chosen == 0 {
		return newNumberFormulaArg(1)
	}
	for c := float64(1); c <= chosen; c++ {
		val *= (number + 1 - c) / c
	}
	return newNumberFormulaArg(math.Ceil(val))
}

// COMBINA function calculates the number of combinations, with repetitions,
// of a given number objects from a set. The syntax of the function is:
//
//	COMBINA(number,number_chosen)
func (fn *formulaFuncs) COMBINA(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "COMBINA requires 2 argument")
	}
	var number, chosen float64
	n := argsList.Front().Value.(formulaArg).ToNumber()
	if n.Type == ArgError {
		return n
	}
	number = n.Number
	c := argsList.Back().Value.(formulaArg).ToNumber()
	if c.Type == ArgError {
		return c
	}
	chosen = c.Number
	number, chosen = math.Trunc(number), math.Trunc(chosen)
	if number < chosen {
		return newErrorFormulaArg(formulaErrorVALUE, "COMBINA requires number > number_chosen")
	}
	if number == 0 {
		return newNumberFormulaArg(number)
	}
	args := list.New()
	args.PushBack(formulaArg{
		String: fmt.Sprintf("%g", number+chosen-1),
		Type:   ArgString,
	})
	args.PushBack(formulaArg{
		String: fmt.Sprintf("%g", number-1),
		Type:   ArgString,
	})
	return fn.COMBIN(args)
}

// COS function calculates the cosine of a given angle. The syntax of the
// function is:
//
//	COS(number)
func (fn *formulaFuncs) COS(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "COS requires 1 numeric argument")
	}
	val := argsList.Front().Value.(formulaArg).ToNumber()
	if val.Type == ArgError {
		return val
	}
	return newNumberFormulaArg(math.Cos(val.Number))
}

// COSH function calculates the hyperbolic cosine (cosh) of a supplied number.
// The syntax of the function is:
//
//	COSH(number)
func (fn *formulaFuncs) COSH(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "COSH requires 1 numeric argument")
	}
	val := argsList.Front().Value.(formulaArg).ToNumber()
	if val.Type == ArgError {
		return val
	}
	return newNumberFormulaArg(math.Cosh(val.Number))
}

// COT function calculates the cotangent of a given angle. The syntax of the
// function is:
//
//	COT(number)
func (fn *formulaFuncs) COT(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "COT requires 1 numeric argument")
	}
	val := argsList.Front().Value.(formulaArg).ToNumber()
	if val.Type == ArgError {
		return val
	}
	if val.Number == 0 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	return newNumberFormulaArg(1 / math.Tan(val.Number))
}

// COTH function calculates the hyperbolic cotangent (coth) of a supplied
// angle. The syntax of the function is:
//
//	COTH(number)
func (fn *formulaFuncs) COTH(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "COTH requires 1 numeric argument")
	}
	val := argsList.Front().Value.(formulaArg).ToNumber()
	if val.Type == ArgError {
		return val
	}
	if val.Number == 0 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	return newNumberFormulaArg((math.Exp(val.Number) + math.Exp(-val.Number)) / (math.Exp(val.Number) - math.Exp(-val.Number)))
}

// CSC function calculates the cosecant of a given angle. The syntax of the
// function is:
//
//	CSC(number)
func (fn *formulaFuncs) CSC(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "CSC requires 1 numeric argument")
	}
	val := argsList.Front().Value.(formulaArg).ToNumber()
	if val.Type == ArgError {
		return val
	}
	if val.Number == 0 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	return newNumberFormulaArg(1 / math.Sin(val.Number))
}

// CSCH function calculates the hyperbolic cosecant (csch) of a supplied
// angle. The syntax of the function is:
//
//	CSCH(number)
func (fn *formulaFuncs) CSCH(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "CSCH requires 1 numeric argument")
	}
	val := argsList.Front().Value.(formulaArg).ToNumber()
	if val.Type == ArgError {
		return val
	}
	if val.Number == 0 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	return newNumberFormulaArg(1 / math.Sinh(val.Number))
}

// DECIMAL function converts a text representation of a number in a specified
// base, into a decimal value. The syntax of the function is:
//
//	DECIMAL(text,radix)
func (fn *formulaFuncs) DECIMAL(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "DECIMAL requires 2 numeric arguments")
	}
	text := argsList.Front().Value.(formulaArg).Value()
	var err error
	radix := argsList.Back().Value.(formulaArg).ToNumber()
	if radix.Type != ArgNumber {
		return radix
	}
	if len(text) > 2 && (strings.HasPrefix(text, "0x") || strings.HasPrefix(text, "0X")) {
		text = text[2:]
	}
	val, err := strconv.ParseInt(text, int(radix.Number), 64)
	if err != nil {
		return newErrorFormulaArg(formulaErrorVALUE, err.Error())
	}
	return newNumberFormulaArg(float64(val))
}

// DEGREES function converts radians into degrees. The syntax of the function
// is:
//
//	DEGREES(angle)
func (fn *formulaFuncs) DEGREES(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "DEGREES requires 1 numeric argument")
	}
	val := argsList.Front().Value.(formulaArg).ToNumber()
	if val.Type == ArgError {
		return val
	}
	if val.Number == 0 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	return newNumberFormulaArg(180.0 / math.Pi * val.Number)
}

// EVEN function rounds a supplied number away from zero (i.e. rounds a
// positive number up and a negative number down), to the next even number.
// The syntax of the function is:
//
//	EVEN(number)
func (fn *formulaFuncs) EVEN(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "EVEN requires 1 numeric argument")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	sign := math.Signbit(number.Number)
	m, frac := math.Modf(number.Number / 2)
	val := m * 2
	if frac != 0 {
		if !sign {
			val += 2
		} else {
			val -= 2
		}
	}
	return newNumberFormulaArg(val)
}

// EXP function calculates the value of the mathematical constant e, raised to
// the power of a given number. The syntax of the function is:
//
//	EXP(number)
func (fn *formulaFuncs) EXP(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "EXP requires 1 numeric argument")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	return newNumberFormulaArg(math.Exp(number.Number))
}

// fact returns the factorial of a supplied number.
func fact(number float64) float64 {
	val := float64(1)
	for i := float64(2); i <= number; i++ {
		val *= i
	}
	return val
}

// FACT function returns the factorial of a supplied number. The syntax of the
// function is:
//
//	FACT(number)
func (fn *formulaFuncs) FACT(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "FACT requires 1 numeric argument")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	if number.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(fact(number.Number))
}

// FACTDOUBLE function returns the double factorial of a supplied number. The
// syntax of the function is:
//
//	FACTDOUBLE(number)
func (fn *formulaFuncs) FACTDOUBLE(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "FACTDOUBLE requires 1 numeric argument")
	}
	val := 1.0
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	if number.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	for i := math.Trunc(number.Number); i > 1; i -= 2 {
		val *= i
	}
	return newStringFormulaArg(strings.ToUpper(fmt.Sprintf("%g", val)))
}

// FLOOR function rounds a supplied number towards zero to the nearest
// multiple of a specified significance. The syntax of the function is:
//
//	FLOOR(number,significance)
func (fn *formulaFuncs) FLOOR(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "FLOOR requires 2 numeric arguments")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	significance := argsList.Back().Value.(formulaArg).ToNumber()
	if significance.Type == ArgError {
		return significance
	}
	if significance.Number < 0 && number.Number >= 0 {
		return newErrorFormulaArg(formulaErrorNUM, "invalid arguments to FLOOR")
	}
	val := number.Number
	val, res := math.Modf(val / significance.Number)
	if res != 0 {
		if number.Number < 0 && res < 0 {
			val--
		}
	}
	return newNumberFormulaArg(val * significance.Number)
}

// FLOORdotMATH function rounds a supplied number down to a supplied multiple
// of significance. The syntax of the function is:
//
//	FLOOR.MATH(number,[significance],[mode])
func (fn *formulaFuncs) FLOORdotMATH(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "FLOOR.MATH requires at least 1 argument")
	}
	if argsList.Len() > 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "FLOOR.MATH allows at most 3 arguments")
	}
	significance, mode := 1.0, 1.0
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	if number.Number < 0 {
		significance = -1
	}
	if argsList.Len() > 1 {
		s := argsList.Front().Next().Value.(formulaArg).ToNumber()
		if s.Type == ArgError {
			return s
		}
		significance = s.Number
	}
	if argsList.Len() == 1 {
		return newNumberFormulaArg(math.Floor(number.Number))
	}
	if argsList.Len() > 2 {
		m := argsList.Back().Value.(formulaArg).ToNumber()
		if m.Type == ArgError {
			return m
		}
		mode = m.Number
	}
	val, res := math.Modf(number.Number / significance)
	if res != 0 && number.Number < 0 && mode > 0 {
		val--
	}
	return newNumberFormulaArg(val * significance)
}

// FLOORdotPRECISE function rounds a supplied number down to a supplied
// multiple of significance. The syntax of the function is:
//
//	FLOOR.PRECISE(number,[significance])
func (fn *formulaFuncs) FLOORdotPRECISE(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "FLOOR.PRECISE requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "FLOOR.PRECISE allows at most 2 arguments")
	}
	var significance float64
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	if number.Number < 0 {
		significance = -1
	}
	if argsList.Len() == 1 {
		return newNumberFormulaArg(math.Floor(number.Number))
	}
	if argsList.Len() > 1 {
		s := argsList.Back().Value.(formulaArg).ToNumber()
		if s.Type == ArgError {
			return s
		}
		significance = s.Number
		significance = math.Abs(significance)
		if significance == 0 {
			return newNumberFormulaArg(significance)
		}
	}
	val, res := math.Modf(number.Number / significance)
	if res != 0 {
		if number.Number < 0 {
			val--
		}
	}
	return newNumberFormulaArg(val * significance)
}

// gcd returns the greatest common divisor of two supplied integers.
func gcd(x, y float64) float64 {
	x, y = math.Trunc(x), math.Trunc(y)
	if x == 0 {
		return y
	}
	if y == 0 {
		return x
	}
	for x != y {
		if x > y {
			x = x - y
		} else {
			y = y - x
		}
	}
	return x
}

// GCD function returns the greatest common divisor of two or more supplied
// integers. The syntax of the function is:
//
//	GCD(number1,[number2],...)
func (fn *formulaFuncs) GCD(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "GCD requires at least 1 argument")
	}
	var (
		val  float64
		nums []float64
	)
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		token := arg.Value.(formulaArg)
		switch token.Type {
		case ArgString:
			num := token.ToNumber()
			if num.Type == ArgError {
				return num
			}
			val = num.Number
		case ArgNumber:
			val = token.Number
		}
		nums = append(nums, val)
	}
	if nums[0] < 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "GCD only accepts positive arguments")
	}
	if len(nums) == 1 {
		return newNumberFormulaArg(nums[0])
	}
	cd := nums[0]
	for i := 1; i < len(nums); i++ {
		if nums[i] < 0 {
			return newErrorFormulaArg(formulaErrorVALUE, "GCD only accepts positive arguments")
		}
		cd = gcd(cd, nums[i])
	}
	return newNumberFormulaArg(cd)
}

// INT function truncates a supplied number down to the closest integer. The
// syntax of the function is:
//
//	INT(number)
func (fn *formulaFuncs) INT(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "INT requires 1 numeric argument")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	val, frac := math.Modf(number.Number)
	if frac < 0 {
		val--
	}
	return newNumberFormulaArg(val)
}

// ISOdotCEILING function rounds a supplied number up (regardless of the
// number's sign), to the nearest multiple of a supplied significance. The
// syntax of the function is:
//
//	ISO.CEILING(number,[significance])
func (fn *formulaFuncs) ISOdotCEILING(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "ISO.CEILING requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "ISO.CEILING allows at most 2 arguments")
	}
	var significance float64
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	if number.Number < 0 {
		significance = -1
	}
	if argsList.Len() == 1 {
		return newNumberFormulaArg(math.Ceil(number.Number))
	}
	if argsList.Len() > 1 {
		s := argsList.Back().Value.(formulaArg).ToNumber()
		if s.Type == ArgError {
			return s
		}
		significance = s.Number
		significance = math.Abs(significance)
		if significance == 0 {
			return newNumberFormulaArg(significance)
		}
	}
	val, res := math.Modf(number.Number / significance)
	if res != 0 {
		if number.Number > 0 {
			val++
		}
	}
	return newNumberFormulaArg(val * significance)
}

// lcm returns the least common multiple of two supplied integers.
func lcm(a, b float64) float64 {
	a = math.Trunc(a)
	b = math.Trunc(b)
	if a == 0 && b == 0 {
		return 0
	}
	return a * b / gcd(a, b)
}

// LCM function returns the least common multiple of two or more supplied
// integers. The syntax of the function is:
//
//	LCM(number1,[number2],...)
func (fn *formulaFuncs) LCM(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "LCM requires at least 1 argument")
	}
	var (
		val  float64
		nums []float64
		err  error
	)
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		token := arg.Value.(formulaArg)
		switch token.Type {
		case ArgString:
			if token.String == "" {
				continue
			}
			if val, err = strconv.ParseFloat(token.String, 64); err != nil {
				return newErrorFormulaArg(formulaErrorVALUE, err.Error())
			}
		case ArgNumber:
			val = token.Number
		}
		nums = append(nums, val)
	}
	if nums[0] < 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "LCM only accepts positive arguments")
	}
	if len(nums) == 1 {
		return newNumberFormulaArg(nums[0])
	}
	cm := nums[0]
	for i := 1; i < len(nums); i++ {
		if nums[i] < 0 {
			return newErrorFormulaArg(formulaErrorVALUE, "LCM only accepts positive arguments")
		}
		cm = lcm(cm, nums[i])
	}
	return newNumberFormulaArg(cm)
}

// LN function calculates the natural logarithm of a given number. The syntax
// of the function is:
//
//	LN(number)
func (fn *formulaFuncs) LN(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "LN requires 1 numeric argument")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	return newNumberFormulaArg(math.Log(number.Number))
}

// LOG function calculates the logarithm of a given number, to a supplied
// base. The syntax of the function is:
//
//	LOG(number,[base])
func (fn *formulaFuncs) LOG(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "LOG requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "LOG allows at most 2 arguments")
	}
	base := 10.0
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	if argsList.Len() > 1 {
		b := argsList.Back().Value.(formulaArg).ToNumber()
		if b.Type == ArgError {
			return b
		}
		base = b.Number
	}
	if number.Number == 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorDIV)
	}
	if base == 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorDIV)
	}
	if base == 1 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	return newNumberFormulaArg(math.Log(number.Number) / math.Log(base))
}

// LOG10 function calculates the base 10 logarithm of a given number. The
// syntax of the function is:
//
//	LOG10(number)
func (fn *formulaFuncs) LOG10(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "LOG10 requires 1 numeric argument")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	return newNumberFormulaArg(math.Log10(number.Number))
}

// minor function implement a minor of a matrix A is the determinant of some
// smaller square matrix.
func minor(sqMtx [][]float64, idx int) [][]float64 {
	var ret [][]float64
	for i := range sqMtx {
		if i == 0 {
			continue
		}
		var row []float64
		for j := range sqMtx {
			if j == idx {
				continue
			}
			row = append(row, sqMtx[i][j])
		}
		ret = append(ret, row)
	}
	return ret
}

// det determinant of the 2x2 matrix.
func det(sqMtx [][]float64) float64 {
	if len(sqMtx) == 2 {
		m00 := sqMtx[0][0]
		m01 := sqMtx[0][1]
		m10 := sqMtx[1][0]
		m11 := sqMtx[1][1]
		return m00*m11 - m10*m01
	}
	var res, sgn float64 = 0, 1
	for j := range sqMtx {
		res += sgn * sqMtx[0][j] * det(minor(sqMtx, j))
		sgn *= -1
	}
	return res
}

// newNumberMatrix converts a formula arguments matrix to a number matrix.
func newNumberMatrix(arg formulaArg, phalanx bool) (numMtx [][]float64, ele formulaArg) {
	rows := len(arg.Matrix)
	for r, row := range arg.Matrix {
		if phalanx && len(row) != rows {
			ele = newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
			return
		}
		numMtx = append(numMtx, make([]float64, len(row)))
		for c, cell := range row {
			if cell.Type != ArgNumber {
				ele = newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
				return
			}
			numMtx[r][c] = cell.Number
		}
	}
	return
}

// newFormulaArgMatrix converts the number formula arguments matrix to a
// formula arguments matrix.
func newFormulaArgMatrix(numMtx [][]float64) (arg [][]formulaArg) {
	for r, row := range numMtx {
		arg = append(arg, make([]formulaArg, len(row)))
		for c, cell := range row {
			arg[r][c] = newNumberFormulaArg(cell)
		}
	}
	return
}

// MDETERM calculates the determinant of a square matrix. The
// syntax of the function is:
//
//	MDETERM(array)
func (fn *formulaFuncs) MDETERM(argsList *list.List) (result formulaArg) {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "MDETERM requires 1 argument")
	}
	numMtx, errArg := newNumberMatrix(argsList.Front().Value.(formulaArg), true)
	if errArg.Type == ArgError {
		return errArg
	}
	return newNumberFormulaArg(det(numMtx))
}

// cofactorMatrix returns the matrix A of cofactors.
func cofactorMatrix(i, j int, A [][]float64) float64 {
	N, sign := len(A), -1.0
	if (i+j)%2 == 0 {
		sign = 1
	}
	var B [][]float64
	B = append(B, A...)
	for m := 0; m < N; m++ {
		for n := j + 1; n < N; n++ {
			B[m][n-1] = B[m][n]
		}
		B[m] = B[m][:len(B[m])-1]
	}
	for k := i + 1; k < N; k++ {
		B[k-1] = B[k]
	}
	B = B[:len(B)-1]
	return sign * det(B)
}

// adjugateMatrix returns transpose of the cofactor matrix A with Cramer's
// rule.
func adjugateMatrix(A [][]float64) (adjA [][]float64) {
	N := len(A)
	var B [][]float64
	for i := 0; i < N; i++ {
		adjA = append(adjA, make([]float64, N))
		for j := 0; j < N; j++ {
			for m := 0; m < N; m++ {
				for n := 0; n < N; n++ {
					for x := len(B); x <= m; x++ {
						B = append(B, []float64{})
					}
					for k := len(B[m]); k <= n; k++ {
						B[m] = append(B[m], 0)
					}
					B[m][n] = A[m][n]
				}
			}
			adjA[i][j] = cofactorMatrix(j, i, B)
		}
	}
	return
}

// MINVERSE function calculates the inverse of a square matrix. The syntax of
// the function is:
//
//	MINVERSE(array)
func (fn *formulaFuncs) MINVERSE(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "MINVERSE requires 1 argument")
	}
	numMtx, errArg := newNumberMatrix(argsList.Front().Value.(formulaArg), true)
	if errArg.Type == ArgError {
		return errArg
	}
	if detM := det(numMtx); detM != 0 {
		datM, invertM := 1/detM, adjugateMatrix(numMtx)
		for i := 0; i < len(invertM); i++ {
			for j := 0; j < len(invertM[i]); j++ {
				invertM[i][j] *= datM
			}
		}
		return newMatrixFormulaArg(newFormulaArgMatrix(invertM))
	}
	return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
}

// MMULT function calculates the matrix product of two arrays
// (representing matrices). The syntax of the function is:
//
//	MMULT(array1,array2)
func (fn *formulaFuncs) MMULT(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "MMULT requires 2 argument")
	}
	arr1 := argsList.Front().Value.(formulaArg)
	arr2 := argsList.Back().Value.(formulaArg)
	if arr1.Type == ArgNumber && arr2.Type == ArgNumber {
		return newNumberFormulaArg(arr1.Number * arr2.Number)
	}
	numMtx1, errArg1 := newNumberMatrix(arr1, false)
	if errArg1.Type == ArgError {
		return errArg1
	}
	numMtx2, errArg2 := newNumberMatrix(arr2, false)
	if errArg2.Type == ArgError {
		return errArg2
	}
	array2Rows, array2Cols := len(numMtx2), len(numMtx2[0])
	if len(numMtx1[0]) != array2Rows {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	var numMtx [][]float64
	var row1, row []float64
	var sum float64
	for i := 0; i < len(numMtx1); i++ {
		numMtx = append(numMtx, []float64{})
		row = []float64{}
		row1 = numMtx1[i]
		for j := 0; j < array2Cols; j++ {
			sum = 0
			for k := 0; k < array2Rows; k++ {
				sum += row1[k] * numMtx2[k][j]
			}
			for l := len(row); l <= j; l++ {
				row = append(row, 0)
			}
			row[j] = sum
			numMtx[i] = row
		}
	}
	return newMatrixFormulaArg(newFormulaArgMatrix(numMtx))
}

// MOD function returns the remainder of a division between two supplied
// numbers. The syntax of the function is:
//
//	MOD(number,divisor)
func (fn *formulaFuncs) MOD(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "MOD requires 2 numeric arguments")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	divisor := argsList.Back().Value.(formulaArg).ToNumber()
	if divisor.Type == ArgError {
		return divisor
	}
	if divisor.Number == 0 {
		return newErrorFormulaArg(formulaErrorDIV, "MOD divide by zero")
	}
	trunc, rem := math.Modf(number.Number / divisor.Number)
	if rem < 0 {
		trunc--
	}
	return newNumberFormulaArg(number.Number - divisor.Number*trunc)
}

// MROUND function rounds a supplied number up or down to the nearest multiple
// of a given number. The syntax of the function is:
//
//	MROUND(number,multiple)
func (fn *formulaFuncs) MROUND(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "MROUND requires 2 numeric arguments")
	}
	n := argsList.Front().Value.(formulaArg).ToNumber()
	if n.Type == ArgError {
		return n
	}
	multiple := argsList.Back().Value.(formulaArg).ToNumber()
	if multiple.Type == ArgError {
		return multiple
	}
	if multiple.Number == 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if multiple.Number < 0 && n.Number > 0 ||
		multiple.Number > 0 && n.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	number, res := math.Modf(n.Number / multiple.Number)
	if math.Trunc(res+0.5) > 0 {
		number++
	}
	return newNumberFormulaArg(number * multiple.Number)
}

// MULTINOMIAL function calculates the ratio of the factorial of a sum of
// supplied values to the product of factorials of those values. The syntax of
// the function is:
//
//	MULTINOMIAL(number1,[number2],...)
func (fn *formulaFuncs) MULTINOMIAL(argsList *list.List) formulaArg {
	val, num, denom := 0.0, 0.0, 1.0
	var err error
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		token := arg.Value.(formulaArg)
		switch token.Type {
		case ArgString:
			if token.String == "" {
				continue
			}
			if val, err = strconv.ParseFloat(token.String, 64); err != nil {
				return newErrorFormulaArg(formulaErrorVALUE, err.Error())
			}
		case ArgNumber:
			val = token.Number
		}
		num += val
		denom *= fact(val)
	}
	return newNumberFormulaArg(fact(num) / denom)
}

// MUNIT function returns the unit matrix for a specified dimension. The
// syntax of the function is:
//
//	MUNIT(dimension)
func (fn *formulaFuncs) MUNIT(argsList *list.List) (result formulaArg) {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "MUNIT requires 1 numeric argument")
	}
	dimension := argsList.Back().Value.(formulaArg).ToNumber()
	if dimension.Type == ArgError || dimension.Number < 0 {
		return newErrorFormulaArg(formulaErrorVALUE, dimension.Error)
	}
	matrix := make([][]formulaArg, 0, int(dimension.Number))
	for i := 0; i < int(dimension.Number); i++ {
		row := make([]formulaArg, int(dimension.Number))
		for j := 0; j < int(dimension.Number); j++ {
			if i == j {
				row[j] = newNumberFormulaArg(1.0)
			} else {
				row[j] = newNumberFormulaArg(0.0)
			}
		}
		matrix = append(matrix, row)
	}
	return newMatrixFormulaArg(matrix)
}

// ODD function ounds a supplied number away from zero (i.e. rounds a positive
// number up and a negative number down), to the next odd number. The syntax
// of the function is:
//
//	ODD(number)
func (fn *formulaFuncs) ODD(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ODD requires 1 numeric argument")
	}
	number := argsList.Back().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	if number.Number == 0 {
		return newNumberFormulaArg(1)
	}
	sign := math.Signbit(number.Number)
	m, frac := math.Modf((number.Number - 1) / 2)
	val := m*2 + 1
	if frac != 0 {
		if !sign {
			val += 2
		} else {
			val -= 2
		}
	}
	return newNumberFormulaArg(val)
}

// PI function returns the value of the mathematical constant π (pi), accurate
// to 15 digits (14 decimal places). The syntax of the function is:
//
//	PI()
func (fn *formulaFuncs) PI(argsList *list.List) formulaArg {
	if argsList.Len() != 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "PI accepts no arguments")
	}
	return newNumberFormulaArg(math.Pi)
}

// POWER function calculates a given number, raised to a supplied power.
// The syntax of the function is:
//
//	POWER(number,power)
func (fn *formulaFuncs) POWER(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "POWER requires 2 numeric arguments")
	}
	x := argsList.Front().Value.(formulaArg).ToNumber()
	if x.Type == ArgError {
		return x
	}
	y := argsList.Back().Value.(formulaArg).ToNumber()
	if y.Type == ArgError {
		return y
	}
	if x.Number == 0 && y.Number == 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	if x.Number == 0 && y.Number < 0 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	return newNumberFormulaArg(math.Pow(x.Number, y.Number))
}

// PRODUCT function returns the product (multiplication) of a supplied set of
// numerical values. The syntax of the function is:
//
//	PRODUCT(number1,[number2],...)
func (fn *formulaFuncs) PRODUCT(argsList *list.List) formulaArg {
	product := 1.0
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		token := arg.Value.(formulaArg)
		switch token.Type {
		case ArgString:
			num := token.ToNumber()
			if num.Type != ArgNumber {
				return num
			}
			product = product * num.Number
		case ArgNumber:
			product = product * token.Number
		case ArgMatrix:
			for _, row := range token.Matrix {
				for _, cell := range row {
					if cell.Type == ArgNumber {
						product *= cell.Number
					}
				}
			}
		}
	}
	return newNumberFormulaArg(product)
}

// QUOTIENT function returns the integer portion of a division between two
// supplied numbers. The syntax of the function is:
//
//	QUOTIENT(numerator,denominator)
func (fn *formulaFuncs) QUOTIENT(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "QUOTIENT requires 2 numeric arguments")
	}
	x := argsList.Front().Value.(formulaArg).ToNumber()
	if x.Type == ArgError {
		return x
	}
	y := argsList.Back().Value.(formulaArg).ToNumber()
	if y.Type == ArgError {
		return y
	}
	if y.Number == 0 {
		return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
	}
	return newNumberFormulaArg(math.Trunc(x.Number / y.Number))
}

// RADIANS function converts radians into degrees. The syntax of the function is:
//
//	RADIANS(angle)
func (fn *formulaFuncs) RADIANS(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "RADIANS requires 1 numeric argument")
	}
	angle := argsList.Front().Value.(formulaArg).ToNumber()
	if angle.Type == ArgError {
		return angle
	}
	return newNumberFormulaArg(math.Pi / 180.0 * angle.Number)
}

// RAND function generates a random real number between 0 and 1. The syntax of
// the function is:
//
//	RAND()
func (fn *formulaFuncs) RAND(argsList *list.List) formulaArg {
	if argsList.Len() != 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "RAND accepts no arguments")
	}
	return newNumberFormulaArg(rand.New(rand.NewSource(time.Now().UnixNano())).Float64())
}

// RANDBETWEEN function generates a random integer between two supplied
// integers. The syntax of the function is:
//
//	RANDBETWEEN(bottom,top)
func (fn *formulaFuncs) RANDBETWEEN(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "RANDBETWEEN requires 2 numeric arguments")
	}
	bottom := argsList.Front().Value.(formulaArg).ToNumber()
	if bottom.Type == ArgError {
		return bottom
	}
	top := argsList.Back().Value.(formulaArg).ToNumber()
	if top.Type == ArgError {
		return top
	}
	if top.Number < bottom.Number {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	num := rand.New(rand.NewSource(time.Now().UnixNano())).Int63n(int64(top.Number - bottom.Number + 1))
	return newNumberFormulaArg(float64(num + int64(bottom.Number)))
}

// romanNumerals defined a numeral system that originated in ancient Rome and
// remained the usual way of writing numbers throughout Europe well into the
// Late Middle Ages.
type romanNumerals struct {
	n float64
	s string
}

var romanTable = [][]romanNumerals{
	{
		{1000, "M"},
		{900, "CM"},
		{500, "D"},
		{400, "CD"},
		{100, "C"},
		{90, "XC"},
		{50, "L"},
		{40, "XL"},
		{10, "X"},
		{9, "IX"},
		{5, "V"},
		{4, "IV"},
		{1, "I"},
	},
	{
		{1000, "M"},
		{950, "LM"},
		{900, "CM"},
		{500, "D"},
		{450, "LD"},
		{400, "CD"},
		{100, "C"},
		{95, "VC"},
		{90, "XC"},
		{50, "L"},
		{45, "VL"},
		{40, "XL"},
		{10, "X"},
		{9, "IX"},
		{5, "V"},
		{4, "IV"},
		{1, "I"},
	},
	{
		{1000, "M"},
		{990, "XM"},
		{950, "LM"},
		{900, "CM"},
		{500, "D"},
		{490, "XD"},
		{450, "LD"},
		{400, "CD"},
		{100, "C"},
		{99, "IC"},
		{90, "XC"},
		{50, "L"},
		{45, "VL"},
		{40, "XL"},
		{10, "X"},
		{9, "IX"},
		{5, "V"},
		{4, "IV"},
		{1, "I"},
	},
	{
		{1000, "M"},
		{995, "VM"},
		{990, "XM"},
		{950, "LM"},
		{900, "CM"},
		{500, "D"},
		{495, "VD"},
		{490, "XD"},
		{450, "LD"},
		{400, "CD"},
		{100, "C"},
		{99, "IC"},
		{90, "XC"},
		{50, "L"},
		{45, "VL"},
		{40, "XL"},
		{10, "X"},
		{9, "IX"},
		{5, "V"},
		{4, "IV"},
		{1, "I"},
	},
	{
		{1000, "M"},
		{999, "IM"},
		{995, "VM"},
		{990, "XM"},
		{950, "LM"},
		{900, "CM"},
		{500, "D"},
		{499, "ID"},
		{495, "VD"},
		{490, "XD"},
		{450, "LD"},
		{400, "CD"},
		{100, "C"},
		{99, "IC"},
		{90, "XC"},
		{50, "L"},
		{45, "VL"},
		{40, "XL"},
		{10, "X"},
		{9, "IX"},
		{5, "V"},
		{4, "IV"},
		{1, "I"},
	},
}

// ROMAN function converts an arabic number to Roman. I.e. for a supplied
// integer, the function returns a text string depicting the roman numeral
// form of the number. The syntax of the function is:
//
//	ROMAN(number,[form])
func (fn *formulaFuncs) ROMAN(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "ROMAN requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "ROMAN allows at most 2 arguments")
	}
	var form int
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	if argsList.Len() > 1 {
		f := argsList.Back().Value.(formulaArg).ToNumber()
		if f.Type == ArgError {
			return f
		}
		form = int(f.Number)
		if form < 0 {
			form = 0
		} else if form > 4 {
			form = 4
		}
	}
	decimalTable := romanTable[0]
	switch form {
	case 1:
		decimalTable = romanTable[1]
	case 2:
		decimalTable = romanTable[2]
	case 3:
		decimalTable = romanTable[3]
	case 4:
		decimalTable = romanTable[4]
	}
	val := math.Trunc(number.Number)
	buf := bytes.Buffer{}
	for _, r := range decimalTable {
		for val >= r.n {
			buf.WriteString(r.s)
			val -= r.n
		}
	}
	return newStringFormulaArg(buf.String())
}

type roundMode byte

const (
	closest roundMode = iota
	down
	up
)

// round rounds a supplied number up or down.
func (fn *formulaFuncs) round(number, digits float64, mode roundMode) float64 {
	var significance float64
	if digits > 0 {
		significance = math.Pow(1/10.0, digits)
	} else {
		significance = math.Pow(10.0, -digits)
	}
	val, res := math.Modf(number / significance)
	switch mode {
	case closest:
		const eps = 0.499999999
		if res >= eps {
			val++
		} else if res <= -eps {
			val--
		}
	case down:
	case up:
		if res > 0 {
			val++
		} else if res < 0 {
			val--
		}
	}
	return val * significance
}

// ROUND function rounds a supplied number up or down, to a specified number
// of decimal places. The syntax of the function is:
//
//	ROUND(number,num_digits)
func (fn *formulaFuncs) ROUND(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "ROUND requires 2 numeric arguments")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	digits := argsList.Back().Value.(formulaArg).ToNumber()
	if digits.Type == ArgError {
		return digits
	}
	return newNumberFormulaArg(fn.round(number.Number, digits.Number, closest))
}

// ROUNDDOWN function rounds a supplied number down towards zero, to a
// specified number of decimal places. The syntax of the function is:
//
//	ROUNDDOWN(number,num_digits)
func (fn *formulaFuncs) ROUNDDOWN(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "ROUNDDOWN requires 2 numeric arguments")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	digits := argsList.Back().Value.(formulaArg).ToNumber()
	if digits.Type == ArgError {
		return digits
	}
	return newNumberFormulaArg(fn.round(number.Number, digits.Number, down))
}

// ROUNDUP function rounds a supplied number up, away from zero, to a
// specified number of decimal places. The syntax of the function is:
//
//	ROUNDUP(number,num_digits)
func (fn *formulaFuncs) ROUNDUP(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "ROUNDUP requires 2 numeric arguments")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	digits := argsList.Back().Value.(formulaArg).ToNumber()
	if digits.Type == ArgError {
		return digits
	}
	return newNumberFormulaArg(fn.round(number.Number, digits.Number, up))
}

// SEC function calculates the secant of a given angle. The syntax of the
// function is:
//
//	SEC(number)
func (fn *formulaFuncs) SEC(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "SEC requires 1 numeric argument")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	return newNumberFormulaArg(math.Cos(number.Number))
}

// SECH function calculates the hyperbolic secant (sech) of a supplied angle.
// The syntax of the function is:
//
//	SECH(number)
func (fn *formulaFuncs) SECH(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "SECH requires 1 numeric argument")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	return newNumberFormulaArg(1 / math.Cosh(number.Number))
}

// SERIESSUM function returns the sum of a power series. The syntax of the
// function is:
//
//	SERIESSUM(x,n,m,coefficients)
func (fn *formulaFuncs) SERIESSUM(argsList *list.List) formulaArg {
	if argsList.Len() != 4 {
		return newErrorFormulaArg(formulaErrorVALUE, "SERIESSUM requires 4 arguments")
	}
	var x, n, m formulaArg
	if x = argsList.Front().Value.(formulaArg).ToNumber(); x.Type != ArgNumber {
		return x
	}
	if n = argsList.Front().Next().Value.(formulaArg).ToNumber(); n.Type != ArgNumber {
		return n
	}
	if m = argsList.Front().Next().Next().Value.(formulaArg).ToNumber(); m.Type != ArgNumber {
		return m
	}
	var result, i float64
	for _, coefficient := range argsList.Back().Value.(formulaArg).ToList() {
		if coefficient.Value() == "" {
			continue
		}
		num := coefficient.ToNumber()
		if num.Type != ArgNumber {
			return num
		}
		result += num.Number * math.Pow(x.Number, n.Number+(m.Number*i))
		i++
	}
	return newNumberFormulaArg(result)
}

// SIGN function returns the arithmetic sign (+1, -1 or 0) of a supplied
// number. I.e. if the number is positive, the Sign function returns +1, if
// the number is negative, the function returns -1 and if the number is 0
// (zero), the function returns 0. The syntax of the function is:
//
//	SIGN(number)
func (fn *formulaFuncs) SIGN(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "SIGN requires 1 numeric argument")
	}
	val := argsList.Front().Value.(formulaArg).ToNumber()
	if val.Type == ArgError {
		return val
	}
	if val.Number < 0 {
		return newNumberFormulaArg(-1)
	}
	if val.Number > 0 {
		return newNumberFormulaArg(1)
	}
	return newNumberFormulaArg(0)
}

// SIN function calculates the sine of a given angle. The syntax of the
// function is:
//
//	SIN(number)
func (fn *formulaFuncs) SIN(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "SIN requires 1 numeric argument")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	return newNumberFormulaArg(math.Sin(number.Number))
}

// SINH function calculates the hyperbolic sine (sinh) of a supplied number.
// The syntax of the function is:
//
//	SINH(number)
func (fn *formulaFuncs) SINH(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "SINH requires 1 numeric argument")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	return newNumberFormulaArg(math.Sinh(number.Number))
}

// SQRT function calculates the positive square root of a supplied number. The
// syntax of the function is:
//
//	SQRT(number)
func (fn *formulaFuncs) SQRT(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "SQRT requires 1 numeric argument")
	}
	value := argsList.Front().Value.(formulaArg).ToNumber()
	if value.Type == ArgError {
		return value
	}
	if value.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(math.Sqrt(value.Number))
}

// SQRTPI function returns the square root of a supplied number multiplied by
// the mathematical constant, π. The syntax of the function is:
//
//	SQRTPI(number)
func (fn *formulaFuncs) SQRTPI(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "SQRTPI requires 1 numeric argument")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	return newNumberFormulaArg(math.Sqrt(number.Number * math.Pi))
}

// STDEV function calculates the sample standard deviation of a supplied set
// of values. The syntax of the function is:
//
//	STDEV(number1,[number2],...)
func (fn *formulaFuncs) STDEV(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "STDEV requires at least 1 argument")
	}
	return fn.stdev(false, argsList)
}

// STDEVdotS function calculates the sample standard deviation of a supplied
// set of values. The syntax of the function is:
//
//	STDEV.S(number1,[number2],...)
func (fn *formulaFuncs) STDEVdotS(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "STDEV.S requires at least 1 argument")
	}
	return fn.stdev(false, argsList)
}

// STDEVA function estimates standard deviation based on a sample. The
// standard deviation is a measure of how widely values are dispersed from
// the average value (the mean). The syntax of the function is:
//
//	STDEVA(number1,[number2],...)
func (fn *formulaFuncs) STDEVA(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "STDEVA requires at least 1 argument")
	}
	return fn.stdev(true, argsList)
}

// calcStdevPow is part of the implementation stdev.
func calcStdevPow(result, count float64, n, m formulaArg) (float64, float64) {
	if result == -1 {
		result = math.Pow(n.Number-m.Number, 2)
	} else {
		result += math.Pow(n.Number-m.Number, 2)
	}
	count++
	return result, count
}

// calcStdev is part of the implementation stdev.
func calcStdev(stdeva bool, result, count float64, mean, token formulaArg) (float64, float64) {
	for _, row := range token.ToList() {
		if row.Type == ArgNumber || row.Type == ArgString {
			if !stdeva && (row.Value() == "TRUE" || row.Value() == "FALSE") {
				continue
			} else if stdeva && (row.Value() == "TRUE" || row.Value() == "FALSE") {
				num := row.ToBool()
				if num.Type == ArgNumber {
					result, count = calcStdevPow(result, count, num, mean)
					continue
				}
			} else {
				num := row.ToNumber()
				if num.Type == ArgNumber {
					result, count = calcStdevPow(result, count, num, mean)
				}
			}
		}
	}
	return result, count
}

// stdev is an implementation of the formula functions STDEV and STDEVA.
func (fn *formulaFuncs) stdev(stdeva bool, argsList *list.List) formulaArg {
	count, result := -1.0, -1.0
	var mean formulaArg
	if stdeva {
		mean = fn.AVERAGEA(argsList)
	} else {
		mean = fn.AVERAGE(argsList)
	}
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		token := arg.Value.(formulaArg)
		switch token.Type {
		case ArgString, ArgNumber:
			if !stdeva && (token.Value() == "TRUE" || token.Value() == "FALSE") {
				continue
			} else if stdeva && (token.Value() == "TRUE" || token.Value() == "FALSE") {
				num := token.ToBool()
				if num.Type == ArgNumber {
					result, count = calcStdevPow(result, count, num, mean)
					continue
				}
			} else {
				num := token.ToNumber()
				if num.Type == ArgNumber {
					result, count = calcStdevPow(result, count, num, mean)
				}
			}
		case ArgList, ArgMatrix:
			result, count = calcStdev(stdeva, result, count, mean, token)
		}
	}
	if count > 0 && result >= 0 {
		return newNumberFormulaArg(math.Sqrt(result / count))
	}
	return newErrorFormulaArg(formulaErrorDIV, formulaErrorDIV)
}

// POISSONdotDIST function calculates the Poisson Probability Mass Function or
// the Cumulative Poisson Probability Function for a supplied set of
// parameters. The syntax of the function is:
//
//	POISSON.DIST(x,mean,cumulative)
func (fn *formulaFuncs) POISSONdotDIST(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "POISSON.DIST requires 3 arguments")
	}
	return fn.POISSON(argsList)
}

// POISSON function calculates the Poisson Probability Mass Function or the
// Cumulative Poisson Probability Function for a supplied set of parameters.
// The syntax of the function is:
//
//	POISSON(x,mean,cumulative)
func (fn *formulaFuncs) POISSON(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "POISSON requires 3 arguments")
	}
	var x, mean, cumulative formulaArg
	if x = argsList.Front().Value.(formulaArg).ToNumber(); x.Type != ArgNumber {
		return x
	}
	if mean = argsList.Front().Next().Value.(formulaArg).ToNumber(); mean.Type != ArgNumber {
		return mean
	}
	if cumulative = argsList.Back().Value.(formulaArg).ToBool(); cumulative.Type == ArgError {
		return cumulative
	}
	if x.Number < 0 || mean.Number <= 0 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	if cumulative.Number == 1 {
		summer := 0.0
		floor := math.Floor(x.Number)
		for i := 0; i <= int(floor); i++ {
			summer += math.Pow(mean.Number, float64(i)) / fact(float64(i))
		}
		return newNumberFormulaArg(math.Exp(0-mean.Number) * summer)
	}
	return newNumberFormulaArg(math.Exp(0-mean.Number) * math.Pow(mean.Number, x.Number) / fact(x.Number))
}

// prepareProbArgs checking and prepare arguments for the formula function
// PROB.
func prepareProbArgs(argsList *list.List) []formulaArg {
	if argsList.Len() < 3 {
		return []formulaArg{newErrorFormulaArg(formulaErrorVALUE, "PROB requires at least 3 arguments")}
	}
	if argsList.Len() > 4 {
		return []formulaArg{newErrorFormulaArg(formulaErrorVALUE, "PROB requires at most 4 arguments")}
	}
	var lower, upper formulaArg
	xRange := argsList.Front().Value.(formulaArg)
	probRange := argsList.Front().Next().Value.(formulaArg)
	if lower = argsList.Front().Next().Next().Value.(formulaArg); lower.Type != ArgNumber {
		return []formulaArg{newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)}
	}
	upper = lower
	if argsList.Len() == 4 {
		if upper = argsList.Back().Value.(formulaArg); upper.Type != ArgNumber {
			return []formulaArg{newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)}
		}
	}
	nR1, nR2 := len(xRange.Matrix), len(probRange.Matrix)
	if nR1 == 0 || nR2 == 0 {
		return []formulaArg{newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)}
	}
	if nR1 != nR2 {
		return []formulaArg{newErrorFormulaArg(formulaErrorNA, formulaErrorNA)}
	}
	nC1, nC2 := len(xRange.Matrix[0]), len(probRange.Matrix[0])
	if nC1 != nC2 {
		return []formulaArg{newErrorFormulaArg(formulaErrorNA, formulaErrorNA)}
	}
	return []formulaArg{xRange, probRange, lower, upper}
}

// PROB function calculates the probability associated with a given range. The
// syntax of the function is:
//
//	PROB(x_range,prob_range,lower_limit,[upper_limit])
func (fn *formulaFuncs) PROB(argsList *list.List) formulaArg {
	args := prepareProbArgs(argsList)
	if len(args) == 1 {
		return args[0]
	}
	xRange, probRange, lower, upper := args[0], args[1], args[2], args[3]
	var sum, res, fP, fW float64
	var stop bool
	for r := 0; r < len(xRange.Matrix) && !stop; r++ {
		for c := 0; c < len(xRange.Matrix[0]) && !stop; c++ {
			p := probRange.Matrix[r][c]
			x := xRange.Matrix[r][c]
			if p.Type == ArgNumber && x.Type == ArgNumber {
				if fP, fW = p.Number, x.Number; fP < 0 || fP > 1 {
					stop = true
					continue
				}
				if sum += fP; fW >= lower.Number && fW <= upper.Number {
					res += fP
				}
				continue
			}
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
	}
	if stop || math.Abs(sum-1) > 1.0e-7 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newNumberFormulaArg(res)
}

// SUBTOTAL function performs a specified calculation (e.g. the sum, product,
// average, etc.) for a supplied set of values. The syntax of the function is:
//
//	SUBTOTAL(function_num,ref1,[ref2],...)
func (fn *formulaFuncs) SUBTOTAL(argsList *list.List) formulaArg {
	if argsList.Len() < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "SUBTOTAL requires at least 2 arguments")
	}
	var fnNum formulaArg
	if fnNum = argsList.Front().Value.(formulaArg).ToNumber(); fnNum.Type != ArgNumber {
		return fnNum
	}
	subFn, ok := map[int]func(argsList *list.List) formulaArg{
		1: fn.AVERAGE, 101: fn.AVERAGE,
		2: fn.COUNT, 102: fn.COUNT,
		3: fn.COUNTA, 103: fn.COUNTA,
		4: fn.MAX, 104: fn.MAX,
		5: fn.MIN, 105: fn.MIN,
		6: fn.PRODUCT, 106: fn.PRODUCT,
		7: fn.STDEV, 107: fn.STDEV,
		8: fn.STDEVP, 108: fn.STDEVP,
		9: fn.SUM, 109: fn.SUM,
		10: fn.VAR, 110: fn.VAR,
		11: fn.VARP, 111: fn.VARP,
	}[int(fnNum.Number)]
	if !ok {
		return newErrorFormulaArg(formulaErrorVALUE, "SUBTOTAL has invalid function_num")
	}
	subArgList := list.New().Init()
	for arg := argsList.Front().Next(); arg != nil; arg = arg.Next() {
		subArgList.PushBack(arg.Value.(formulaArg))
	}
	return subFn(subArgList)
}

// SUM function adds together a supplied set of numbers and returns the sum of
// these values. The syntax of the function is:
//
//	SUM(number1,[number2],...)
func (fn *formulaFuncs) SUM(argsList *list.List) formulaArg {
	var sum float64
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		token := arg.Value.(formulaArg)
		switch token.Type {
		case ArgError:
			return token
		case ArgString:
			if num := token.ToNumber(); num.Type == ArgNumber {
				sum += num.Number
			}
		case ArgNumber:
			sum += token.Number
		case ArgMatrix:
			for _, row := range token.Matrix {
				for _, value := range row {
					if num := value.ToNumber(); num.Type == ArgNumber {
						sum += num.Number
					}
				}
			}
		}
	}
	return newNumberFormulaArg(sum)
}

// SUMIF function finds the values in a supplied array, that satisfy a given
// criteria, and returns the sum of the corresponding values in a second
// supplied array. The syntax of the function is:
//
//	SUMIF(range,criteria,[sum_range])
func (fn *formulaFuncs) SUMIF(argsList *list.List) formulaArg {
	if argsList.Len() < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "SUMIF requires at least 2 arguments")
	}
	criteria := formulaCriteriaParser(argsList.Front().Next().Value.(formulaArg))
	rangeMtx := argsList.Front().Value.(formulaArg).Matrix
	var sumRange [][]formulaArg
	if argsList.Len() == 3 {
		sumRange = argsList.Back().Value.(formulaArg).Matrix
	}
	var sum float64
	var arg formulaArg
	for rowIdx, row := range rangeMtx {
		for colIdx, cell := range row {
			arg = cell
			if arg.Type == ArgEmpty {
				continue
			}
			if ok, _ := formulaCriteriaEval(arg, criteria); ok {
				if argsList.Len() == 3 {
					if len(sumRange) > rowIdx && len(sumRange[rowIdx]) > colIdx {
						arg = sumRange[rowIdx][colIdx]
					}
				}
				if arg.Type == ArgNumber {
					sum += arg.Number
				}
			}
		}
	}
	return newNumberFormulaArg(sum)
}

// SUMIFS function finds values in one or more supplied arrays, that satisfy a
// set of criteria, and returns the sum of the corresponding values in a
// further supplied array. The syntax of the function is:
//
//	SUMIFS(sum_range,criteria_range1,criteria1,[criteria_range2,criteria2],...)
func (fn *formulaFuncs) SUMIFS(argsList *list.List) formulaArg {
	if argsList.Len() < 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "SUMIFS requires at least 3 arguments")
	}
	if argsList.Len()%2 != 1 {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	var args []formulaArg
	sum, sumRange := 0.0, argsList.Front().Value.(formulaArg).Matrix
	for arg := argsList.Front().Next(); arg != nil; arg = arg.Next() {
		args = append(args, arg.Value.(formulaArg))
	}
	for _, ref := range formulaIfsMatch(args) {
		if ref.Row >= len(sumRange) || ref.Col >= len(sumRange[ref.Row]) {
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
		if num := sumRange[ref.Row][ref.Col].ToNumber(); num.Type == ArgNumber {
			sum += num.Number
		}
	}
	return newNumberFormulaArg(sum)
}

// sumproduct is an implementation of the formula function SUMPRODUCT.
func (fn *formulaFuncs) sumproduct(argsList *list.List) formulaArg {
	var (
		argType ArgType
		n       int
		res     []float64
		sum     float64
	)
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		token := arg.Value.(formulaArg)
		if argType == ArgUnknown {
			argType = token.Type
		}
		if token.Type != argType {
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
		switch token.Type {
		case ArgString, ArgNumber:
			if num := token.ToNumber(); num.Type == ArgNumber {
				sum = fn.PRODUCT(argsList).Number
				continue
			}
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		case ArgMatrix:
			args := token.ToList()
			if res == nil {
				n = len(args)
				res = make([]float64, n)
				for i := range res {
					res[i] = 1.0
				}
			}
			if len(args) != n {
				return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
			}
			for i, value := range args {
				num := value.ToNumber()
				if num.Type != ArgNumber && value.Value() != "" {
					return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
				}
				res[i] = res[i] * num.Number
			}
		}
	}
	for _, r := range res {
		sum += r
	}
	return newNumberFormulaArg(sum)
}

// SUMPRODUCT function returns the sum of the products of the corresponding
// values in a set of supplied arrays. The syntax of the function is:
//
//	SUMPRODUCT(array1,[array2],[array3],...)
func (fn *formulaFuncs) SUMPRODUCT(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "SUMPRODUCT requires at least 1 argument")
	}
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		if token := arg.Value.(formulaArg); token.Type == ArgError {
			return token
		}
	}
	return fn.sumproduct(argsList)
}

// SUMSQ function returns the sum of squares of a supplied set of values. The
// syntax of the function is:
//
//	SUMSQ(number1,[number2],...)
func (fn *formulaFuncs) SUMSQ(argsList *list.List) formulaArg {
	var val, sq float64
	var err error
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		token := arg.Value.(formulaArg)
		switch token.Type {
		case ArgString:
			if token.String == "" {
				continue
			}
			if val, err = strconv.ParseFloat(token.String, 64); err != nil {
				return newErrorFormulaArg(formulaErrorVALUE, err.Error())
			}
			sq += val * val
		case ArgNumber:
			sq += token.Number * token.Number
		case ArgMatrix:
			for _, row := range token.Matrix {
				for _, value := range row {
					if value.Value() == "" {
						continue
					}
					if val, err = strconv.ParseFloat(value.Value(), 64); err != nil {
						return newErrorFormulaArg(formulaErrorVALUE, err.Error())
					}
					sq += val * val
				}
			}
		}
	}
	return newNumberFormulaArg(sq)
}

// sumx is an implementation of the formula functions SUMX2MY2, SUMX2PY2 and
// SUMXMY2.
func (fn *formulaFuncs) sumx(name string, argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires 2 arguments", name))
	}
	array1 := argsList.Front().Value.(formulaArg)
	array2 := argsList.Back().Value.(formulaArg)
	left, right := array1.ToList(), array2.ToList()
	n := len(left)
	if n != len(right) {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	result := 0.0
	for i := 0; i < n; i++ {
		if lhs, rhs := left[i].ToNumber(), right[i].ToNumber(); lhs.Number != 0 && rhs.Number != 0 {
			switch name {
			case "SUMX2MY2":
				result += lhs.Number*lhs.Number - rhs.Number*rhs.Number
			case "SUMX2PY2":
				result += lhs.Number*lhs.Number + rhs.Number*rhs.Number
			default:
				result += (lhs.Number - rhs.Number) * (lhs.Number - rhs.Number)
			}
		}
	}
	return newNumberFormulaArg(result)
}

// SUMX2MY2 function returns the sum of the differences of squares of two
// supplied sets of values. The syntax of the function is:
//
//	SUMX2MY2(array_x,array_y)
func (fn *formulaFuncs) SUMX2MY2(argsList *list.List) formulaArg {
	return fn.sumx("SUMX2MY2", argsList)
}

// SUMX2PY2 function returns the sum of the sum of squares of two supplied sets
// of values. The syntax of the function is:
//
//	SUMX2PY2(array_x,array_y)
func (fn *formulaFuncs) SUMX2PY2(argsList *list.List) formulaArg {
	return fn.sumx("SUMX2PY2", argsList)
}

// SUMXMY2 function returns the sum of the squares of differences between
// corresponding values in two supplied arrays. The syntax of the function
// is:
//
//	SUMXMY2(array_x,array_y)
func (fn *formulaFuncs) SUMXMY2(argsList *list.List) formulaArg {
	return fn.sumx("SUMXMY2", argsList)
}

// TAN function calculates the tangent of a given angle. The syntax of the
// function is:
//
//	TAN(number)
func (fn *formulaFuncs) TAN(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "TAN requires 1 numeric argument")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	return newNumberFormulaArg(math.Tan(number.Number))
}

// TANH function calculates the hyperbolic tangent (tanh) of a supplied
// number. The syntax of the function is:
//
//	TANH(number)
func (fn *formulaFuncs) TANH(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "TANH requires 1 numeric argument")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	return newNumberFormulaArg(math.Tanh(number.Number))
}

// TRUNC function truncates a supplied number to a specified number of decimal
// places. The syntax of the function is:
//
//	TRUNC(number,[number_digits])
func (fn *formulaFuncs) TRUNC(argsList *list.List) formulaArg {
	if argsList.Len() == 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "TRUNC requires at least 1 argument")
	}
	var digits, adjust, rtrim float64
	var err error
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type == ArgError {
		return number
	}
	if argsList.Len() > 1 {
		d := argsList.Back().Value.(formulaArg).ToNumber()
		if d.Type == ArgError {
			return d
		}
		digits = d.Number
		digits = math.Floor(digits)
	}
	adjust = math.Pow(10, digits)
	x := int((math.Abs(number.Number) - math.Abs(float64(int(number.Number)))) * adjust)
	if x != 0 {
		if rtrim, err = strconv.ParseFloat(strings.TrimRight(strconv.Itoa(x), "0"), 64); err != nil {
			return newErrorFormulaArg(formulaErrorVALUE, err.Error())
		}
	}
	if (digits > 0) && (rtrim < adjust/10) {
		return newNumberFormulaArg(number.Number)
	}
	return newNumberFormulaArg(float64(int(number.Number*adjust)) / adjust)
}

// Statistical Functions

// AVEDEV function calculates the average deviation of a supplied set of
// values. The syntax of the function is:
//
//	AVEDEV(number1,[number2],...)
