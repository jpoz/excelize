// Copyright 2016 - 2025 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.24.0 or later.

package excelize

import (
	"container/list"
	"strings"
)

func (fn *formulaFuncs) ERRORdotTYPE(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ERROR.TYPE requires 1 argument")
	}
	token := argsList.Front().Value.(formulaArg)
	if token.Type == ArgError {
		for i, errType := range []string{
			formulaErrorNULL, formulaErrorDIV, formulaErrorVALUE, formulaErrorREF,
			formulaErrorNAME, formulaErrorNUM, formulaErrorNA,
		} {
			if errType == token.String {
				return newNumberFormulaArg(float64(i) + 1)
			}
		}
	}
	return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
}

// ISBLANK function tests if a specified cell is blank (empty) and if so,
// returns TRUE; Otherwise the function returns FALSE. The syntax of the
// function is:
//
//	ISBLANK(value)
func (fn *formulaFuncs) ISBLANK(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ISBLANK requires 1 argument")
	}
	token := argsList.Front().Value.(formulaArg)
	switch token.Type {
	case ArgUnknown, ArgEmpty:
		return newBoolFormulaArg(true)
	default:
		return newBoolFormulaArg(false)
	}
}

// ISERR function tests if an initial supplied expression (or value) returns
// any Excel Error, except the #N/A error. If so, the function returns the
// logical value TRUE; If the supplied value is not an error or is the #N/A
// error, the ISERR function returns FALSE. The syntax of the function is:
//
//	ISERR(value)
func (fn *formulaFuncs) ISERR(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ISERR requires 1 argument")
	}
	token := argsList.Front().Value.(formulaArg)
	result := false
	if token.Type == ArgError {
		for _, errType := range []string{
			formulaErrorDIV, formulaErrorNAME, formulaErrorNUM,
			formulaErrorVALUE, formulaErrorREF, formulaErrorNULL,
			formulaErrorSPILL, formulaErrorCALC, formulaErrorGETTINGDATA,
		} {
			if errType == token.String {
				result = true
			}
		}
	}
	return newBoolFormulaArg(result)
}

// ISERROR function tests if an initial supplied expression (or value) returns
// an Excel Error, and if so, returns the logical value TRUE; Otherwise the
// function returns FALSE. The syntax of the function is:
//
//	ISERROR(value)
func (fn *formulaFuncs) ISERROR(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ISERROR requires 1 argument")
	}
	token := argsList.Front().Value.(formulaArg)
	result := false
	if token.Type == ArgError {
		for _, errType := range []string{
			formulaErrorDIV, formulaErrorNAME, formulaErrorNA, formulaErrorNUM,
			formulaErrorVALUE, formulaErrorREF, formulaErrorNULL, formulaErrorSPILL,
			formulaErrorCALC, formulaErrorGETTINGDATA,
		} {
			if errType == token.String {
				result = true
			}
		}
	}
	return newBoolFormulaArg(result)
}

// ISEVEN function tests if a supplied number (or numeric expression)
// evaluates to an even number, and if so, returns TRUE; Otherwise, the
// function returns FALSE. The syntax of the function is:
//
//	ISEVEN(value)
func (fn *formulaFuncs) ISEVEN(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ISEVEN requires 1 argument")
	}
	token := argsList.Front().Value.(formulaArg)
	switch token.Type {
	case ArgEmpty:
		return newBoolFormulaArg(true)
	case ArgNumber, ArgString:
		num := token.ToNumber()
		if num.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
		if num.Number == 1 {
			return newBoolFormulaArg(false)
		}
		return newBoolFormulaArg(num.Number == num.Number/2*2)
	default:
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
}

// ISFORMULA function tests if a specified cell contains a formula, and if so,
// returns TRUE; Otherwise, the function returns FALSE. The syntax of the
// function is:
//
//	ISFORMULA(reference)
func (fn *formulaFuncs) ISFORMULA(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ISFORMULA requires 1 argument")
	}
	arg := argsList.Front().Value.(formulaArg)
	if arg.cellRefs != nil && arg.cellRefs.Len() == 1 {
		ref := arg.cellRefs.Front().Value.(cellRef)
		cell, _ := CoordinatesToCellName(ref.Col, ref.Row)
		if formula, _ := fn.f.GetCellFormula(ref.Sheet, cell); len(formula) > 0 {
			return newBoolFormulaArg(true)
		}
	}
	return newBoolFormulaArg(false)
}

// ISLOGICAL function tests if a supplied value (or expression) returns a
// logical value (i.e. evaluates to True or False). If so, the function
// returns TRUE; Otherwise, it returns FALSE. The syntax of the function is:
//
//	ISLOGICAL(value)
func (fn *formulaFuncs) ISLOGICAL(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ISLOGICAL requires 1 argument")
	}
	val := argsList.Front().Value.(formulaArg).Value()
	if strings.EqualFold("TRUE", val) || strings.EqualFold("FALSE", val) {
		return newBoolFormulaArg(true)
	}
	return newBoolFormulaArg(false)
}

// ISNA function tests if an initial supplied expression (or value) returns
// the Excel #N/A Error, and if so, returns TRUE; Otherwise the function
// returns FALSE. The syntax of the function is:
//
//	ISNA(value)
func (fn *formulaFuncs) ISNA(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ISNA requires 1 argument")
	}
	if token := argsList.Front().Value.(formulaArg); token.Type == ArgError && token.String == formulaErrorNA {
		return newBoolFormulaArg(true)
	}
	return newBoolFormulaArg(false)
}

// ISNONTEXT function tests if a supplied value is text. If not, the
// function returns TRUE; If the supplied value is text, the function returns
// FALSE. The syntax of the function is:
//
//	ISNONTEXT(value)
func (fn *formulaFuncs) ISNONTEXT(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ISNONTEXT requires 1 argument")
	}
	if argsList.Front().Value.(formulaArg).Type == ArgString {
		return newBoolFormulaArg(false)
	}
	return newBoolFormulaArg(true)
}

// ISNUMBER function tests if a supplied value is a number. If so,
// the function returns TRUE; Otherwise it returns FALSE. The syntax of the
// function is:
//
//	ISNUMBER(value)
func (fn *formulaFuncs) ISNUMBER(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ISNUMBER requires 1 argument")
	}
	arg := argsList.Front().Value.(formulaArg)
	if arg.Type == ArgMatrix {
		var mtx [][]formulaArg
		for _, row := range arg.Matrix {
			var array []formulaArg
			for _, val := range row {
				if val.Type == ArgNumber {
					array = append(array, newBoolFormulaArg(true))
				}
				array = append(array, newBoolFormulaArg(false))
			}
			mtx = append(mtx, array)
		}
		return newMatrixFormulaArg(mtx)
	}
	if arg.Type == ArgNumber {
		return newBoolFormulaArg(true)
	}
	return newBoolFormulaArg(false)
}

// ISODD function tests if a supplied number (or numeric expression) evaluates
// to an odd number, and if so, returns TRUE; Otherwise, the function returns
// FALSE. The syntax of the function is:
//
//	ISODD(value)
func (fn *formulaFuncs) ISODD(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ISODD requires 1 argument")
	}
	arg := argsList.Front().Value.(formulaArg).ToNumber()
	if arg.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
	}
	if int(arg.Number) != int(arg.Number)/2*2 {
		return newBoolFormulaArg(true)
	}
	return newBoolFormulaArg(false)
}

// ISREF function tests if a supplied value is a reference. If so, the
// function returns TRUE; Otherwise it returns FALSE. The syntax of the
// function is:
//
//	ISREF(value)
func (fn *formulaFuncs) ISREF(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ISREF requires 1 argument")
	}
	arg := argsList.Front().Value.(formulaArg)
	if arg.cellRanges != nil && arg.cellRanges.Len() > 0 || arg.cellRefs != nil && arg.cellRefs.Len() > 0 {
		return newBoolFormulaArg(true)
	}
	return newBoolFormulaArg(false)
}

// ISTEXT function tests if a supplied value is text, and if so, returns TRUE;
// Otherwise, the function returns FALSE. The syntax of the function is:
//
//	ISTEXT(value)
func (fn *formulaFuncs) ISTEXT(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ISTEXT requires 1 argument")
	}
	token := argsList.Front().Value.(formulaArg)
	if token.ToNumber().Type != ArgError {
		return newBoolFormulaArg(false)
	}
	return newBoolFormulaArg(token.Type == ArgString)
}

// N function converts data into a numeric value. The syntax of the function
// is:
//
//	N(value)
func (fn *formulaFuncs) N(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "N requires 1 argument")
	}
	token, num := argsList.Front().Value.(formulaArg), 0.0
	if token.Type == ArgError {
		return token
	}
	if arg := token.ToNumber(); arg.Type == ArgNumber {
		num = arg.Number
	}
	if token.Value() == "TRUE" {
		num = 1
	}
	return newNumberFormulaArg(num)
}

// NA function returns the Excel #N/A error. This error message has the
// meaning 'value not available' and is produced when an Excel Formula is
// unable to find a value that it needs. The syntax of the function is:
//
//	NA()
func (fn *formulaFuncs) NA(argsList *list.List) formulaArg {
	if argsList.Len() != 0 {
		return newErrorFormulaArg(formulaErrorVALUE, "NA accepts no arguments")
	}
	return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
}

// SHEET function returns the Sheet number for a specified reference. The
// syntax of the function is:
//
//	SHEET([value])
func (fn *formulaFuncs) SHEET(argsList *list.List) formulaArg {
	if argsList.Len() > 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "SHEET accepts at most 1 argument")
	}
	if argsList.Len() == 0 {
		idx, _ := fn.f.GetSheetIndex(fn.sheet)
		return newNumberFormulaArg(float64(idx + 1))
	}
	arg := argsList.Front().Value.(formulaArg)
	if sheetIdx, _ := fn.f.GetSheetIndex(arg.Value()); sheetIdx != -1 {
		return newNumberFormulaArg(float64(sheetIdx + 1))
	}
	if arg.cellRanges != nil && arg.cellRanges.Len() > 0 {
		if sheetIdx, _ := fn.f.GetSheetIndex(arg.cellRanges.Front().Value.(cellRange).From.Sheet); sheetIdx != -1 {
			return newNumberFormulaArg(float64(sheetIdx + 1))
		}
	}
	if arg.cellRefs != nil && arg.cellRefs.Len() > 0 {
		if sheetIdx, _ := fn.f.GetSheetIndex(arg.cellRefs.Front().Value.(cellRef).Sheet); sheetIdx != -1 {
			return newNumberFormulaArg(float64(sheetIdx + 1))
		}
	}
	return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
}

// SHEETS function returns the number of sheets in a supplied reference. The
// result includes sheets that are Visible, Hidden or Very Hidden. The syntax
// of the function is:
//
//	SHEETS([reference])
func (fn *formulaFuncs) SHEETS(argsList *list.List) formulaArg {
	if argsList.Len() > 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "SHEETS accepts at most 1 argument")
	}
	if argsList.Len() == 0 {
		return newNumberFormulaArg(float64(len(fn.f.GetSheetList())))
	}
	arg := argsList.Front().Value.(formulaArg)
	sheetMap := map[string]struct{}{}
	if arg.cellRanges != nil && arg.cellRanges.Len() > 0 {
		for rng := arg.cellRanges.Front(); rng != nil; rng = rng.Next() {
			sheetMap[rng.Value.(cellRange).From.Sheet] = struct{}{}
		}
	}
	if arg.cellRefs != nil && arg.cellRefs.Len() > 0 {
		for ref := arg.cellRefs.Front(); ref != nil; ref = ref.Next() {
			sheetMap[ref.Value.(cellRef).Sheet] = struct{}{}
		}
	}
	if len(sheetMap) > 0 {
		return newNumberFormulaArg(float64(len(sheetMap)))
	}
	return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
}

// TYPE function returns an integer that represents the value's data type. The
// syntax of the function is:
//
//	TYPE(value)
func (fn *formulaFuncs) TYPE(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "TYPE requires 1 argument")
	}
	token := argsList.Front().Value.(formulaArg)
	switch token.Type {
	case ArgError:
		return newNumberFormulaArg(16)
	case ArgMatrix:
		return newNumberFormulaArg(64)
	case ArgNumber, ArgEmpty:
		if token.Boolean {
			return newNumberFormulaArg(4)
		}
		return newNumberFormulaArg(1)
	default:
		return newNumberFormulaArg(2)
	}
}

// T function tests if a supplied value is text and if so, returns the
// supplied text; Otherwise, the function returns an empty text string. The
// syntax of the function is:
//
//	T(value)
func (fn *formulaFuncs) T(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "T requires 1 argument")
	}
	token := argsList.Front().Value.(formulaArg)
	if token.Type == ArgError {
		return token
	}
	if token.Type == ArgNumber {
		return newStringFormulaArg("")
	}
	return newStringFormulaArg(token.Value())
}

// Logical Functions

// AND function tests a number of supplied conditions and returns TRUE or
// FALSE. The syntax of the function is:
//
//	AND(logical_test1,[logical_test2],...)
