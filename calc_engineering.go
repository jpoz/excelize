// Copyright 2016 - 2025 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.24.0 or later.

package excelize

import (
	"container/list"
	"fmt"
	"math"
	"math/cmplx"
	"strconv"
	"strings"
	"unsafe"
)

// the Besseli function is:
//
//	BESSELI(x,n)
func (fn *formulaFuncs) BESSELI(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "BESSELI requires 2 numeric arguments")
	}
	return fn.bassel(argsList, true)
}

// BESSELJ function returns the Bessel function, Jn(x), for a specified order
// and value of x. The syntax of the function is:
//
//	BESSELJ(x,n)
func (fn *formulaFuncs) BESSELJ(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "BESSELJ requires 2 numeric arguments")
	}
	return fn.bassel(argsList, false)
}

// bassel is an implementation of the formula functions BESSELI and BESSELJ.
func (fn *formulaFuncs) bassel(argsList *list.List, modfied bool) formulaArg {
	x, n := argsList.Front().Value.(formulaArg).ToNumber(), argsList.Back().Value.(formulaArg).ToNumber()
	if x.Type != ArgNumber {
		return x
	}
	if n.Type != ArgNumber {
		return n
	}
	maxVal, x1 := 100, x.Number*0.5
	x2 := x1 * x1
	x1 = math.Pow(x1, n.Number)
	n1, n2, n3, n4, add := fact(n.Number), 1.0, 0.0, n.Number, false
	result := x1 / n1
	t := result * 0.9
	for result != t && maxVal != 0 {
		x1 *= x2
		n3++
		n1 *= n3
		n4++
		n2 *= n4
		t = result
		r := x1 / n1 / n2
		if modfied || add {
			result += r
		} else {
			result -= r
		}
		maxVal--
		add = !add
	}
	return newNumberFormulaArg(result)
}

// BESSELK function calculates the modified Bessel functions, Kn(x), which are
// also known as the hyperbolic Bessel Functions. These are the equivalent of
// the Bessel functions, evaluated for purely imaginary arguments. The syntax
// of the function is:
//
//	BESSELK(x,n)
func (fn *formulaFuncs) BESSELK(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "BESSELK requires 2 numeric arguments")
	}
	x, n := argsList.Front().Value.(formulaArg).ToNumber(), argsList.Back().Value.(formulaArg).ToNumber()
	if x.Type != ArgNumber {
		return x
	}
	if n.Type != ArgNumber {
		return n
	}
	if x.Number <= 0 || n.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	var result float64
	switch math.Floor(n.Number) {
	case 0:
		result = fn.besselK0(x)
	case 1:
		result = fn.besselK1(x)
	default:
		result = fn.besselK2(x, n)
	}
	return newNumberFormulaArg(result)
}

// besselK0 is an implementation of the formula function BESSELK.
func (fn *formulaFuncs) besselK0(x formulaArg) float64 {
	var y float64
	if x.Number <= 2 {
		n2 := x.Number * 0.5
		y = n2 * n2
		args := list.New()
		args.PushBack(x)
		args.PushBack(newNumberFormulaArg(0))
		return -math.Log(n2)*fn.BESSELI(args).Number +
			(-0.57721566 + y*(0.42278420+y*(0.23069756+y*(0.3488590e-1+y*(0.262698e-2+y*
				(0.10750e-3+y*0.74e-5))))))
	}
	y = 2 / x.Number
	return math.Exp(-x.Number) / math.Sqrt(x.Number) *
		(1.25331414 + y*(-0.7832358e-1+y*(0.2189568e-1+y*(-0.1062446e-1+y*
			(0.587872e-2+y*(-0.251540e-2+y*0.53208e-3))))))
}

// besselK1 is an implementation of the formula function BESSELK.
func (fn *formulaFuncs) besselK1(x formulaArg) float64 {
	var n2, y float64
	if x.Number <= 2 {
		n2 = x.Number * 0.5
		y = n2 * n2
		args := list.New()
		args.PushBack(x)
		args.PushBack(newNumberFormulaArg(1))
		return math.Log(n2)*fn.BESSELI(args).Number +
			(1+y*(0.15443144+y*(-0.67278579+y*(-0.18156897+y*(-0.1919402e-1+y*(-0.110404e-2+y*(-0.4686e-4)))))))/x.Number
	}
	y = 2 / x.Number
	return math.Exp(-x.Number) / math.Sqrt(x.Number) *
		(1.25331414 + y*(0.23498619+y*(-0.3655620e-1+y*(0.1504268e-1+y*(-0.780353e-2+y*
			(0.325614e-2+y*(-0.68245e-3)))))))
}

// besselK2 is an implementation of the formula function BESSELK.
func (fn *formulaFuncs) besselK2(x, n formulaArg) float64 {
	tox, bkm, bk, bkp := 2/x.Number, fn.besselK0(x), fn.besselK1(x), 0.0
	for i := 1.0; i < n.Number; i++ {
		bkp = bkm + i*tox*bk
		bkm = bk
		bk = bkp
	}
	return bk
}

// BESSELY function returns the Bessel function, Yn(x), (also known as the
// Weber function or the Neumann function), for a specified order and value
// of x. The syntax of the function is:
//
//	BESSELY(x,n)
func (fn *formulaFuncs) BESSELY(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "BESSELY requires 2 numeric arguments")
	}
	x, n := argsList.Front().Value.(formulaArg).ToNumber(), argsList.Back().Value.(formulaArg).ToNumber()
	if x.Type != ArgNumber {
		return x
	}
	if n.Type != ArgNumber {
		return n
	}
	if x.Number <= 0 || n.Number < 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	var result float64
	switch math.Floor(n.Number) {
	case 0:
		result = fn.besselY0(x)
	case 1:
		result = fn.besselY1(x)
	default:
		result = fn.besselY2(x, n)
	}
	return newNumberFormulaArg(result)
}

// besselY0 is an implementation of the formula function BESSELY.
func (fn *formulaFuncs) besselY0(x formulaArg) float64 {
	var y float64
	if x.Number < 8 {
		y = x.Number * x.Number
		f1 := -2957821389.0 + y*(7062834065.0+y*(-512359803.6+y*(10879881.29+y*
			(-86327.92757+y*228.4622733))))
		f2 := 40076544269.0 + y*(745249964.8+y*(7189466.438+y*
			(47447.26470+y*(226.1030244+y))))
		args := list.New()
		args.PushBack(x)
		args.PushBack(newNumberFormulaArg(0))
		return f1/f2 + 0.636619772*fn.BESSELJ(args).Number*math.Log(x.Number)
	}
	z := 8.0 / x.Number
	y = z * z
	xx := x.Number - 0.785398164
	f1 := 1 + y*(-0.1098628627e-2+y*(0.2734510407e-4+y*(-0.2073370639e-5+y*0.2093887211e-6)))
	f2 := -0.1562499995e-1 + y*(0.1430488765e-3+y*(-0.6911147651e-5+y*(0.7621095161e-6+y*
		(-0.934945152e-7))))
	return math.Sqrt(0.636619772/x.Number) * (math.Sin(xx)*f1 + z*math.Cos(xx)*f2)
}

// besselY1 is an implementation of the formula function BESSELY.
func (fn *formulaFuncs) besselY1(x formulaArg) float64 {
	if x.Number < 8 {
		y := x.Number * x.Number
		f1 := x.Number * (-0.4900604943e13 + y*(0.1275274390e13+y*(-0.5153438139e11+y*
			(0.7349264551e9+y*(-0.4237922726e7+y*0.8511937935e4)))))
		f2 := 0.2499580570e14 + y*(0.4244419664e12+y*(0.3733650367e10+y*(0.2245904002e8+y*
			(0.1020426050e6+y*(0.3549632885e3+y)))))
		args := list.New()
		args.PushBack(x)
		args.PushBack(newNumberFormulaArg(1))
		return f1/f2 + 0.636619772*(fn.BESSELJ(args).Number*math.Log(x.Number)-1/x.Number)
	}
	return math.Sqrt(0.636619772/x.Number) * math.Sin(x.Number-2.356194491)
}

// besselY2 is an implementation of the formula function BESSELY.
func (fn *formulaFuncs) besselY2(x, n formulaArg) float64 {
	tox, bym, by, byp := 2/x.Number, fn.besselY0(x), fn.besselY1(x), 0.0
	for i := 1.0; i < n.Number; i++ {
		byp = i*tox*by - bym
		bym = by
		by = byp
	}
	return by
}

// BIN2DEC function converts a Binary (a base-2 number) into a decimal number.
// The syntax of the function is:
//
//	BIN2DEC(number)
func (fn *formulaFuncs) BIN2DEC(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "BIN2DEC requires 1 numeric argument")
	}
	token := argsList.Front().Value.(formulaArg)
	number := token.ToNumber()
	if number.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, number.Error)
	}
	return fn.bin2dec(token.Value())
}

// BIN2HEX function converts a Binary (Base 2) number into a Hexadecimal
// (Base 16) number. The syntax of the function is:
//
//	BIN2HEX(number,[places])
func (fn *formulaFuncs) BIN2HEX(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "BIN2HEX requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "BIN2HEX allows at most 2 arguments")
	}
	token := argsList.Front().Value.(formulaArg)
	number := token.ToNumber()
	if number.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, number.Error)
	}
	decimal, newList := fn.bin2dec(token.Value()), list.New()
	if decimal.Type != ArgNumber {
		return decimal
	}
	newList.PushBack(decimal)
	if argsList.Len() == 2 {
		newList.PushBack(argsList.Back().Value.(formulaArg))
	}
	return fn.dec2x("BIN2HEX", newList)
}

// BIN2OCT function converts a Binary (Base 2) number into an Octal (Base 8)
// number. The syntax of the function is:
//
//	BIN2OCT(number,[places])
func (fn *formulaFuncs) BIN2OCT(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "BIN2OCT requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "BIN2OCT allows at most 2 arguments")
	}
	token := argsList.Front().Value.(formulaArg)
	number := token.ToNumber()
	if number.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, number.Error)
	}
	decimal, newList := fn.bin2dec(token.Value()), list.New()
	if decimal.Type != ArgNumber {
		return decimal
	}
	newList.PushBack(decimal)
	if argsList.Len() == 2 {
		newList.PushBack(argsList.Back().Value.(formulaArg))
	}
	return fn.dec2x("BIN2OCT", newList)
}

// bin2dec is an implementation of the formula function BIN2DEC.
func (fn *formulaFuncs) bin2dec(number string) formulaArg {
	decimal, length := 0.0, len(number)
	for i := length; i > 0; i-- {
		s := string(number[length-i])
		if i == 10 && s == "1" {
			decimal += math.Pow(-2.0, float64(i-1))
			continue
		}
		if s == "1" {
			decimal += math.Pow(2.0, float64(i-1))
			continue
		}
		if s != "0" {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
	}
	return newNumberFormulaArg(decimal)
}

// BITAND function returns the bitwise 'AND' for two supplied integers. The
// syntax of the function is:
//
//	BITAND(number1,number2)
func (fn *formulaFuncs) BITAND(argsList *list.List) formulaArg {
	return fn.bitwise("BITAND", argsList)
}

// BITLSHIFT function returns a supplied integer, shifted left by a specified
// number of bits. The syntax of the function is:
//
//	BITLSHIFT(number1,shift_amount)
func (fn *formulaFuncs) BITLSHIFT(argsList *list.List) formulaArg {
	return fn.bitwise("BITLSHIFT", argsList)
}

// BITOR function returns the bitwise 'OR' for two supplied integers. The
// syntax of the function is:
//
//	BITOR(number1,number2)
func (fn *formulaFuncs) BITOR(argsList *list.List) formulaArg {
	return fn.bitwise("BITOR", argsList)
}

// BITRSHIFT function returns a supplied integer, shifted right by a specified
// number of bits. The syntax of the function is:
//
//	BITRSHIFT(number1,shift_amount)
func (fn *formulaFuncs) BITRSHIFT(argsList *list.List) formulaArg {
	return fn.bitwise("BITRSHIFT", argsList)
}

// BITXOR function returns the bitwise 'XOR' (exclusive 'OR') for two supplied
// integers. The syntax of the function is:
//
//	BITXOR(number1,number2)
func (fn *formulaFuncs) BITXOR(argsList *list.List) formulaArg {
	return fn.bitwise("BITXOR", argsList)
}

// bitwise is an implementation of the formula functions BITAND, BITLSHIFT,
// BITOR, BITRSHIFT and BITXOR.
func (fn *formulaFuncs) bitwise(name string, argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires 2 numeric arguments", name))
	}
	num1, num2 := argsList.Front().Value.(formulaArg).ToNumber(), argsList.Back().Value.(formulaArg).ToNumber()
	if num1.Type != ArgNumber || num2.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	maxVal := math.Pow(2, 48) - 1
	if num1.Number < 0 || num1.Number > maxVal || num2.Number < 0 || num2.Number > maxVal {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	bitwiseFuncMap := map[string]func(a, b int) int{
		"BITAND":    func(a, b int) int { return a & b },
		"BITLSHIFT": func(a, b int) int { return a << uint(b) },
		"BITOR":     func(a, b int) int { return a | b },
		"BITRSHIFT": func(a, b int) int { return a >> uint(b) },
		"BITXOR":    func(a, b int) int { return a ^ b },
	}
	bitwiseFunc := bitwiseFuncMap[name]
	return newNumberFormulaArg(float64(bitwiseFunc(int(num1.Number), int(num2.Number))))
}

// COMPLEX function takes two arguments, representing the real and the
// imaginary coefficients of a complex number, and from these, creates a
// complex number. The syntax of the function is:
//
//	COMPLEX(real_num,i_num,[suffix])
func (fn *formulaFuncs) COMPLEX(argsList *list.List) formulaArg {
	if argsList.Len() < 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "COMPLEX requires at least 2 arguments")
	}
	if argsList.Len() > 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "COMPLEX allows at most 3 arguments")
	}
	realNum, i, suffix := argsList.Front().Value.(formulaArg).ToNumber(), argsList.Front().Next().Value.(formulaArg).ToNumber(), "i"
	if realNum.Type != ArgNumber {
		return realNum
	}
	if i.Type != ArgNumber {
		return i
	}
	if argsList.Len() == 3 {
		if suffix = strings.ToLower(argsList.Back().Value.(formulaArg).Value()); suffix != "i" && suffix != "j" {
			return newErrorFormulaArg(formulaErrorVALUE, formulaErrorVALUE)
		}
	}
	return newStringFormulaArg(cmplx2str(complex(realNum.Number, i.Number), suffix))
}

// cmplx2str replace complex number string characters.
func cmplx2str(num complex128, suffix string) string {
	realPart, imagPart := fmt.Sprint(real(num)), fmt.Sprint(imag(num))
	isNum, i, decimal := isNumeric(realPart)
	if isNum && i > 15 {
		realPart = strconv.FormatFloat(decimal, 'G', 15, 64)
	}
	isNum, i, decimal = isNumeric(imagPart)
	if isNum && i > 15 {
		imagPart = strconv.FormatFloat(decimal, 'G', 15, 64)
	}
	c := realPart
	if imag(num) > 0 {
		c += "+"
	}
	if imag(num) != 0 {
		c += imagPart + "i"
	}
	c = strings.TrimPrefix(c, "(")
	c = strings.TrimPrefix(c, "+0+")
	c = strings.TrimPrefix(c, "-0+")
	c = strings.TrimSuffix(c, ")")
	c = strings.TrimPrefix(c, "0+")
	if strings.HasPrefix(c, "0-") {
		c = "-" + strings.TrimPrefix(c, "0-")
	}
	c = strings.TrimPrefix(c, "0+")
	c = strings.TrimSuffix(c, "+0i")
	c = strings.TrimSuffix(c, "-0i")
	c = strings.NewReplacer("+1i", "+i", "-1i", "-i").Replace(c)
	c = strings.ReplaceAll(c, "i", suffix)
	return c
}

// str2cmplx convert complex number string characters.
func str2cmplx(c string) string {
	c = strings.ReplaceAll(c, "j", "i")
	if c == "i" {
		c = "1i"
	}
	c = strings.NewReplacer("+i", "+1i", "-i", "-1i").Replace(c)
	return c
}

// conversionUnit defined unit info for conversion.
type conversionUnit struct {
	group       uint8
	allowPrefix bool
}

// conversionUnits maps info list for unit conversion, that can be used in
// formula function CONVERT.
var conversionUnits = map[string]conversionUnit{
	// weight and mass
	"g":        {group: categoryWeightAndMass, allowPrefix: true},
	"sg":       {group: categoryWeightAndMass, allowPrefix: false},
	"lbm":      {group: categoryWeightAndMass, allowPrefix: false},
	"u":        {group: categoryWeightAndMass, allowPrefix: true},
	"ozm":      {group: categoryWeightAndMass, allowPrefix: false},
	"grain":    {group: categoryWeightAndMass, allowPrefix: false},
	"cwt":      {group: categoryWeightAndMass, allowPrefix: false},
	"shweight": {group: categoryWeightAndMass, allowPrefix: false},
	"uk_cwt":   {group: categoryWeightAndMass, allowPrefix: false},
	"lcwt":     {group: categoryWeightAndMass, allowPrefix: false},
	"hweight":  {group: categoryWeightAndMass, allowPrefix: false},
	"stone":    {group: categoryWeightAndMass, allowPrefix: false},
	"ton":      {group: categoryWeightAndMass, allowPrefix: false},
	"uk_ton":   {group: categoryWeightAndMass, allowPrefix: false},
	"LTON":     {group: categoryWeightAndMass, allowPrefix: false},
	"brton":    {group: categoryWeightAndMass, allowPrefix: false},
	// distance
	"m":         {group: categoryDistance, allowPrefix: true},
	"mi":        {group: categoryDistance, allowPrefix: false},
	"Nmi":       {group: categoryDistance, allowPrefix: false},
	"in":        {group: categoryDistance, allowPrefix: false},
	"ft":        {group: categoryDistance, allowPrefix: false},
	"yd":        {group: categoryDistance, allowPrefix: false},
	"ang":       {group: categoryDistance, allowPrefix: true},
	"ell":       {group: categoryDistance, allowPrefix: false},
	"ly":        {group: categoryDistance, allowPrefix: false},
	"parsec":    {group: categoryDistance, allowPrefix: false},
	"pc":        {group: categoryDistance, allowPrefix: false},
	"Pica":      {group: categoryDistance, allowPrefix: false},
	"Picapt":    {group: categoryDistance, allowPrefix: false},
	"pica":      {group: categoryDistance, allowPrefix: false},
	"survey_mi": {group: categoryDistance, allowPrefix: false},
	// time
	"yr":  {group: categoryTime, allowPrefix: false},
	"day": {group: categoryTime, allowPrefix: false},
	"d":   {group: categoryTime, allowPrefix: false},
	"hr":  {group: categoryTime, allowPrefix: false},
	"mn":  {group: categoryTime, allowPrefix: false},
	"min": {group: categoryTime, allowPrefix: false},
	"sec": {group: categoryTime, allowPrefix: true},
	"s":   {group: categoryTime, allowPrefix: true},
	// pressure
	"Pa":   {group: categoryPressure, allowPrefix: true},
	"p":    {group: categoryPressure, allowPrefix: true},
	"atm":  {group: categoryPressure, allowPrefix: true},
	"at":   {group: categoryPressure, allowPrefix: true},
	"mmHg": {group: categoryPressure, allowPrefix: true},
	"psi":  {group: categoryPressure, allowPrefix: true},
	"Torr": {group: categoryPressure, allowPrefix: true},
	// force
	"N":    {group: categoryForce, allowPrefix: true},
	"dyn":  {group: categoryForce, allowPrefix: true},
	"dy":   {group: categoryForce, allowPrefix: true},
	"lbf":  {group: categoryForce, allowPrefix: false},
	"pond": {group: categoryForce, allowPrefix: true},
	// energy
	"J":   {group: categoryEnergy, allowPrefix: true},
	"e":   {group: categoryEnergy, allowPrefix: true},
	"c":   {group: categoryEnergy, allowPrefix: true},
	"cal": {group: categoryEnergy, allowPrefix: true},
	"eV":  {group: categoryEnergy, allowPrefix: true},
	"ev":  {group: categoryEnergy, allowPrefix: true},
	"HPh": {group: categoryEnergy, allowPrefix: false},
	"hh":  {group: categoryEnergy, allowPrefix: false},
	"Wh":  {group: categoryEnergy, allowPrefix: true},
	"wh":  {group: categoryEnergy, allowPrefix: true},
	"flb": {group: categoryEnergy, allowPrefix: false},
	"BTU": {group: categoryEnergy, allowPrefix: false},
	"btu": {group: categoryEnergy, allowPrefix: false},
	// power
	"HP": {group: categoryPower, allowPrefix: false},
	"h":  {group: categoryPower, allowPrefix: false},
	"W":  {group: categoryPower, allowPrefix: true},
	"w":  {group: categoryPower, allowPrefix: true},
	"PS": {group: categoryPower, allowPrefix: false},
	"T":  {group: categoryMagnetism, allowPrefix: true},
	"ga": {group: categoryMagnetism, allowPrefix: true},
	// temperature
	"C":    {group: categoryTemperature, allowPrefix: false},
	"cel":  {group: categoryTemperature, allowPrefix: false},
	"F":    {group: categoryTemperature, allowPrefix: false},
	"fah":  {group: categoryTemperature, allowPrefix: false},
	"K":    {group: categoryTemperature, allowPrefix: false},
	"kel":  {group: categoryTemperature, allowPrefix: false},
	"Rank": {group: categoryTemperature, allowPrefix: false},
	"Reau": {group: categoryTemperature, allowPrefix: false},
	// volume
	"l":        {group: categoryVolumeAndLiquidMeasure, allowPrefix: true},
	"L":        {group: categoryVolumeAndLiquidMeasure, allowPrefix: true},
	"lt":       {group: categoryVolumeAndLiquidMeasure, allowPrefix: true},
	"tsp":      {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"tspm":     {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"tbs":      {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"oz":       {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"cup":      {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"pt":       {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"us_pt":    {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"uk_pt":    {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"qt":       {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"uk_qt":    {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"gal":      {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"uk_gal":   {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"ang3":     {group: categoryVolumeAndLiquidMeasure, allowPrefix: true},
	"ang^3":    {group: categoryVolumeAndLiquidMeasure, allowPrefix: true},
	"barrel":   {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"bushel":   {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"in3":      {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"in^3":     {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"ft3":      {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"ft^3":     {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"ly3":      {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"ly^3":     {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"m3":       {group: categoryVolumeAndLiquidMeasure, allowPrefix: true},
	"m^3":      {group: categoryVolumeAndLiquidMeasure, allowPrefix: true},
	"mi3":      {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"mi^3":     {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"yd3":      {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"yd^3":     {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"Nmi3":     {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"Nmi^3":    {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"Pica3":    {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"Pica^3":   {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"Picapt3":  {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"Picapt^3": {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"GRT":      {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"regton":   {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	"MTON":     {group: categoryVolumeAndLiquidMeasure, allowPrefix: false},
	// area
	"ha":       {group: categoryArea, allowPrefix: true},
	"uk_acre":  {group: categoryArea, allowPrefix: false},
	"us_acre":  {group: categoryArea, allowPrefix: false},
	"ang2":     {group: categoryArea, allowPrefix: true},
	"ang^2":    {group: categoryArea, allowPrefix: true},
	"ar":       {group: categoryArea, allowPrefix: true},
	"ft2":      {group: categoryArea, allowPrefix: false},
	"ft^2":     {group: categoryArea, allowPrefix: false},
	"in2":      {group: categoryArea, allowPrefix: false},
	"in^2":     {group: categoryArea, allowPrefix: false},
	"ly2":      {group: categoryArea, allowPrefix: false},
	"ly^2":     {group: categoryArea, allowPrefix: false},
	"m2":       {group: categoryArea, allowPrefix: true},
	"m^2":      {group: categoryArea, allowPrefix: true},
	"Morgen":   {group: categoryArea, allowPrefix: false},
	"mi2":      {group: categoryArea, allowPrefix: false},
	"mi^2":     {group: categoryArea, allowPrefix: false},
	"Nmi2":     {group: categoryArea, allowPrefix: false},
	"Nmi^2":    {group: categoryArea, allowPrefix: false},
	"Pica2":    {group: categoryArea, allowPrefix: false},
	"Pica^2":   {group: categoryArea, allowPrefix: false},
	"Picapt2":  {group: categoryArea, allowPrefix: false},
	"Picapt^2": {group: categoryArea, allowPrefix: false},
	"yd2":      {group: categoryArea, allowPrefix: false},
	"yd^2":     {group: categoryArea, allowPrefix: false},
	// information
	"byte": {group: categoryInformation, allowPrefix: true},
	"bit":  {group: categoryInformation, allowPrefix: true},
	// speed
	"m/s":   {group: categorySpeed, allowPrefix: true},
	"m/sec": {group: categorySpeed, allowPrefix: true},
	"m/h":   {group: categorySpeed, allowPrefix: true},
	"m/hr":  {group: categorySpeed, allowPrefix: true},
	"mph":   {group: categorySpeed, allowPrefix: false},
	"admkn": {group: categorySpeed, allowPrefix: false},
	"kn":    {group: categorySpeed, allowPrefix: false},
}

// unitConversions maps details of the Units of measure conversion factors,
// organised by group.
var unitConversions = map[byte]map[string]float64{
	// conversion uses gram (g) as an intermediate unit
	categoryWeightAndMass: {
		"g":        1,
		"sg":       6.85217658567918e-05,
		"lbm":      2.20462262184878e-03,
		"u":        6.02214179421676e+23,
		"ozm":      3.52739619495804e-02,
		"grain":    1.54323583529414e+01,
		"cwt":      2.20462262184878e-05,
		"shweight": 2.20462262184878e-05,
		"uk_cwt":   1.96841305522212e-05,
		"lcwt":     1.96841305522212e-05,
		"hweight":  1.96841305522212e-05,
		"stone":    1.57473044417770e-04,
		"ton":      1.10231131092439e-06,
		"uk_ton":   9.84206527611061e-07,
		"LTON":     9.84206527611061e-07,
		"brton":    9.84206527611061e-07,
	},
	// conversion uses meter (m) as an intermediate unit
	categoryDistance: {
		"m":         1,
		"mi":        6.21371192237334e-04,
		"Nmi":       5.39956803455724e-04,
		"in":        3.93700787401575e+01,
		"ft":        3.28083989501312e+00,
		"yd":        1.09361329833771e+00,
		"ang":       1.0e+10,
		"ell":       8.74890638670166e-01,
		"ly":        1.05700083402462e-16,
		"parsec":    3.24077928966473e-17,
		"pc":        3.24077928966473e-17,
		"Pica":      2.83464566929134e+03,
		"Picapt":    2.83464566929134e+03,
		"pica":      2.36220472440945e+02,
		"survey_mi": 6.21369949494950e-04,
	},
	// conversion uses second (s) as an intermediate unit
	categoryTime: {
		"yr":  3.16880878140289e-08,
		"day": 1.15740740740741e-05,
		"d":   1.15740740740741e-05,
		"hr":  2.77777777777778e-04,
		"mn":  1.66666666666667e-02,
		"min": 1.66666666666667e-02,
		"sec": 1,
		"s":   1,
	},
	// conversion uses Pascal (Pa) as an intermediate unit
	categoryPressure: {
		"Pa":   1,
		"p":    1,
		"atm":  9.86923266716013e-06,
		"at":   9.86923266716013e-06,
		"mmHg": 7.50063755419211e-03,
		"psi":  1.45037737730209e-04,
		"Torr": 7.50061682704170e-03,
	},
	// conversion uses Newton (N) as an intermediate unit
	categoryForce: {
		"N":    1,
		"dyn":  1.0e+5,
		"dy":   1.0e+5,
		"lbf":  2.24808923655339e-01,
		"pond": 1.01971621297793e+02,
	},
	// conversion uses Joule (J) as an intermediate unit
	categoryEnergy: {
		"J":   1,
		"e":   9.99999519343231e+06,
		"c":   2.39006249473467e-01,
		"cal": 2.38846190642017e-01,
		"eV":  6.24145700000000e+18,
		"ev":  6.24145700000000e+18,
		"HPh": 3.72506430801000e-07,
		"hh":  3.72506430801000e-07,
		"Wh":  2.77777916238711e-04,
		"wh":  2.77777916238711e-04,
		"flb": 2.37304222192651e+01,
		"BTU": 9.47815067349015e-04,
		"btu": 9.47815067349015e-04,
	},
	// conversion uses Horsepower (HP) as an intermediate unit
	categoryPower: {
		"HP": 1,
		"h":  1,
		"W":  7.45699871582270e+02,
		"w":  7.45699871582270e+02,
		"PS": 1.01386966542400e+00,
	},
	// conversion uses Tesla (T) as an intermediate unit
	categoryMagnetism: {
		"T":  1,
		"ga": 10000,
	},
	// conversion uses litre (l) as an intermediate unit
	categoryVolumeAndLiquidMeasure: {
		"l":        1,
		"L":        1,
		"lt":       1,
		"tsp":      2.02884136211058e+02,
		"tspm":     2.0e+02,
		"tbs":      6.76280454036860e+01,
		"oz":       3.38140227018430e+01,
		"cup":      4.22675283773038e+00,
		"pt":       2.11337641886519e+00,
		"us_pt":    2.11337641886519e+00,
		"uk_pt":    1.75975398639270e+00,
		"qt":       1.05668820943259e+00,
		"uk_qt":    8.79876993196351e-01,
		"gal":      2.64172052358148e-01,
		"uk_gal":   2.19969248299088e-01,
		"ang3":     1.0e+27,
		"ang^3":    1.0e+27,
		"barrel":   6.28981077043211e-03,
		"bushel":   2.83775932584017e-02,
		"in3":      6.10237440947323e+01,
		"in^3":     6.10237440947323e+01,
		"ft3":      3.53146667214886e-02,
		"ft^3":     3.53146667214886e-02,
		"ly3":      1.18093498844171e-51,
		"ly^3":     1.18093498844171e-51,
		"m3":       1.0e-03,
		"m^3":      1.0e-03,
		"mi3":      2.39912758578928e-13,
		"mi^3":     2.39912758578928e-13,
		"yd3":      1.30795061931439e-03,
		"yd^3":     1.30795061931439e-03,
		"Nmi3":     1.57426214685811e-13,
		"Nmi^3":    1.57426214685811e-13,
		"Pica3":    2.27769904358706e+07,
		"Pica^3":   2.27769904358706e+07,
		"Picapt3":  2.27769904358706e+07,
		"Picapt^3": 2.27769904358706e+07,
		"GRT":      3.53146667214886e-04,
		"regton":   3.53146667214886e-04,
		"MTON":     8.82866668037215e-04,
	},
	// conversion uses hectare (ha) as an intermediate unit
	categoryArea: {
		"ha":       1,
		"uk_acre":  2.47105381467165e+00,
		"us_acre":  2.47104393046628e+00,
		"ang2":     1.0e+24,
		"ang^2":    1.0e+24,
		"ar":       1.0e+02,
		"ft2":      1.07639104167097e+05,
		"ft^2":     1.07639104167097e+05,
		"in2":      1.55000310000620e+07,
		"in^2":     1.55000310000620e+07,
		"ly2":      1.11725076312873e-28,
		"ly^2":     1.11725076312873e-28,
		"m2":       1.0e+04,
		"m^2":      1.0e+04,
		"Morgen":   4.0e+00,
		"mi2":      3.86102158542446e-03,
		"mi^2":     3.86102158542446e-03,
		"Nmi2":     2.91553349598123e-03,
		"Nmi^2":    2.91553349598123e-03,
		"Pica2":    8.03521607043214e+10,
		"Pica^2":   8.03521607043214e+10,
		"Picapt2":  8.03521607043214e+10,
		"Picapt^2": 8.03521607043214e+10,
		"yd2":      1.19599004630108e+04,
		"yd^2":     1.19599004630108e+04,
	},
	// conversion uses bit (bit) as an intermediate unit
	categoryInformation: {
		"bit":  1,
		"byte": 0.125,
	},
	// conversion uses Meters per Second (m/s) as an intermediate unit
	categorySpeed: {
		"m/s":   1,
		"m/sec": 1,
		"m/h":   3.60e+03,
		"m/hr":  3.60e+03,
		"mph":   2.23693629205440e+00,
		"admkn": 1.94260256941567e+00,
		"kn":    1.94384449244060e+00,
	},
}

// conversionMultipliers maps details of the Multiplier prefixes that can be
// used with Units of Measure in CONVERT.
var conversionMultipliers = map[string]float64{
	"Y":  1e24,
	"Z":  1e21,
	"E":  1e18,
	"P":  1e15,
	"T":  1e12,
	"G":  1e9,
	"M":  1e6,
	"k":  1e3,
	"h":  1e2,
	"e":  1e1,
	"da": 1e1,
	"d":  1e-1,
	"c":  1e-2,
	"m":  1e-3,
	"u":  1e-6,
	"n":  1e-9,
	"p":  1e-12,
	"f":  1e-15,
	"a":  1e-18,
	"z":  1e-21,
	"y":  1e-24,
	"Yi": math.Pow(2, 80),
	"Zi": math.Pow(2, 70),
	"Ei": math.Pow(2, 60),
	"Pi": math.Pow(2, 50),
	"Ti": math.Pow(2, 40),
	"Gi": math.Pow(2, 30),
	"Mi": math.Pow(2, 20),
	"ki": math.Pow(2, 10),
}

// getUnitDetails check and returns the unit of measure details.
func getUnitDetails(uom string) (unit string, catgory byte, res float64, ok bool) {
	if len(uom) == 0 {
		ok = false
		return
	}
	if unit, ok := conversionUnits[uom]; ok {
		return uom, unit.group, 1, ok
	}
	// 1 character standard metric multiplier prefixes
	multiplierType := uom[:1]
	uom = uom[1:]
	conversionUnit, ok1 := conversionUnits[uom]
	multiplier, ok2 := conversionMultipliers[multiplierType]
	if ok1 && ok2 {
		if !conversionUnit.allowPrefix {
			ok = false
			return
		}
		unitCategory := conversionUnit.group
		return uom, unitCategory, multiplier, true
	}
	// 2 character standard and binary metric multiplier prefixes
	if len(uom) > 0 {
		multiplierType += uom[:1]
		uom = uom[1:]
	}
	conversionUnit, ok1 = conversionUnits[uom]
	multiplier, ok2 = conversionMultipliers[multiplierType]
	if ok1 && ok2 {
		if !conversionUnit.allowPrefix {
			ok = false
			return
		}
		unitCategory := conversionUnit.group
		return uom, unitCategory, multiplier, true
	}
	ok = false
	return
}

// resolveTemperatureSynonyms returns unit of measure according to a given
// temperature synonyms.
func resolveTemperatureSynonyms(uom string) string {
	switch uom {
	case "fah":
		return "F"
	case "cel":
		return "C"
	case "kel":
		return "K"
	}
	return uom
}

// convertTemperature returns converted temperature by a given unit of measure.
func convertTemperature(fromUOM, toUOM string, value float64) float64 {
	fromUOM = resolveTemperatureSynonyms(fromUOM)
	toUOM = resolveTemperatureSynonyms(toUOM)
	if fromUOM == toUOM {
		return value
	}
	// convert to Kelvin
	switch fromUOM {
	case "F":
		value = (value-32)/1.8 + 273.15
	case "C":
		value += 273.15
	case "Rank":
		value /= 1.8
	case "Reau":
		value = value*1.25 + 273.15
	}
	// convert from Kelvin
	switch toUOM {
	case "F":
		value = (value-273.15)*1.8 + 32
	case "C":
		value -= 273.15
	case "Rank":
		value *= 1.8
	case "Reau":
		value = (value - 273.15) * 0.8
	}
	return value
}

// CONVERT function converts a number from one unit type (e.g. Yards) to
// another unit type (e.g. Meters). The syntax of the function is:
//
//	CONVERT(number,from_unit,to_unit)
func (fn *formulaFuncs) CONVERT(argsList *list.List) formulaArg {
	if argsList.Len() != 3 {
		return newErrorFormulaArg(formulaErrorVALUE, "CONVERT requires 3 arguments")
	}
	num := argsList.Front().Value.(formulaArg).ToNumber()
	if num.Type != ArgNumber {
		return num
	}
	fromUOM, fromCategory, fromMultiplier, ok1 := getUnitDetails(argsList.Front().Next().Value.(formulaArg).Value())
	toUOM, toCategory, toMultiplier, ok2 := getUnitDetails(argsList.Back().Value.(formulaArg).Value())
	if !ok1 || !ok2 || fromCategory != toCategory {
		return newErrorFormulaArg(formulaErrorNA, formulaErrorNA)
	}
	val := num.Number * fromMultiplier
	if fromUOM == toUOM && fromMultiplier == toMultiplier {
		return newNumberFormulaArg(val / fromMultiplier)
	} else if fromUOM == toUOM {
		return newNumberFormulaArg(val / toMultiplier)
	} else if fromCategory == categoryTemperature {
		return newNumberFormulaArg(convertTemperature(fromUOM, toUOM, val))
	}
	fromConversion := unitConversions[fromCategory][fromUOM]
	toConversion := unitConversions[fromCategory][toUOM]
	baseValue := val * (1 / fromConversion)
	return newNumberFormulaArg((baseValue * toConversion) / toMultiplier)
}

// DEC2BIN function converts a decimal number into a Binary (Base 2) number.
// The syntax of the function is:
//
//	DEC2BIN(number,[places])
func (fn *formulaFuncs) DEC2BIN(argsList *list.List) formulaArg {
	return fn.dec2x("DEC2BIN", argsList)
}

// DEC2HEX function converts a decimal number into a Hexadecimal (Base 16)
// number. The syntax of the function is:
//
//	DEC2HEX(number,[places])
func (fn *formulaFuncs) DEC2HEX(argsList *list.List) formulaArg {
	return fn.dec2x("DEC2HEX", argsList)
}

// DEC2OCT function converts a decimal number into an Octal (Base 8) number.
// The syntax of the function is:
//
//	DEC2OCT(number,[places])
func (fn *formulaFuncs) DEC2OCT(argsList *list.List) formulaArg {
	return fn.dec2x("DEC2OCT", argsList)
}

// dec2x is an implementation of the formula functions DEC2BIN, DEC2HEX and
// DEC2OCT.
func (fn *formulaFuncs) dec2x(name string, argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires at least 1 argument", name))
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s allows at most 2 arguments", name))
	}
	decimal := argsList.Front().Value.(formulaArg).ToNumber()
	if decimal.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, decimal.Error)
	}
	maxLimitMap := map[string]float64{
		"DEC2BIN": 511,
		"HEX2BIN": 511,
		"OCT2BIN": 511,
		"BIN2HEX": 549755813887,
		"DEC2HEX": 549755813887,
		"OCT2HEX": 549755813887,
		"BIN2OCT": 536870911,
		"DEC2OCT": 536870911,
		"HEX2OCT": 536870911,
	}
	minLimitMap := map[string]float64{
		"DEC2BIN": -512,
		"HEX2BIN": -512,
		"OCT2BIN": -512,
		"BIN2HEX": -549755813888,
		"DEC2HEX": -549755813888,
		"OCT2HEX": -549755813888,
		"BIN2OCT": -536870912,
		"DEC2OCT": -536870912,
		"HEX2OCT": -536870912,
	}
	baseMap := map[string]int{
		"DEC2BIN": 2,
		"HEX2BIN": 2,
		"OCT2BIN": 2,
		"BIN2HEX": 16,
		"DEC2HEX": 16,
		"OCT2HEX": 16,
		"BIN2OCT": 8,
		"DEC2OCT": 8,
		"HEX2OCT": 8,
	}
	maxLimit, minLimit := maxLimitMap[name], minLimitMap[name]
	base := baseMap[name]
	if decimal.Number < minLimit || decimal.Number > maxLimit {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	n := int64(decimal.Number)
	binary := strconv.FormatUint(*(*uint64)(unsafe.Pointer(&n)), base)
	if argsList.Len() == 2 {
		places := argsList.Back().Value.(formulaArg).ToNumber()
		if places.Type != ArgNumber {
			return newErrorFormulaArg(formulaErrorVALUE, places.Error)
		}
		binaryPlaces := len(binary)
		if places.Number < 0 || places.Number > 10 || binaryPlaces > int(places.Number) {
			return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
		}
		return newStringFormulaArg(strings.ToUpper(fmt.Sprintf("%s%s", strings.Repeat("0", int(places.Number)-binaryPlaces), binary)))
	}
	if decimal.Number < 0 && len(binary) > 10 {
		return newStringFormulaArg(strings.ToUpper(binary[len(binary)-10:]))
	}
	return newStringFormulaArg(strings.ToUpper(binary))
}

// DELTA function tests two numbers for equality and returns the Kronecker
// Delta. i.e. the function returns 1 if the two supplied numbers are equal
// and 0 otherwise. The syntax of the function is:
//
//	DELTA(number1,[number2])
func (fn *formulaFuncs) DELTA(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "DELTA requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "DELTA allows at most 2 arguments")
	}
	number1 := argsList.Front().Value.(formulaArg).ToNumber()
	if number1.Type != ArgNumber {
		return number1
	}
	number2 := newNumberFormulaArg(0)
	if argsList.Len() == 2 {
		if number2 = argsList.Back().Value.(formulaArg).ToNumber(); number2.Type != ArgNumber {
			return number2
		}
	}
	return newBoolFormulaArg(number1.Number == number2.Number).ToNumber()
}

// ERF function calculates the Error Function, integrated between two supplied
// limits. The syntax of the function is:
//
//	ERF(lower_limit,[upper_limit])
func (fn *formulaFuncs) ERF(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ERF requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "ERF allows at most 2 arguments")
	}
	lower := argsList.Front().Value.(formulaArg).ToNumber()
	if lower.Type != ArgNumber {
		return lower
	}
	if argsList.Len() == 2 {
		upper := argsList.Back().Value.(formulaArg).ToNumber()
		if upper.Type != ArgNumber {
			return upper
		}
		return newNumberFormulaArg(math.Erf(upper.Number) - math.Erf(lower.Number))
	}
	return newNumberFormulaArg(math.Erf(lower.Number))
}

// ERFdotPRECISE function calculates the Error Function, integrated between a
// supplied lower or upper limit and 0. The syntax of the function is:
//
//	ERF.PRECISE(x)
func (fn *formulaFuncs) ERFdotPRECISE(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "ERF.PRECISE requires 1 argument")
	}
	x := argsList.Front().Value.(formulaArg).ToNumber()
	if x.Type != ArgNumber {
		return x
	}
	return newNumberFormulaArg(math.Erf(x.Number))
}

// erfc is an implementation of the formula functions ERFC and ERFC.PRECISE.
func (fn *formulaFuncs) erfc(name string, argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, fmt.Sprintf("%s requires 1 argument", name))
	}
	x := argsList.Front().Value.(formulaArg).ToNumber()
	if x.Type != ArgNumber {
		return x
	}
	return newNumberFormulaArg(math.Erfc(x.Number))
}

// ERFC function calculates the Complementary Error Function, integrated
// between a supplied lower limit and infinity. The syntax of the function
// is:
//
//	ERFC(x)
func (fn *formulaFuncs) ERFC(argsList *list.List) formulaArg {
	return fn.erfc("ERFC", argsList)
}

// ERFCdotPRECISE function calculates the Complementary Error Function,
// integrated between a supplied lower limit and infinity. The syntax of the
// function is:
//
//	ERFC(x)
func (fn *formulaFuncs) ERFCdotPRECISE(argsList *list.List) formulaArg {
	return fn.erfc("ERFC.PRECISE", argsList)
}

// GESTEP unction tests whether a supplied number is greater than a supplied
// step size and returns. The syntax of the function is:
//
//	GESTEP(number,[step])
func (fn *formulaFuncs) GESTEP(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "GESTEP requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "GESTEP allows at most 2 arguments")
	}
	number := argsList.Front().Value.(formulaArg).ToNumber()
	if number.Type != ArgNumber {
		return number
	}
	step := newNumberFormulaArg(0)
	if argsList.Len() == 2 {
		if step = argsList.Back().Value.(formulaArg).ToNumber(); step.Type != ArgNumber {
			return step
		}
	}
	return newBoolFormulaArg(number.Number >= step.Number).ToNumber()
}

// HEX2BIN function converts a Hexadecimal (Base 16) number into a Binary
// (Base 2) number. The syntax of the function is:
//
//	HEX2BIN(number,[places])
func (fn *formulaFuncs) HEX2BIN(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "HEX2BIN requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "HEX2BIN allows at most 2 arguments")
	}
	decimal, newList := fn.hex2dec(argsList.Front().Value.(formulaArg).Value()), list.New()
	if decimal.Type != ArgNumber {
		return decimal
	}
	newList.PushBack(decimal)
	if argsList.Len() == 2 {
		newList.PushBack(argsList.Back().Value.(formulaArg))
	}
	return fn.dec2x("HEX2BIN", newList)
}

// HEX2DEC function converts a hexadecimal (a base-16 number) into a decimal
// number. The syntax of the function is:
//
//	HEX2DEC(number)
func (fn *formulaFuncs) HEX2DEC(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "HEX2DEC requires 1 numeric argument")
	}
	return fn.hex2dec(argsList.Front().Value.(formulaArg).Value())
}

// HEX2OCT function converts a Hexadecimal (Base 16) number into an Octal
// (Base 8) number. The syntax of the function is:
//
//	HEX2OCT(number,[places])
func (fn *formulaFuncs) HEX2OCT(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "HEX2OCT requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "HEX2OCT allows at most 2 arguments")
	}
	decimal, newList := fn.hex2dec(argsList.Front().Value.(formulaArg).Value()), list.New()
	if decimal.Type != ArgNumber {
		return decimal
	}
	newList.PushBack(decimal)
	if argsList.Len() == 2 {
		newList.PushBack(argsList.Back().Value.(formulaArg))
	}
	return fn.dec2x("HEX2OCT", newList)
}

// hex2dec is an implementation of the formula function HEX2DEC.
func (fn *formulaFuncs) hex2dec(number string) formulaArg {
	decimal, length := 0.0, len(number)
	for i := length; i > 0; i-- {
		num, err := strconv.ParseInt(string(number[length-i]), 16, 64)
		if err != nil {
			return newErrorFormulaArg(formulaErrorNUM, err.Error())
		}
		if i == 10 && string(number[length-i]) == "F" {
			decimal += math.Pow(-16.0, float64(i-1))
			continue
		}
		decimal += float64(num) * math.Pow(16.0, float64(i-1))
	}
	return newNumberFormulaArg(decimal)
}

// IMABS function returns the absolute value (the modulus) of a complex
// number. The syntax of the function is:
//
//	IMABS(inumber)
func (fn *formulaFuncs) IMABS(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMABS requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	return newNumberFormulaArg(cmplx.Abs(inumber))
}

// IMAGINARY function returns the imaginary coefficient of a supplied complex
// number. The syntax of the function is:
//
//	IMAGINARY(inumber)
func (fn *formulaFuncs) IMAGINARY(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMAGINARY requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	return newNumberFormulaArg(imag(inumber))
}

// IMARGUMENT function returns the phase (also called the argument) of a
// supplied complex number. The syntax of the function is:
//
//	IMARGUMENT(inumber)
func (fn *formulaFuncs) IMARGUMENT(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMARGUMENT requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	return newNumberFormulaArg(cmplx.Phase(inumber))
}

// IMCONJUGATE function returns the complex conjugate of a supplied complex
// number. The syntax of the function is:
//
//	IMCONJUGATE(inumber)
func (fn *formulaFuncs) IMCONJUGATE(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMCONJUGATE requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	return newStringFormulaArg(cmplx2str(cmplx.Conj(inumber), value[len(value)-1:]))
}

// IMCOS function returns the cosine of a supplied complex number. The syntax
// of the function is:
//
//	IMCOS(inumber)
func (fn *formulaFuncs) IMCOS(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMCOS requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	return newStringFormulaArg(cmplx2str(cmplx.Cos(inumber), value[len(value)-1:]))
}

// IMCOSH function returns the hyperbolic cosine of a supplied complex number. The syntax
// of the function is:
//
//	IMCOSH(inumber)
func (fn *formulaFuncs) IMCOSH(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMCOSH requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	return newStringFormulaArg(cmplx2str(cmplx.Cosh(inumber), value[len(value)-1:]))
}

// IMCOT function returns the cotangent of a supplied complex number. The syntax
// of the function is:
//
//	IMCOT(inumber)
func (fn *formulaFuncs) IMCOT(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMCOT requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	return newStringFormulaArg(cmplx2str(cmplx.Cot(inumber), value[len(value)-1:]))
}

// IMCSC function returns the cosecant of a supplied complex number. The syntax
// of the function is:
//
//	IMCSC(inumber)
func (fn *formulaFuncs) IMCSC(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMCSC requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	num := 1 / cmplx.Sin(inumber)
	if cmplx.IsInf(num) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newStringFormulaArg(cmplx2str(num, value[len(value)-1:]))
}

// IMCSCH function returns the hyperbolic cosecant of a supplied complex
// number. The syntax of the function is:
//
//	IMCSCH(inumber)
func (fn *formulaFuncs) IMCSCH(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMCSCH requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	num := 1 / cmplx.Sinh(inumber)
	if cmplx.IsInf(num) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newStringFormulaArg(cmplx2str(num, value[len(value)-1:]))
}

// IMDIV function calculates the quotient of two complex numbers (i.e. divides
// one complex number by another). The syntax of the function is:
//
//	IMDIV(inumber1,inumber2)
func (fn *formulaFuncs) IMDIV(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMDIV requires 2 arguments")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber1, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	inumber2, err := strconv.ParseComplex(str2cmplx(argsList.Back().Value.(formulaArg).Value()), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	num := inumber1 / inumber2
	if cmplx.IsInf(num) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newStringFormulaArg(cmplx2str(num, value[len(value)-1:]))
}

// IMEXP function returns the exponential of a supplied complex number. The
// syntax of the function is:
//
//	IMEXP(inumber)
func (fn *formulaFuncs) IMEXP(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMEXP requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	return newStringFormulaArg(cmplx2str(cmplx.Exp(inumber), value[len(value)-1:]))
}

// IMLN function returns the natural logarithm of a supplied complex number.
// The syntax of the function is:
//
//	IMLN(inumber)
func (fn *formulaFuncs) IMLN(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMLN requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	num := cmplx.Log(inumber)
	if cmplx.IsInf(num) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newStringFormulaArg(cmplx2str(num, value[len(value)-1:]))
}

// IMLOG10 function returns the common (base 10) logarithm of a supplied
// complex number. The syntax of the function is:
//
//	IMLOG10(inumber)
func (fn *formulaFuncs) IMLOG10(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMLOG10 requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	num := cmplx.Log10(inumber)
	if cmplx.IsInf(num) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newStringFormulaArg(cmplx2str(num, value[len(value)-1:]))
}

// IMLOG2 function calculates the base 2 logarithm of a supplied complex
// number. The syntax of the function is:
//
//	IMLOG2(inumber)
func (fn *formulaFuncs) IMLOG2(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMLOG2 requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	num := cmplx.Log(inumber)
	if cmplx.IsInf(num) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newStringFormulaArg(cmplx2str(num/cmplx.Log(2), value[len(value)-1:]))
}

// IMPOWER function returns a supplied complex number, raised to a given
// power. The syntax of the function is:
//
//	IMPOWER(inumber,number)
func (fn *formulaFuncs) IMPOWER(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMPOWER requires 2 arguments")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	number, err := strconv.ParseComplex(str2cmplx(argsList.Back().Value.(formulaArg).Value()), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	if inumber == 0 && number == 0 {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	num := cmplx.Pow(inumber, number)
	if cmplx.IsInf(num) {
		return newErrorFormulaArg(formulaErrorNUM, formulaErrorNUM)
	}
	return newStringFormulaArg(cmplx2str(num, value[len(value)-1:]))
}

// IMPRODUCT function calculates the product of two or more complex numbers.
// The syntax of the function is:
//
//	IMPRODUCT(number1,[number2],...)
func (fn *formulaFuncs) IMPRODUCT(argsList *list.List) formulaArg {
	product := complex128(1)
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		token := arg.Value.(formulaArg)
		switch token.Type {
		case ArgString:
			if token.Value() == "" {
				continue
			}
			val, err := strconv.ParseComplex(str2cmplx(token.Value()), 128)
			if err != nil {
				return newErrorFormulaArg(formulaErrorNUM, err.Error())
			}
			product = product * val
		case ArgNumber:
			product = product * complex(token.Number, 0)
		case ArgMatrix:
			for _, row := range token.Matrix {
				for _, value := range row {
					if value.Value() == "" {
						continue
					}
					val, err := strconv.ParseComplex(str2cmplx(value.Value()), 128)
					if err != nil {
						return newErrorFormulaArg(formulaErrorNUM, err.Error())
					}
					product = product * val
				}
			}
		}
	}
	return newStringFormulaArg(cmplx2str(product, "i"))
}

// IMREAL function returns the real coefficient of a supplied complex number.
// The syntax of the function is:
//
//	IMREAL(inumber)
func (fn *formulaFuncs) IMREAL(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMREAL requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	return newStringFormulaArg(fmt.Sprint(real(inumber)))
}

// IMSEC function returns the secant of a supplied complex number. The syntax
// of the function is:
//
//	IMSEC(inumber)
func (fn *formulaFuncs) IMSEC(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMSEC requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	return newStringFormulaArg(cmplx2str(1/cmplx.Cos(inumber), value[len(value)-1:]))
}

// IMSECH function returns the hyperbolic secant of a supplied complex number.
// The syntax of the function is:
//
//	IMSECH(inumber)
func (fn *formulaFuncs) IMSECH(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMSECH requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	return newStringFormulaArg(cmplx2str(1/cmplx.Cosh(inumber), value[len(value)-1:]))
}

// IMSIN function returns the Sine of a supplied complex number. The syntax of
// the function is:
//
//	IMSIN(inumber)
func (fn *formulaFuncs) IMSIN(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMSIN requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	return newStringFormulaArg(cmplx2str(cmplx.Sin(inumber), value[len(value)-1:]))
}

// IMSINH function returns the hyperbolic sine of a supplied complex number.
// The syntax of the function is:
//
//	IMSINH(inumber)
func (fn *formulaFuncs) IMSINH(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMSINH requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	return newStringFormulaArg(cmplx2str(cmplx.Sinh(inumber), value[len(value)-1:]))
}

// IMSQRT function returns the square root of a supplied complex number. The
// syntax of the function is:
//
//	IMSQRT(inumber)
func (fn *formulaFuncs) IMSQRT(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMSQRT requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	return newStringFormulaArg(cmplx2str(cmplx.Sqrt(inumber), value[len(value)-1:]))
}

// IMSUB function calculates the difference between two complex numbers
// (i.e. subtracts one complex number from another). The syntax of the
// function is:
//
//	IMSUB(inumber1,inumber2)
func (fn *formulaFuncs) IMSUB(argsList *list.List) formulaArg {
	if argsList.Len() != 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMSUB requires 2 arguments")
	}
	i1, err := strconv.ParseComplex(str2cmplx(argsList.Front().Value.(formulaArg).Value()), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	i2, err := strconv.ParseComplex(str2cmplx(argsList.Back().Value.(formulaArg).Value()), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	return newStringFormulaArg(cmplx2str(i1-i2, "i"))
}

// IMSUM function calculates the sum of two or more complex numbers. The
// syntax of the function is:
//
//	IMSUM(inumber1,inumber2,...)
func (fn *formulaFuncs) IMSUM(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMSUM requires at least 1 argument")
	}
	var result complex128
	for arg := argsList.Front(); arg != nil; arg = arg.Next() {
		token := arg.Value.(formulaArg)
		num, err := strconv.ParseComplex(str2cmplx(token.Value()), 128)
		if err != nil {
			return newErrorFormulaArg(formulaErrorNUM, err.Error())
		}
		result += num
	}
	return newStringFormulaArg(cmplx2str(result, "i"))
}

// IMTAN function returns the tangent of a supplied complex number. The syntax
// of the function is:
//
//	IMTAN(inumber)
func (fn *formulaFuncs) IMTAN(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "IMTAN requires 1 argument")
	}
	value := argsList.Front().Value.(formulaArg).Value()
	inumber, err := strconv.ParseComplex(str2cmplx(value), 128)
	if err != nil {
		return newErrorFormulaArg(formulaErrorNUM, err.Error())
	}
	return newStringFormulaArg(cmplx2str(cmplx.Tan(inumber), value[len(value)-1:]))
}

// OCT2BIN function converts an Octal (Base 8) number into a Binary (Base 2)
// number. The syntax of the function is:
//
//	OCT2BIN(number,[places])
func (fn *formulaFuncs) OCT2BIN(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "OCT2BIN requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "OCT2BIN allows at most 2 arguments")
	}
	token := argsList.Front().Value.(formulaArg)
	number := token.ToNumber()
	if number.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, number.Error)
	}
	decimal, newList := fn.oct2dec(token.Value()), list.New()
	newList.PushBack(decimal)
	if argsList.Len() == 2 {
		newList.PushBack(argsList.Back().Value.(formulaArg))
	}
	return fn.dec2x("OCT2BIN", newList)
}

// OCT2DEC function converts an Octal (a base-8 number) into a decimal number.
// The syntax of the function is:
//
//	OCT2DEC(number)
func (fn *formulaFuncs) OCT2DEC(argsList *list.List) formulaArg {
	if argsList.Len() != 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "OCT2DEC requires 1 numeric argument")
	}
	token := argsList.Front().Value.(formulaArg)
	number := token.ToNumber()
	if number.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, number.Error)
	}
	return fn.oct2dec(token.Value())
}

// OCT2HEX function converts an Octal (Base 8) number into a Hexadecimal
// (Base 16) number. The syntax of the function is:
//
//	OCT2HEX(number,[places])
func (fn *formulaFuncs) OCT2HEX(argsList *list.List) formulaArg {
	if argsList.Len() < 1 {
		return newErrorFormulaArg(formulaErrorVALUE, "OCT2HEX requires at least 1 argument")
	}
	if argsList.Len() > 2 {
		return newErrorFormulaArg(formulaErrorVALUE, "OCT2HEX allows at most 2 arguments")
	}
	token := argsList.Front().Value.(formulaArg)
	number := token.ToNumber()
	if number.Type != ArgNumber {
		return newErrorFormulaArg(formulaErrorVALUE, number.Error)
	}
	decimal, newList := fn.oct2dec(token.Value()), list.New()
	newList.PushBack(decimal)
	if argsList.Len() == 2 {
		newList.PushBack(argsList.Back().Value.(formulaArg))
	}
	return fn.dec2x("OCT2HEX", newList)
}

// oct2dec is an implementation of the formula function OCT2DEC.
func (fn *formulaFuncs) oct2dec(number string) formulaArg {
	decimal, length := 0.0, len(number)
	for i := length; i > 0; i-- {
		num, _ := strconv.Atoi(string(number[length-i]))
		if i == 10 && string(number[length-i]) == "7" {
			decimal += math.Pow(-8.0, float64(i-1))
			continue
		}
		decimal += float64(num) * math.Pow(8.0, float64(i-1))
	}
	return newNumberFormulaArg(decimal)
}

// Math and Trigonometric Functions
